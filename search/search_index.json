{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DAODST Documentation","text":""},{"location":"api/","title":"Home","text":""},{"location":"api/#cli","title":"cli","text":""},{"location":"api/#eth-json-grpc","title":"eth json grpc","text":""},{"location":"api/#cosmos-grpc","title":"cosmos grpc","text":""},{"location":"chat/","title":"Chat","text":""},{"location":"chat/#abstract","title":"Abstract","text":"<p>This document specifies the chat module of the DaoDst.</p>"},{"location":"chat/#contents","title":"Contents","text":"<ol> <li>Concepts</li> <li>State</li> <li>Keeper</li> <li>Messages</li> <li>Parameters</li> </ol>"},{"location":"chat/#module-architecture","title":"Module Architecture","text":"<p>NOTE:: If you're not familiar with the overall module structure from the SDK modules, please check this document as prerequisite reading.</p> <pre><code>chat/\n\u251c\u2500\u2500 client\n\u2502   \u2514\u2500\u2500 rest\n\u2502        \u251c\u2500\u2500 error.go          # errors for api\n\u2502        \u251c\u2500\u2500 grpc.go           # query method fro grpc\n\u2502        \u251c\u2500\u2500 handle_account.go # Account details acquisition and processing\n\u2502        \u251c\u2500\u2500 handle_chat.go    # Chat module message preprocessing\n\u2502        \u251c\u2500\u2500 query.go          # Interface Query Function\n\u2502        \u251c\u2500\u2500 rest.go           # Registration of Message and Query Routes\n\u2502        \u2514\u2500\u2500 tx.go             # Tx related methods, including broadcasting, etc\n\u251c\u2500\u2500 keeper\n\u2502   \u251c\u2500\u2500 genesis.go        # Genesis state for the module\n\u2502   \u251c\u2500\u2500 keeper.go         # Store keeper that handles the business logic of the module and has access to a specific subtree of the state tree.\n\u2502   \u251c\u2500\u2500 msg_server.go     # Provide message service processing logic\n\u2502   \u251c\u2500\u2500 params.go         # Parameter getter and setter\n\u2502   \u251c\u2500\u2500 query.go          # State query functions\n\u251c\u2500\u2500 types\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 codec.go          # Type registration for encoding\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 errors.go         # Module-specific errors\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 events.go         # Events exposed to the Tendermint PubSub/Websocket\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 genesis.go        # Genesis state for the module\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 interface.go      # interface of the module\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 keys.go           # Store keys and utility functions\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 msg.go            # chat module transaction messages\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 params.go         # Module parameters that can be customized with governance parameter change proposals\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 types.go          # Type collection of modules\n\u251c\u2500\u2500 genesis.go            # ABCI InitGenesis and ExportGenesis functionality\n\u251c\u2500\u2500 handler.go            # Message routing\n\u2514\u2500\u2500 module.go             # Module setup for the module manager\n</code></pre>"},{"location":"chat/#concepts","title":"Concepts","text":""},{"location":"chat/#chat","title":"Chat","text":"<p>DaoDst, as a blockchain with decentralized chat, mainly manages the chat data on the chain through the 'x/chat' module, When a user registers for a chat, a broadcast will be initiated, recording the user's address, gateway, DID, chat, and other information on the chain. When other functions or modules need to call these data, they also need to be obtained through the chat module</p>"},{"location":"chat/#state","title":"State","text":"<p>The Chat module stores basic on chain data about chat users</p> <pre><code>// User Info\ntype UserInfo struct {\n    //Wallet address\n    FromAddress string `json:\"from_address\" yaml:\"from_address\"`\n    //Register Gateway\n    RegisterNodeAddress string `json:\"register_node_address\" yaml:\"register_node_address\"`\n    //Current gateway\n    NodeAddress string `json:\"node_address\" yaml:\"node_address\"`\n    //address book\n    AddressBook string `json:\"address_book\" yaml:\"address_book\"`\n    //Address book blacklist (user public key encryption)\n    ChatBlacklist string `json:\"chat_blacklist\" yaml:\"chat_blacklist\"`\n    //Chat restriction mode (feel | any | list)\n    ChatRestrictedMode string `json:\"chat_restricted_mode\" yaml:\"chat_restricted_mode\"`\n    //Address book whitelist (user public key encryption)\n    ChatWhitelist string `json:\"chat_whitelist\" yaml:\"chat_whitelist\"`\n    //Chat fee\n    ChatFee types.Coin `json:\"chat_fee\" yaml:\"chat_fee\"`\n    //Holding a mobile phone number\n    Mobile []string `json:\"mobile\" yaml:\"mobile\"`\n    //Last update time\n    UpdateTime int64 `json:\"update_time\" yaml:\"update_time\"`\n    //Address book blacklist (gateway public key encryption)\n    ChatBlackEncList string `json:\"chat_black_enc_list\" yaml:\"chat_black_enc_list\"`\n    //Address book whitelist (gateway public key encryption)\n    ChatWhiteEncList string `json:\"chat_white_enc_list\" yaml:\"chat_white_enc_list\" `\n    //remarks\n    Remarks string `json:\"remarks\" yaml:\"remarks\"`\n}\n</code></pre> <p>Users will initialize it during registration, The ChatRestrictedMode and ChatFee parameters regarding chat fees will have default values Most of the business logic of the Chat module is based on this structure</p>"},{"location":"chat/#did","title":"DID","text":"<p>When registering, users need to select the gateway they belong to and select a number range that belongs to the gateway Under this number range, users will receive a unique number (DID) that belongs to the wallet address (even if the gateway no longer exists) Outside of the preceding number range, subsequent numbers are incremented</p> <p>For example, in the 8888888 number segment of a certain gateway, the number in this segment has already reached 1234 So the next person to choose this number range will receive a number of 8888881235</p> <p>In addition to registration, you can also proactively destroy to obtain DID</p> <p>Did can voluntarily transfer</p>"},{"location":"chat/#destruction-and-pledge","title":"Destruction and Pledge","text":"<p>When registering for chat, a certain number of DSTs need to be destroyed. At the same time, the registration contract will automatically pledge the destroyed hash coins to the Pledge module, thereby obtaining a pledge reward</p>"},{"location":"chat/#chat-charging-mode","title":"Chat charging mode","text":"<p>When users register, the default chat charging mode is \"fee\", and users can change it themselves</p> <p>There are three modes as follows</p> <ul> <li>fee</li> </ul> <p>After activating the fee mode, initiating a chat or pulling into a room requires a certain fee to be paid</p> <ul> <li>any</li> </ul> <p>After opening any mode, anyone can initiate a chat with you voluntarily</p> <ul> <li>list</li> </ul> <p>After turning on the whitelist mode, only the addresses on the whitelist can initiate a chat with you (the whitelist settings belong to the chat module)</p>"},{"location":"chat/#keeper","title":"Keeper","text":"<p>The Chat module <code>Keeper</code> grants access to the Chat module state and implements <code>statedb.Keeper</code> interface to support the <code>StateDB</code> implementation. The Keeper contains a store key that allows the DB to write to a concrete subtree of the multistore that is only accessible by the Chat module. Instead of using a trie and database for querying and persistence (the <code>StateDB</code> implementation), Daodst uses the Cosmos <code>KVStore</code> (key-value store) and Cosmos SDK <code>Keeper</code> to facilitate state transitions.</p> <p>To support the interface functionality, it imports 4 module Keepers:</p> <ul> <li><code>auth</code>: CURD for accounts</li> <li><code>bank</code>: CURD for supply and balance</li> <li><code>comm</code>: Management of gateway related data</li> <li><code>pledge</code>: Pledge, Destruction, and Rewards</li> </ul> <pre><code>type Keeper struct {\n    storeKey   sdk.StoreKey\n    cdc        codec.BinaryCodec\n    paramstore paramtypes.Subspace\n\n    accountKeeper types.AccountKeeper\n    bankKeeper    types.BankKeeper\n    commKeeper    commkeeper.Keeper\n    pledgeKeeper  pledgekeeper.Keeper\n}\n\n</code></pre>"},{"location":"chat/#messages","title":"Messages","text":""},{"location":"chat/#msgsendgift","title":"MsgSendGift","text":"<pre><code>Register the address to the chat module and initialize the corresponding information through this message\n</code></pre> <pre><code>      type MsgRegister struct {\n          FromAddress    string     `protobuf:\"bytes,1,opt,name=from_address,json=fromAddress,proto3\" json:\"from_address,omitempty\" yaml:\"from_address\"`\n          NodeAddress    string     `protobuf:\"bytes,2,opt,name=node_address,json=nodeAddress,proto3\" json:\"node_address,omitempty\" yaml:\"node_address\"`\n          MortgageAmount types.Coin `protobuf:\"bytes,3,opt,name=mortgage_amount,json=mortgageAmount,proto3\" json:\"mortgage_amount\" yaml:\"mortgage_amount\"`\n          MobilePrefix   string     `protobuf:\"bytes,4,opt,name=mobile_prefix,json=mobilePrefix,proto3\" json:\"mobile_prefix,omitempty\" yaml:\"mobile_prefix\"`\n      }\n</code></pre>"},{"location":"chat/#msgsetchatinfo","title":"MsgSetChatInfo","text":"<pre><code>Modify the data stored in the chat module corresponding to the address through this message, which accepts the full amount of user data and overwrites the original data\n</code></pre> <pre><code>    type MsgSetChatInfo struct {\n        FromAddress        string     `protobuf:\"bytes,1,opt,name=from_address,json=fromAddress,proto3\" json:\"from_address,omitempty\" yaml:\"from_address\"`\n        NodeAddress        string     `protobuf:\"bytes,2,opt,name=node_address,json=nodeAddress,proto3\" json:\"node_address,omitempty\" yaml:\"node_address\"`\n        AddressBook        string     `protobuf:\"bytes,3,opt,name=address_book,json=addressBook,proto3\" json:\"address_book,omitempty\" yaml:\"address_book\"`\n        ChatBlacklist      string     `protobuf:\"bytes,4,opt,name=chat_blacklist,json=chatBlacklist,proto3\" json:\"chat_blacklist,omitempty\" yaml:\"chat_blacklist\"`\n        ChatRestrictedMode string     `protobuf:\"bytes,5,opt,name=chat_restricted_mode,json=chatRestrictedMode,proto3\" json:\"chat_restricted_mode,omitempty\" yaml:\"chat_limit\"`\n        ChatFee            types.Coin `protobuf:\"bytes,6,opt,name=chat_fee,json=chatFee,proto3\" json:\"chat_fee\" yaml:\"chat_fee\"`\n        ChatWhitelist      string     `protobuf:\"bytes,7,opt,name=chat_whitelist,json=chatWhitelist,proto3\" json:\"chat_whitelist,omitempty\" yaml:\"chat_whitelist\"`\n        UpdateTime         int64      `protobuf:\"varint,8,opt,name=update_time,json=updateTime,proto3\" json:\"update_time,omitempty\" yaml:\"update_time\"`\n        ChatBlacklistEnc   string     `protobuf:\"bytes,9,opt,name=chat_blacklist_enc,json=chatBlacklistEnc,proto3\" json:\"chat_blacklist_enc,omitempty\" yaml:\"chat_blacklist_enc\"`\n        ChatWhitelistEnc   string     `protobuf:\"bytes,10,opt,name=chat_whitelist_enc,json=chatWhitelistEnc,proto3\" json:\"chat_whitelist_enc,omitempty\" yaml:\"chat_whitelist_enc\"`\n    }\n</code></pre>"},{"location":"chat/#msgburngetmobile","title":"MsgBurnGetMobile","text":"<pre><code>By destroying this message, the did is obtained. The prefix of the obtained did is the selected did number segment, and the suffix is incremented under this number segment\nIf the number segment does not match the gateway or the number under the segment is full, the acquisition fails\n</code></pre> <pre><code>    type MsgBurnGetMobile struct {\n        FromAddress  string `protobuf:\"bytes,1,opt,name=from_address,json=fromAddress,proto3\" json:\"from_address,omitempty\" yaml:\"from_address\"`\n        MobilePrefix string `protobuf:\"bytes,2,opt,name=mobile_prefix,json=mobilePrefix,proto3\" json:\"mobile_prefix,omitempty\" yaml:\"mobile_prefix\"`\n    }\n</code></pre>"},{"location":"chat/#msgmobiletransfer","title":"MsgMobileTransfer","text":"<pre><code>The held DID can be transferred\nIf the other party's hold of DID has reached the maximum holding amount, the transfer fails\n</code></pre> <pre><code>    type MsgMobileTransfer struct {\n        FromAddress string `protobuf:\"bytes,1,opt,name=from_address,json=fromAddress,proto3\" json:\"from_address,omitempty\" yaml:\"from_address\"`\n        ToAddress   string `protobuf:\"bytes,2,opt,name=to_address,json=toAddress,proto3\" json:\"to_address,omitempty\" yaml:\"to_address\"`\n        Mobile      string `protobuf:\"bytes,3,opt,name=mobile,proto3\" json:\"mobile,omitempty\" yaml:\"mobile\"`\n    }\n</code></pre>"},{"location":"chat/#msgchatsendgift","title":"MsgChatSendGift","text":"<pre><code>Chat payment. If the other party has set a chat fee, this message needs to be sent to pay a certain token to the other party\n</code></pre> <pre><code>    type MsgChatSendGift struct {\n        FromAddress string     `protobuf:\"bytes,1,opt,name=from_address,json=fromAddress,proto3\" json:\"from_address,omitempty\" yaml:\"from_address\"`\n        ToAddress   string     `protobuf:\"bytes,2,opt,name=to_address,json=toAddress,proto3\" json:\"to_address,omitempty\" yaml:\"to_address\"`\n        GiftValue   types.Coin `protobuf:\"bytes,3,opt,name=gift_value,json=giftValue,proto3\" json:\"gift_value\" yaml:\"gift_value\"`\n    }\n</code></pre>"},{"location":"chat/#parameters","title":"Parameters","text":"<p>The chat module contains the following module parameters</p>"},{"location":"chat/#params","title":"Params","text":"Key Type Default Value <code>MaxPhoneNumber</code> uint64 <code>10</code> <code>DestroyPhoneNumberCoin</code> github.com/cosmos/cosmos-sdk/types.Coin <code>100000000000000000000dst</code> <code>ChatFee</code> github.com/cosmos/cosmos-sdk/types.Coin <code>1000000000000000000dst</code> <code>MinRegisterBurnAmount</code> github.com/cosmos/cosmos-sdk/types.Coin <code>100000000000000000000dst</code>"},{"location":"contract/","title":"Contract","text":""},{"location":"contract/#abstract","title":"Abstract","text":"<p>This module is responsible for transactions and queries related to evm</p>"},{"location":"contract/#contents","title":"Contents","text":"<ol> <li>Concepts</li> <li>Keeper</li> <li>Messages</li> </ol> <pre><code>chat/\n\u251c\u2500\u2500 client\n\u2502 \u2514\u2500\u2500 rest\n\u2502 \u251c\u2500\u2500 error.go # interface error collection\n\u2502 \u251c\u2500\u2500 grpc.go # grpc query method\n\u2502 \u251c\u2500\u2500 handle_comm.go # comm module message pre-processing\n\u2502 \u251c\u2500\u2500 query.go # interface query function\n\u2502 \u251c\u2500\u2500 rest.go # Registration of message and query routing\n\u2502 \u2514\u2500\u2500 tx.go # tx related methods, including broadcasting, etc.\n\u251c\u2500\u2500keeper\n\u2502 \u251c\u2500\u2500 genesis.go # Status and export of modules\n\u2502 \u251c\u2500\u2500 keeper.go # storage manager, handles the business logic of the module, and has permission to access specific subtrees of the state tree\n\u2502 \u251c\u2500\u2500 msg_server.go # Provide service processing logic for uplink messages\n\u2502 \u251c\u2500\u2500 params.go # Setting and obtaining module parameters\n\u2502 \u251c\u2500\u2500 query.go # Status query function\n\u2502 \u251c\u2500\u2500 medal.go # Hash coin pledge calculation related logic algorithm\n\u2502 \u2514\u2500\u2500 mingkeeper.go # Foundry related logic algorithm\n\u251c\u2500\u2500 types\n\u2502 \u251c\u2500\u2500 codec.go # code registration type\n\u2502 \u251c\u2500\u2500 errors.go # module-specific errors\n\u2502 \u251c\u2500\u2500 events.go # Events exposed to Tendermint PubSub/Websocket\n\u2502 \u251c\u2500\u2500 genesis.go # Genesis state of the module\n\u2502 \u251c\u2500\u2500 interface.go # interface collection of modules\n\u2502 \u251c\u2500\u2500 keys.go # module stores key and some other constants\n\u2502 \u251c\u2500\u2500 msg.go # Chat module transaction message\n\u2502 \u251c\u2500\u2500 params.go # The custom parameters that the module can modify through the governance module\n\u2502 \u251c\u2500\u2500 interface.go # The method implemented by the imported external module\n\u2502 \u2514\u2500\u2500 types.go # module type collection\n\u251c\u2500\u2500 genesis.go # ABCI's genesis state initialization and export function\n\u251c\u2500\u2500 handler.go # message routing\n\u2514\u2500\u2500 module.go # Module settings of the module manager\n</code></pre>"},{"location":"contract/#overview","title":"Overview","text":""},{"location":"contract/#contract","title":"Contract","text":"<pre><code> Contract is responsible for the content related to the evm contract\n</code></pre>"},{"location":"contract/#one-click-coin-issuance","title":"One-click coin issuance","text":"<pre><code> Users can directly publish their own tokens on evm through messages, only need to upload some basic information of tokens, no need to deploy token contracts\n Everything is done automatically inside the contract\n</code></pre>"},{"location":"contract/#cross-chain-transfer","title":"Cross-chain transfer","text":"<pre><code> This module can be used to realize the token mapping transfer (such as ETH) from DaoDst to the external chain, and the cross-chain supports two-way\n\n When DaoDst transfers funds to the external chain, the balance inside DaoDst will be frozen, and at the same time, the external chain contract will issue corresponding tokens\n Correspondingly, when the opposite operation is performed, the external chain is destroyed and Daodst is unfrozen\n</code></pre>"},{"location":"contract/#keeper","title":"Keeper","text":"<p>The contract module 'Keeper' grants access to the state of the chat module And implement 'statedb. Interface to support 'StateDB' implementation. Keeper contains a storage key that allows the repository Write to the concrete subtree of the multibase that can only be accessed by the Chat module. Instead of using trees and databases for querying and persistence (the 'StateDB' implementation), DaoDst uses Cosmos' \"KVStore\" (key-value store) and Cosmos SDK's \"Keeper\" to facilitate state transitions.</p> <p>In order to support the interface function, it imports 7 module Keepers:</p> <ul> <li><code>auth</code>: addition, deletion, modification and query of accounts</li> <li><code>bank</code>: addition, deletion, modification and query of supply and balance</li> <li><code>staking</code>: management of gateway related data</li> <li><code>pledge</code>: management of chat related data</li> <li><code>evm</code>: management of evm related data</li> <li><code>chat</code>: management of chat related data</li> <li><code>gateway</code>: gateway data management</li> </ul> <pre><code>    type Keeper struct {\n        storeKey   sdk.StoreKey\n        cdc        codec.BinaryCodec\n        paramstore paramtypes.Subspace\n\n        stakingKeeper *stakingKeeper.Keeper\n        accountKeeper types.AccountKeeper\n        BankKeeper    types.BankKeeper\n        pledgeKeeper  types.PledgeKeeper\n        evmKeeper     types.EVMKeeper\n        chatKeeper    types.ChatKeeper\n        gatewayKeeper types.GatewayKeeper\n        erc20Keeper   erc20keeper.Keeper\n    }\n</code></pre>"},{"location":"contract/#messages","title":"Messages","text":""},{"location":"contract/#msgapptokenissue","title":"MsgAppTokenIssue","text":"<pre><code>Through this message, initiate one-click coin issuance\n</code></pre> <pre><code>    type MsgAppTokenIssue struct {\n        FromAddress   string `protobuf:\"bytes,1,opt,name=from_address,json=fromAddress,proto3\" json:\"from_address,omitempty\" yaml:\"from_address\"`\n        Name          string `protobuf:\"bytes,2,opt,name=name,proto3\" json:\"name,omitempty\" yaml:\"name\"`\n        Symbol        string `protobuf:\"bytes,3,opt,name=symbol,proto3\" json:\"symbol,omitempty\" yaml:\"symbol\"`\n        PreMintAmount string `protobuf:\"bytes,4,opt,name=pre_mint_amount,json=preMintAmount,proto3\" json:\"pre_mint_amount,omitempty\" yaml:\"pre_mint_amount\"`\n        Decimals      string `protobuf:\"bytes,5,opt,name=decimals,proto3\" json:\"decimals,omitempty\" yaml:\"decimals\"`\n        LogoUrl       string `protobuf:\"bytes,6,opt,name=logo_url,json=logoUrl,proto3\" json:\"logo_url,omitempty\" yaml:\"logo_url\"`\n    }\n</code></pre>"},{"location":"contract/#msgcrosschainout","title":"MsgCrossChainOut","text":"<pre><code>Through this message, initiate a cross-chain transfer from DaoDst\n</code></pre> <pre><code>    type MsgCrossChainOut struct {\n        SendAddress string `protobuf:\"bytes,1,opt,name=send_address,json=sendAddress,proto3\" json:\"send_address,omitempty\" yaml:\"send_address\"`\n        ToAddress   string `protobuf:\"bytes,2,opt,name=to_address,json=toAddress,proto3\" json:\"to_address,omitempty\" yaml:\"to_address\"`\n        Coins       string `protobuf:\"bytes,3,opt,name=coins,proto3\" json:\"coins,omitempty\" yaml:\"coins\"`\n        ChainType   string `protobuf:\"bytes,4,opt,name=chain_type,json=chainType,proto3\" json:\"chain_type,omitempty\" yaml:\"chain_type\"`\n        Remark      string `protobuf:\"bytes,5,opt,name=remark,proto3\" json:\"remark,omitempty\" yaml:\"remark\"`\n    }\n</code></pre>"},{"location":"contract/#msgcrosschainin","title":"MsgCrossChainIn","text":"<p>Through this message, a cross-chain transfer to DaoDst is initiated from the external chain</p> <pre><code>    type MsgCrossChainIn struct {\n        SendAddress string `protobuf:\"bytes,1,opt,name=send_address,json=sendAddress,proto3\" json:\"send_address,omitempty\" yaml:\"send_address\"`\n        Coins       string `protobuf:\"bytes,2,opt,name=coins,proto3\" json:\"coins,omitempty\" yaml:\"coins\"`\n        ChainType   string `protobuf:\"bytes,3,opt,name=chain_type,json=chainType,proto3\" json:\"chain_type,omitempty\" yaml:\"chain_type\"`\n        Remark      string `protobuf:\"bytes,4,opt,name=remark,proto3\" json:\"remark,omitempty\" yaml:\"remark\"`\n        TxHash      string `protobuf:\"bytes,5,opt,name=tx_hash,json=txHash,proto3\" json:\"tx_hash,omitempty\" yaml:\"tx_hash\"`\n    }\n</code></pre>"},{"location":"evm/","title":"Evm","text":""},{"location":"evm/#abstract","title":"Abstract","text":"<p>This document defines the specification of the Ethereum Virtual Machine (EVM) as a Cosmos SDK module.</p> <p>Since the introduction of Ethereum in 2015, the ability to control digital assets through [smart contracts] has attracted a large number of developers to build decentralized applications on the Ethereum Virtual Machine (EVM). This community continues to create a wide range of tools and introduce standards, which further increases the adoption rate of EVM-compatible technologies.</p> <p>However, the growth of EVM-based chains such as Ethereum has revealed some scalability challenges, often referred to as the decentralization, security, and scalability trilemma. Developers are frustrated by high gas fees, slow transaction speeds and throughput, and chain-specific governance that undergoes only slow changes due to their widely deployed applications. A solution is needed to allay these concerns for developers building applications in the familiar EVM environment.</p> <p>The <code>x/evm</code> module provides this EVM familiarity on scalable, high-throughput proof-of-stake blockchains. It is built as a Cosmos SDK module, allowing deployment of smart contracts, interaction with the EVM state machine (state transitions), and use of EVM tools . It is available for Cosmos application-specific blockchains through Tendermint Core high transaction throughput, fast transaction finality and IBC to alleviate the above problems.</p>"},{"location":"evm/#content","title":"content","text":"<ol> <li>Concepts</li> <li>state</li> <li>state transitions</li> <li>Transactions</li> <li>ABCI</li> <li>hooks</li> <li>Events</li> <li>Parameters</li> <li>client</li> </ol>"},{"location":"evm/#module-architecture","title":"Module architecture","text":"<p>Note:: If you are not familiar with the overall module structure of SDK modules, please read this document first as a prerequisite .</p> <pre><code>evm/\n\u251c\u2500\u2500 client\n\u2502 \u2514\u2500\u2500 cli\n\u2502 \u251c\u2500\u2500 query.go # Module CLI query command\n\u2502 \u2514\u2500\u2500 tx.go # CLI transaction command of the module\n\u251c\u2500\u2500keeper\n\u2502 \u251c\u2500\u2500 abci.go # ABCI start and end block logic\n\u2502 \u251c\u2500\u2500 keeper.go # Process the business logic of the module.\n\u2502 \u251c\u2500\u2500 params.go # parameter getter and setter\n\u2502 \u251c\u2500\u2500 queryer.go # status query function\n\u2502 \u2514\u2500\u2500 statedb.go # Functions from types/statedb passed into sdk.Context\n\u251c\u2500\u2500 types\n\u2502 \u251c\u2500\u2500 chain_config.go\n\u2502 \u251c\u2500\u2500 codec.go # Encoding type registration\n\u2502 \u251c\u2500\u2500 errors.go # Module-specific errors\n\u2502 \u251c\u2500\u2500 events.go # Events exposed to Tendermint PubSub/Websocket\n\u2502 \u251c\u2500\u2500 genesis.go # Genesis state of the module\n\u2502 \u251c\u2500\u2500 journal.go # Ethereum state transition transactions\n\u2502 \u251c\u2500\u2500 keys.go # Store keys and utility functions\n\u2502 \u251c\u2500\u2500 logs.go # Persistent Ethereum tx login status type after chain upgrade\n\u2502 \u251c\u2500\u2500 msg.go #EVM module transaction message\n\u2502 \u251c\u2500\u2500 params.go # Governance parameters can be used to change suggested custom module parameters\n\u2502 \u251c\u2500\u2500 state_object.go # EVM state object\n\u2502 \u251c\u2500\u2500 statedb.go # Implementation of StateDb interface\n\u2502 \u251c\u2500\u2500 storage.go # Use arrays to implement Ethereum state storage mapping to prevent non-determinism\n\u2502 \u2514\u2500\u2500 tx_data.go # Ethereum transaction data type\n\u251c\u2500\u2500 genesis.go # ABCI InitGenesis and ExportGenesis functions\n\u251c\u2500\u2500 handler.go # message routing\n\u2514\u2500\u2500 module.go # Module settings for the module manager\n</code></pre>"},{"location":"evm/#concept","title":"concept","text":""},{"location":"evm/#evm","title":"EVM","text":"<p>The Ethereum Virtual Machine (EVM) is a computing engine that can be thought of as a single entity maintained by thousands of connected computers (nodes) running Ethereum clients. As a virtual machine (VM), the EVM is responsible for computing state changes deterministically, regardless of its environment (hardware and operating system). This means that given the same starting state and transaction (tx), each node must achieve the exact same result.</p> <p>The EVM is considered part of the Ethereum protocol that handles deployment and execution of smart contracts.</p> <p>To clearly distinguish between:</p> <ul> <li>The Ethereum protocol describes a blockchain in which all Ethereum accounts and smart contracts exist.   It has only one canonical state (a data structure that holds all accounts) in any given block in the chain.</li> <li>However, the EVM is a state machine, which defines the rules for computing a new valid state from one block to another.   It is an isolated runtime, which means that code running inside the EVM cannot access the network, file system, or other processes (not external APIs).</li> </ul> <p>The <code>x/evm</code> module implements the EVM as a Cosmos SDK module. It allows users to interact with the EVM by submitting Ethereum transactions and executing the contained messages on a given state to induce state transitions.</p>"},{"location":"evm/#state","title":"state","text":"<p>The Ethereum state is a data structure, implemented as a Merkle Patricia Tree, that keeps all accounts on-chain. The EVM makes changes to this data structure, resulting in a new state with a different state root. Therefore, Ethereum can be viewed as a state chain that transitions from one state to another by executing transactions in blocks using the EVM. A new txs block can be described by its block header (parent hash, block number, timestamp, nonce, receipt...).</p>"},{"location":"evm/#account","title":"account","text":"<p>There are two types of accounts that can be stored in the state for a given address:</p> <ul> <li>Externally Owned Account (EOA): Has nonce (tx counter) and balance</li> <li>Smart Contract: with nonce, balance, (immutable) code hash, storage root (another Merkle Patricia Trie)</li> </ul> <p>A smart contract is like a regular account on the blockchain, it also stores executable code in an Ethereum-specific binary format called EVM bytecode. They are usually written in an Ethereum high-level language, such as Solidity, which is compiled to EVM bytecode and deployed on the blockchain by submitting transactions using the Ethereum client.</p>"},{"location":"evm/#structure","title":"structure","text":"<p>The EVM operates as a stack-based machine. Its main architectural components include:</p> <ul> <li>Virtual ROM: Contract code is pulled into this read-only memory when processing txs</li> <li>Machine state (volatile): changes as the EVM runs and is cleared after processing each tx<ul> <li>Program counter (PC)</li> <li>Gas\u200b\u200b: track how much gas is used<ul> <li>stack and memory: computing state changes</li> </ul> </li> </ul> </li> <li>Access account storage (persistent)</li> </ul>"},{"location":"evm/#state-transition-of-smart-contract","title":"State transition of smart contract","text":"<p>Typically, smart contracts expose a public ABI, which is a list of supported ways users can interact with the contract. To interact with a contract and invoke a state transition, a user submits a transaction carrying an arbitrary amount of gas and a data payload formatted according to the ABI, specifying the interaction type and any other parameters. When a tx is received, the EVM executes the EVM bytecode of the smart contract using the tx payload.</p>"},{"location":"evm/#execute-evm-bytecode","title":"Execute EVM bytecode","text":"<p>A contract's EVM bytecode consists of basic operations (addition, multiplication, store, etc.), called opcodes. Each Opcode execution requires gas paid for in tx. Therefore, the EVM is considered quasi-Turing-complete because it allows arbitrary computations, but the amount of computation during contract execution is limited to the amount of gas provided in tx.</p> <p>The gas cost of each opcode reflects the cost of running these operations on actual computer hardware (e.g. <code>ADD = 3gas</code> and <code>SSTORE = 100gas</code> `). To calculate the gas consumption of a transaction, multiply the gas cost by the gas price, which may vary based on the demand of the network at the time. If the network is heavily loaded, you may need to pay a higher gas price to execute your transaction. If the gas limit is reached (gas exception), no changes will be made to the Ethereum state unless the sender's nonce increases and their balance decreases to pay for wasting EVM time.</p> <p>Smart contracts can also call other smart contracts. Every call to a new contract creates a new EVM instance (including new stack and memory). Each invocation passes the sandbox state to the next EVM. If the gas runs out, all state changes will be discarded. Otherwise, they will be preserved.</p> <p>For further reading, see:</p> <ul> <li>EVM</li> <li>EVM Architecture</li> <li>What is Ethereum</li> <li>Opcodes</li> </ul>"},{"location":"evm/#daodst-implemented-as-geth","title":"Daodst implemented as Geth","text":"<p>Daodst includes an implementation of the Ethereum Protocol in Golang (Geth) as a Cosmos SDK module. Geth includes an implementation of the EVM to compute state transitions. Check out the go-ethereum source code to see how the EVM opcodes are implemented. Just as Geth can run as an Ethereum node, Daodst can also run as a node to compute state transitions of the EVM. Daodst supports Geth's standard for compatibility with Web3 and EVM.</p>"},{"location":"evm/#json-rpc","title":"JSON-RPC","text":"<p>JSON-RPC is a stateless, lightweight remote procedure call (RPC) protocol. The specification mainly defines several data structures and their processing rules. It's transport-agnostic, as the concepts can be used in the same process, over sockets, over HTTP, or in many different messaging environments. It uses JSON (RFC 4627) as the data format.</p> <p> JSON-RPC example: <code>eth_call</code> </p> <p>The JSON-RPC method allows you to execute messages against contracts. Typically, you need to send a transaction to a Geth node to include it in the mempool, then the nodes propagate to each other, and eventually the transaction is included in a block and executed. However, <code>eth_call</code> allows you to send data to a contract and see what happens without committing the transaction.</p> <p>In the Geth implementation, the call endpoint roughly goes through the following steps:</p> <ol> <li>The <code>eth_call</code> request is converted to call the <code>func (s *PublicBlockchainAPI) Call()</code> function using the <code>eth</code> namespace</li> <li><code>Call()</code> is given the transaction parameters, the block to call and an optional Parameters to modify the state to call.    Then it calls <code>DoCall()</code>.</li> <li><code>DoCall()</code>    Convert arguments to <code>ethtypes.message</code>, instantiate the EVM and apply the message using <code>core.ApplyMessage</code></li> <li><code>ApplyMessage()</code>    Call state transition <code>TransitionDb()</code></li> <li><code>TransitionDb()</code> <code>Create()</code> is a new contract or <code>Call()</code> is a contract</li> <li><code>evm.Call()</code>    Run the interpreter evm.interpreter.Run() to execute the message.    If the execution fails, the state will revert to the snapshot taken before execution and consume gas.</li> <li><code>Run()</code>    Execute a loop to execute opcodes.</li> </ol>"},{"location":"evm/#status-db","title":"Status DB","text":"<p>The <code>StateDB</code> interface from go-ethereum represents the EVM database for full state queries. EVM state transitions are enabled by this interface, implemented by <code>Keeper</code> in the <code>x/evm</code> module. The implementation of this interface makes Daodst EVM compatible.</p>"},{"location":"evm/#consensus-engine","title":"Consensus Engine","text":"<p>Applications using the <code>x/evm</code> module interact with the Tendermint core consensus engine through the Application Blockchain Interface (ABCI). Together, the application and Tendermint Core form a program that runs a full blockchain and combines business logic with decentralized data storage.</p> <p>Ethereum transactions submitted to the <code>x/evm</code> module participate in this consensus process before executing and changing application state. We encourage understanding the basics of the Tendermint consensus engine in order to understand state transitions in detail.</p>"},{"location":"evm/#transaction-record","title":"Transaction Record","text":"<p>In each <code>x/evm</code> transaction, the result contains the Ethereum <code>log</code> from the state machine execution, which is used by the JSON-RPC Web3 server for filter queries and processing EVM hooks.</p> <p>The tx log is stored in temporary storage during tx execution and then emitted via cosmos events after the transaction. They can be queried via gRPC and JSON-RPC.</p>"},{"location":"evm/#block-bloom","title":"Block Bloom","text":"<p>bloom is the bloom filter value (in bytes) per block available for filter queries. Block bloom values are stored in transient storage and then emitted via cosmos events during EndBlock processing. They can be queried via gRPC and JSON-RPC.</p> <p>:::hint</p> <p>\ud83d\udc49 NOTE: Since they are not stored in state, transaction logs and block blooms are not persisted after upgrades. Users must use an archive node after upgrading to get legacy chain events. :::</p>"},{"location":"evm/#state_1","title":"state","text":"<p>This section provides an overview of objects stored in the state of the <code>x/evm</code> module, functionality derived from the go-ethereum <code>StateDB</code> interface, and its implementation via Keeper and state implementation at genesis.</p>"},{"location":"evm/#state-object","title":"State object","text":"<p>The <code>x/evm</code> module maintains objects in the following states:</p>"},{"location":"evm/#state_2","title":"state","text":"Description Key Value Store Code Smart contract bytecode <code>[]byte{1} + []byte(address)</code> <code>[]byte{code}</code> KV Storage Smart contract storage <code>[]byte{2} + [32]byte{key}</code> <code>[32]byte(value)</code> KV Block Bloom Block bloom filter, used to accumulate the bloom filter of the current block and send to the end blocker event. <code>[]byte{1} + []byte(tx.Hash)</code> <code>protobuf([]Log)</code> Transient Tx Index The index of the current transaction in the current block. <code>[]byte{2}</code> <code>BigEndian(uint64)</code> Transient Log Size The number of logs emitted so far in the current block. Log index used to determine subsequent logs. <code>[]byte{3}</code> <code>BigEndian(uint64)</code> Transient Gas Used The amount of gas used by the ethereum message of the current cosmos-sdk tx, which is required when the cosmos-sdk tx contains multiple ethereum messages. <code>[]byte{4}</code> <code>BigEndian(uint64)</code> Transient"},{"location":"evm/#status-db_1","title":"Status DB","text":"<p>The <code>StateDB</code> interface is implemented by <code>StateDB</code> in the <code>x/evm/statedb</code> module, which represents an EVM database for complete state queries of contracts and accounts. In the Ethereum protocol, <code>StateDB</code> is used to store anything in the IAVL tree and is responsible for caching and storing nested states.</p> <pre><code>// github.com/ethereum/go-ethereum/core/vm/interface.go\ntype StateDB interface {\n CreateAccount(common.Address)\n\n SubBalance(common.Address, *big.Int)\n AddBalance(common.Address, *big.Int)\n GetBalance(common.Address) *big.Int\n\n GetNonce(common.Address) uint64\n SetNonce(common.Address, uint64)\n\n GetCodeHash(common.Address) common.Hash\n GetCode(common.Address) []byte\n SetCode(common.Address, []byte)\n GetCodeSize(common.Address) int\n\n AddRefund(uint64)\n SubRefund(uint64)\n GetRefund() uint64\n\n GetCommittedState(common.Address, common.Hash) common.Hash\n GetState(common.Address, common.Hash) common.Hash\n SetState(common.Address, common.Hash, common.Hash)\n\n Suicide(common.Address) bool\n HasSuicided(common.Address) bool\n\n // Exist reports whether the given account exists in state.\n // Notably this should also return true for suicided accounts.\n Exist(common.Address) bool\n // Empty returns whether the given account is empty. Empty\n // is defined according to EIP161 (balance = nonce = code = 0).\n Empty(common.Address) bool\n\n PrepareAccessList(sender common.Address, dest *common.Address, precompiles []common.Address, txAccesses types.AccessList)\n AddressInAccessList(addr common.Address) bool\n SlotInAccessList(addr common.Address, slot common.Hash) (addressOk bool, slotOk bool)\n // AddAddressToAccessList adds the given address to the access list. This operation is safe to perform\n // even if the feature/fork is not active yet\n AddAddressToAccessList(addr common.Address)\n // AddSlotToAccessList adds the given (address,slot) to the access list. This operation is safe to perform\n // even if the feature/fork is not active yet\n AddSlotToAccessList(addr common.Address, slot common.Hash)\n\n RevertToSnapshot(int)\n Snapshot() int\n\n AddLog(*types.Log)\n AddPreimage(common.Hash, []byte)\n\n ForEachStorage(common.Address, func(common.Hash, common.Hash) bool) error\n}\n</code></pre> <p>The <code>StateDB</code> in the <code>x/evm</code> provides the following functionalities:</p>"},{"location":"evm/#crud-for-ethereum-accounts","title":"CRUD for Ethereum accounts","text":"<p>You can create an <code>EthAccount</code> instance from a provided address and use <code>createAccount()</code> to set the value to be stored on the <code>AccountKeeper</code>. If an account with the given address already exists, this function also resets any pre-existing code and storage associated with that address.</p> <p>An account's currency balance can be managed through <code>BankKeeper</code>, which can be read using <code>GetBalance()</code> and updated using <code>AddBalance()</code> and <code>SubBalance()</code>.</p> <ul> <li><code>GetBalance()</code> returns the EVM currency balance of the provided address.   The currency name is taken from the module parameters.</li> <li><code>AddBalance()</code> adds the given amount to the address currency balance by minting new currency and transferring it to the address.   The currency name is taken from the module parameters.</li> <li><code>SubBalance()</code> subtracts the given amount from the address balance by transferring currency to escrow accounts and then destroying them.   The currency name is taken from the module parameters.   This function will perform a no-op if the amount is negative or the user does not have enough funds to transfer.</li> </ul> <p>The nonce (or transaction sequence) can be obtained from the account <code>Sequence</code> by the authentication module <code>AccountKeeper</code>.</p> <ul> <li><code>GetNonce()</code> retrieves the account with the given address and returns the tx sequence (i.e. the nonce).   If the account cannot be found, the function will perform a no-op.</li> <li><code>SetNonce()</code> sets the given nonce as sequence of address accounts.   If the account does not exist, a new account will be created from this address.</li> </ul> <p>Smart contract bytecode containing arbitrary contract logic is stored on <code>EVMKeeper</code> and can be queried using <code>GetCodeHash()</code>, <code>GetCode()</code> and <code>GetCodeSize()</code>, and updated using <code>SetCode()</code>.</p> <ul> <li><code>GetCodeHash()</code> gets an account from storage and returns its code hash.   Returns an empty code hash if the account does not exist or is not of type EthAccount.</li> <li><code>GetCode()</code> returns the code byte array associated with the given address.   This function returns nil if the code hash from the account is empty.</li> <li><code>SetCode()</code> stores the code byte array to the application KVStore and sets the code hash to the given account.   If the code is empty, it will be removed from storage.</li> <li><code>GetCodeSize()</code> returns the size of the contract code associated with this object, or zero if none.</li> </ul> <p>The refunded gas needs to be tracked and stored in a separate variable so that it can be subtracted/added to the gas usage value after the EVM execution is complete. The refund value is cleared at the end of each transaction and each block.</p> <ul> <li><code>AddRefund()</code> adds the given amount of gas to the refund value in memory.</li> <li><code>SubRefund()</code> subtracts the given amount of gas from the refund value in memory.   This function will panic if the gas amount is greater than the current refund.</li> <li><code>GetRefund()</code> returns the amount of gas available for return after tx execution completes.   The value resets to 0 on every transaction.</li> </ul> <p>State is stored on <code>EVMKeeper</code>. Can be queried with <code>GetCommittedState()</code>, <code>GetState()</code> and updated with <code>SetState()</code>.</p> <ul> <li><code>GetCommittedState()</code> returns the value set in storage for the given key hash.   If the key is not registered, this function returns an empty hash.</li> <li><code>GetState()</code> returns the in-memory dirty state for the given key hash,   If not present, the submitted value is loaded from the KVStore.</li> <li><code>SetState()</code> sets the given hash (key, value) as state.   This function removes the key from the state if the value hash is empty,   The new value is first kept dirty and finally committed to KVStore.</li> </ul> <p>Accounts can also be set to commit suicide. When the contract commits suicide, the account is marked as suicide, and when the code is committed, the storage and account are deleted (starting from the next block).</p> <ul> <li><code>Suicide()</code> marks the given account as having committed suicide and clears the account balance in EVM tokens.</li> <li><code>HasSuicided()</code> queries the flags in memory to check if the account has been marked as suicidal in the current transaction.   Suicided accounts will return non-zero during queries and be \"cleared\" after the block is committed.</li> </ul> <p>To check if an account exists, use <code>Exist()</code> and <code>Empty()</code>.</p> <ul> <li><code>Exist()</code> returns true if the given account exists in storage or has been marked as suicidal.</li> <li><code>Empty()</code> returns true if the address satisfies the following conditions:<ul> <li>nonce is 0</li> <li>Balance of evm currency is 0</li> <li>account code hash is empty</li> </ul> </li> </ul>"},{"location":"evm/#eip2930-functionality","title":"EIP2930 functionality","text":"<p>Supports transaction types that contain an access list, addresses and storage key lists that the transaction plans to access. Access list state is kept in memory and discarded after transaction commit.</p> <ul> <li><code>PrepareAccessList()</code> handles the preparation steps for performing state transitions on EIP-2929 and EIP-2930.   This method should only be called if Yolov3/Berlin/2929+2930 applies to the current number.<ul> <li>Add sender to access list (EIP-2929)</li> <li>Add destination to access list (EIP-2929)</li> <li>Add precompile to access list (EIP-2929)</li> <li>Add optional tx access list content (EIP-2930)</li> </ul> </li> <li><code>AddressInAccessList()</code> returns true if the address is registered.</li> <li><code>SlotInAccessList()</code> checks if address and slot are registered.</li> <li><code>AddAddressToAccessList()</code> adds the given address to the access list.   If the address is already in the access list, this function performs a no-op.</li> <li><code>AddSlotToAccessList()</code> adds the given (address, slot) to the access list.   This function performs a no-op if the address and slot are already in the access list.</li> </ul>"},{"location":"evm/#snapshot-state-and-restore-functions","title":"Snapshot state and restore functions","text":"<p>The EVM uses state restoration exceptions to handle errors. Such an exception will undo all changes made to the state in the current call (and all its sub-calls), and the caller can handle the error and not propagate. You can use <code>Snapshot()</code> to identify the current state by revision, and <code>RevertToSnapshot()</code> to revert the state to a given revision to support this feature. - <code>Snapshot()</code> creates a new snapshot and returns the identifier. - <code>RevertToSnapshot(rev)</code> undoes all modifications up to the snapshot identified by <code>rev</code>.</p> <p>Daodst adapted the to support this, it uses a journal list in order to record For all the state modification operations done so far, the snapshot consists of a unique id and index in the log list, to revert to a snapshot it just undoes the log logs after the snapshot index in reverse order.</p>"},{"location":"evm/#ethereum-transaction-log","title":"Ethereum transaction log","text":"<p>With <code>AddLog()</code>, you can append a given Ethereum <code>Log</code> to the list of logs associated with the transaction hash saved in the current state. The function also fills in the tx hash, block hash, tx index and log index fields before setting the log to be stored.</p>"},{"location":"evm/#keeper","title":"Keeper","text":"<p>The EVM module <code>Keeper</code> grants access to the state of the EVM module and implements the <code>statedb.Keeper</code> interface to support <code>StateDB</code> implementations. The Keeper contains a storage key that allows the DB to write to a concrete subtree of the multistore that can only be accessed by the EVM module. Instead of using trie and database for query and persistence (<code>StateDB</code> implementation), Daodst uses Cosmos' KVStore (key-value store) and Cosmos SDK's <code>Keeper</code> to facilitate state transitions.</p> <p>To support interface functionality, it imports 4 modules Keepers:</p> <ul> <li><code>auth</code>: CRUD account</li> <li><code>bank</code>: CRUD for accounting (supply) and balances</li> <li><code>staking</code>: query historical headers</li> <li><code>fee market</code>: handle EIP1559 base fee for <code>DynamicFeeTx</code>   After activating the <code>London</code> hard fork on the <code>ChainConfig</code> parameter</li> </ul> <pre><code>type Keeper struct {\n // Protobuf codec\n cdc codec.BinaryCodec\n // Store key required for the EVM Prefix KVStore. It is required by:\n // - storing account's Storage State\n // - storing account's Code\n // - storing Bloom filters by block height. Needed for the Web3 API.\n // For the full list, check the module specification\n storeKey sdk.StoreKey\n\n // key to access the transient store, which is reset on every block during Commit\n transientKey sdk.StoreKey\n\n // module specific parameter space that can be configured through governance\n paramSpace paramtypes.Subspace\n // access to account state\n accountKeeper types.AccountKeeper\n // update balance and accounting operations with coins\n bankKeeper types.BankKeeper\n // access historical headers for EVM state transition execution\n stakingKeeper types.StakingKeeper\n // fetch EIP1559 base fee and parameters\n feeMarketKeeper types.FeeMarketKeeper\n\n // chain ID number obtained from the context's chain id\n eip155ChainID *big.Int\n\n // Tracer used to collect execution traces from the EVM transaction execution\n tracer string\n // trace EVM state transition execution. This value is obtained from the `--trace` flag.\n // For more info check https://geth.ethereum.org/docs/dapp/tracing\n debug bool\n\n // EVM Hooks for tx post-processing\n hooks types.EvmHooks\n}\n</code></pre>"},{"location":"evm/#genesis-state","title":"Genesis state","text":"<p>The <code>x/evm</code> module <code>GenesisState</code> defines the state required to initialize a chain from a previously exported height. It contains <code>GenesisAccounts</code> and module parameters</p> <pre><code>type GenesisState struct {\n   // accounts is an array containing the ethereum genesis accounts.\n   Accounts []GenesisAccount `protobuf:\"bytes,1,rep,name=accounts,proto3\" json:\"accounts\"`\n   // params defines all the parameters of the module.\n   Params Params `protobuf:\"bytes,2,opt,name=params,proto3\" json:\"params\"`\n}\n</code></pre>"},{"location":"evm/#genesis-account","title":"Genesis account","text":"<p>The <code>GenesisAccount</code> type corresponds to an adaptation of the Ethereum <code>GenesisAccount</code> type. It defines an account that is initialized in the genesis state.</p> <p>Its main difference is that the one on Daodst uses a custom <code>Storage</code> type that uses slices instead of evm <code>State</code>'s map (due to non-determinism), and it does not contain a private key field.</p> <p>It is also important to note that since the <code>auth</code> module on the Cosmos SDK manages account state, the <code>Address</code> field must correspond to an existing <code>EthAccount</code> (i.e. <code>AccountKeeper</code>) stored in the <code>auth</code> module <code>Keeper</code>.</p> <p>The address uses EIP55 hexadecimal[format] on <code>genesis.json</code>.</p> <pre><code>type GenesisAccount struct {\n   // address defines an ethereum hex formatted address of an account\n   Address string `protobuf:\"bytes,1,opt,name=address,proto3\" json:\"address,omitempty\"`\n   // code defines the hex bytes of the account code.\n   Code string `protobuf:\"bytes,2,opt,name=code,proto3\" json:\"code,omitempty\"`\n   // storage defines the set of state key values for the account.\n   Storage Storage `protobuf:\"bytes,3,rep,name=storage,proto3,castrepeated=Storage\" json:\"storage\"`\n}\n</code></pre>"},{"location":"evm/#state-transition","title":"state transition","text":"<p>The <code>x/evm</code> module allows users to submit Ethereum transactions (<code>Tx</code>) and execute the messages they contain to induce a state transition on a given state.</p> <p>Users submit transactions on the client side to broadcast them to the network. When a transaction is included in a block during the consensus process, it is executed server-side. We strongly recommend that you learn the basics of the Tendermint consensus engine to learn more about state transitions.</p>"},{"location":"evm/#client","title":"client","text":"<p>:::hint \ud83d\udc49 This is based on <code>eth_sendTransaction</code> JSON-RPC :::</p> <ol> <li> <p>A user submits a transaction via one of the available JSON-RPC endpoints using an Ethereum-compatible client or wallet (e.g. Metamask, WalletConnect, Ledger, etc.):</p> <ul> <li>eth (public) namespace: <code>eth_sendTransaction</code> and <code>eth_sendRawTransaction</code></li> <li>Personal (private) namespace: <code>personal_sendTransaction</code></li> </ul> </li> <li> <p>Create a MsgEthereumTx instance after filling the RPC transaction with SetTxDefaults to fill the missing tx parameter with default values</p> </li> <li>Use ValidateBasic() to validate the <code>Tx</code> field (stateless)</li> <li><code>Tx</code> is signed using the key associated with the sender address and the latest Ethereum hard fork (<code>London</code>, <code>Berlin</code>, etc.) from <code>ChainConfig</code></li> <li><code>Tx</code> is constructed from the msg field using the Cosmos Config builder</li> <li><code>Tx</code> in synchronous mode broadcasting    Make sure to wait for the <code>CheckTx</code> execution response.    The application verifies the transaction using <code>CheckTx()</code> before adding to the consensus engine's mempool.</li> <li>The JSON-RPC user receives a response with the <code>RLP</code> hash of the transaction field.    This hash is different from the default hash used by SDK transactions, which computes a <code>sha256</code> hash of the transaction bytes.</li> </ol>"},{"location":"evm/#server","title":"Server","text":"<p>Once a block (containing \"Tx\") is committed during consensus, it is applied to the application in a series of ABCI messages on the server side.</p> <p>Each <code>Tx</code> is handled by the application by calling <code>RunTx</code>. After stateless verification of each <code>sdk.Msg</code> in <code>Tx</code>, <code>AnteHandler</code> confirms whether <code>Tx</code> is an Ethereum transaction or an SDK transaction. As an Ethereum transaction, it contains messages, which are then processed by the <code>x/evm</code> module to update the state of the application.</p>"},{"location":"evm/#preprocessor","title":"Preprocessor","text":"<p><code>anteHandler</code> runs for every transaction. It checks whether <code>Tx</code> is an Ethereum transaction and routes it to the internal ante handler. Here, <code>Tx</code> is handled using EthereumTx extension options to handle them differently than normal Cosmos SDK transactions. <code>antehandler</code> runs through a list of options and its <code>AnteHandle</code> function for each <code>Tx</code>:</p> <ul> <li><code>EthSetUpContextDecorator()</code> adapted from cosmos-sdk's SetUpContextDecorator which ignores gas consumption by setting the gas meter to infinite</li> <li><code>EthValidateBasicDecorator(evmKeeper)</code> validates fields of Ethereum type Cosmos <code>Tx</code> messages</li> <li><code>EthSigVerificationDecorator(evmKeeper)</code> verifies that the registered chain ID is the same as on the message, and that the signer address matches that defined on the message.   RecheckTx won't skip it because it sets the <code>From</code> address, which is essential for other ante handlers to work.   A failure of RecheckTx will prevent the tx from being included into the block, especially when CheckTx is successful, in which case the user will not see the error message.<ul> <li><code>EthAccountVerificationDecorator(ak, bankKeeper, evmKeeper)</code>   Will verify that the sender balance is greater than the total transaction cost.   If the account does not exist, i.e. cannot be found in the store, the account will be set into the store.   This AnteHandler decorator will fail if:<ul> <li>Any message is not MsgEthereumTx</li> <li>sender address is empty</li> <li>The account balance is lower than the transaction cost</li> </ul> </li> </ul> </li> <li><code>EthNonceVerificationDecorator(ak)</code> verifies that the transaction nonce is valid and equal to the sender account's current nonce.</li> <li><code>EthGasConsumeDecorator(evmKeeper)</code> verifies that the Ethereum tx message is sufficient to pay for inherent gas (during CheckTx only) and that the sender has enough balance to cover the gas cost.   The intrinsic gas of a transaction is the amount of gas used by the transaction before execution.   Gas is a constant value plus any cost incurred by the extra data bytes provided by the transaction.   This AnteHandler decorator will fail if:<ul> <li>Transaction contains multiple messages</li> <li>Message is not MsgEthereumTx</li> <li>No sender account found</li> <li>the gas limit of the transaction is lower than the intrinsic gas</li> <li>User does not have enough balance to deduct transaction fee (gas_limit * gas_price)</li> <li>Transaction or block gas meter runs out of gas</li> </ul> </li> <li><code>CanTransferDecorator(evmKeeper, feeMarketKeeper)</code> creates an EVM from the message and calls the BlockContext CanTransfer function to see if the address can perform a transaction.</li> <li><code>EthIncrementSenderSequenceDecorator(ak)</code> handles the sequence of incrementing signers (i.e. senders).   If the transaction is a contract creation, the nonce will be incremented during transaction execution, not within this AnteHandler decorator.</li> </ul> <p>The options <code>authante.NewMempoolFeeDecorator()</code>, <code>authante.NewTxTimeoutHeightDecorator()</code> and <code>authante.NewValidateMemoDecorator(ak)</code> are the same as Cosmos <code>Tx</code>. Click here to learn more about <code>anteHandler</code>.</p>"},{"location":"evm/#evm-module","title":"EVM module","text":"<p>Each <code>sdk.Msg</code> in <code>Tx</code> (in this case <code>MsgEthereumTx</code>) after being authenticated by <code>antehandler</code> Passed to the Msg Handler in the <code>x/evm</code> module and run through the following steps:</p> <ol> <li>Convert <code>Msg</code> to Ethereum's <code>Tx</code> type</li> <li>Apply <code>Tx</code> with <code>EVMConfig</code> and attempt to perform a state transition, only persisting (committing) to the underlying KVStore if the transaction has not failed:<ol> <li>Confirm that <code>EVMConfig</code> is created</li> <li>Create an Ethereum signer using the chain configuration values from \"EVMConfig\"</li> <li>Set the Ethereum transaction hash to (temporary) temporary storage so that it can also be used for StateDB functions<ol> <li>Generate a new EVM instance</li> </ol> </li> <li>Verify that the EVM parameters for contract creation (<code>EnableCreate</code>) and contract execution (<code>EnableCall</code>) are enabled<ol> <li>App message. If the <code>To</code> address is <code>nil</code>, create a new contract with the code as the deployed code. Else invokes the contract at the given address with the given input as arguments</li> <li>Calculate the gas used by the evm operation</li> </ol> </li> </ol> </li> <li>If the <code>Tx</code> application is successful<ol> <li>Execute the EVM <code>Tx</code> post-processing hook. If the hook returns an error, restore the entire \"Tx\"<ol> <li>Return gas according to the Ethereum gas bookkeeping rules</li> </ol> </li> <li>Update block bloom filter value with log generated from tx</li> <li>Emit SDK events for transaction fields and tx logs</li> </ol> </li> </ol>"},{"location":"evm/#trade","title":"trade","text":"<p>This section defines the <code>sdk.Msg</code> concrete types that cause the state transitions defined in the previous section.</p>"},{"location":"evm/#msgethereumtx","title":"<code>MsgEthereumTx</code>","text":"<p>EVM state transitions can be achieved by using \"MsgEthereumTx\". This message encapsulates the Ethereum transaction data (<code>TxData</code>) as <code>sdk.Msg</code>. It contains the necessary transaction data fields. Note that <code>MsgEthereumTx</code> implements <code>sdk.Msg</code> and <code>sdk .Tx</code> interface. Typically, SDK messages only implement the former, while the latter is a set of messages bundled together.</p> <p>This section defines the <code>sdk.Msg</code> concrete types that cause the state transitions defined in the previous section.</p>"},{"location":"evm/#msgethereumtx_1","title":"<code>MsgEthereumTx</code>","text":"<p>EVM state transitions can be achieved using <code>MsgEthereumTx</code>. This message encapsulates the Ethereum transaction data (<code>TxData</code>) as <code>sdk.Msg</code>. It contains the necessary transaction data fields. Note that <code>MsgEthereumTx</code> implements <code>sdk.Msg</code> and <code>sdk .Tx</code> interface.</p> <p>Typically, SDK messages only implement the former, while the latter is a set of messages bundled together.</p> <pre><code>type MsgEthereumTx struct {\n // inner transaction data\n Data *types.Any `protobuf:\"bytes,1,opt,name=data,proto3\" json:\"data,omitempty\"`\n // DEPRECATED: encoded storage size of the transaction\n Size_ float64 `protobuf:\"fixed64,2,opt,name=size,proto3\" json:\"-\"`\n // transaction hash in hex format\n Hash string `protobuf:\"bytes,3,opt,name=hash,proto3\" json:\"hash,omitempty\" rlp:\"-\"`\n // ethereum signer address in hex format. This address value is checked\n // against the address derived from the signature (V, R, S) using the\n // secp256k1 elliptic curve\n From string `protobuf:\"bytes,4,opt,name=from,proto3\" json:\"from,omitempty\"`\n}\n</code></pre> <p>This message field validation is expected to fail if:</p> <ul> <li>The <code>From</code> field is defined and the address is invalid</li> <li><code>TxData</code> stateless validation failed</li> </ul> <p>Transaction execution is expected to fail if:</p> <ul> <li>Any custom <code>AnteHandler</code> ethereum decorator check fails:<ul> <li>Minimum gas requirement for transactions</li> <li>Tx sender account does not exist or does not have sufficient fee balance</li> <li>account sequence does not match transaction <code>Data.AccountNonce</code></li> <li>message signature verification failed</li> </ul> </li> <li>EVM contract creation (i.e. <code>evm.Create</code>) failed, or <code>evm.Call</code> failed</li> </ul>"},{"location":"evm/#conversion","title":"Conversion","text":"<p><code>MsgEthreumTx</code> can be converted to go-ethereum <code>Transaction</code> and <code>Message</code> types In order to create and call evm contracts.</p> <pre><code>// AsTransaction creates an Ethereum Transaction type from the msg fields\nfunc (msg MsgEthereumTx) AsTransaction() *ethtypes.Transaction {\n  txData, err := UnpackTxData(msg.Data)\n  if err != nil {\n   return nil\n  }\n\n  return ethtypes. NewTx(txData. AsEthereumData())\n}\n\n// AsMessage returns the transaction as a core.Message.\nfunc (tx *Transaction) AsMessage(s Signer, baseFee *big.Int) (Message, error) {\n  msg := Message{\n   nonce: tx.Nonce(),\n   gasLimit: tx. Gas(),\n   gasPrice: new(big.Int).Set(tx.GasPrice()),\n   gasFeeCap: new(big.Int).Set(tx.GasFeeCap()),\n   gasTipCap: new(big.Int).Set(tx.GasTipCap()),\n   to: tx.To(),\n   amount: tx. Value(),\n   data: tx.Data(),\n   accessList: tx.AccessList(),\n   isFake: false,\n  }\n  // If baseFee provided, set gasPrice to effectiveGasPrice.\n  if baseFee != nil {\n   msg.gasPrice = math.BigMin(msg.gasPrice.Add(msg.gasTipCap, baseFee), msg.gasFeeCap)\n  }\n  var err error\n  msg.from, err = Sender(s, tx)\n  return msg, err\n}\n</code></pre>"},{"location":"evm/#sign","title":"sign","text":"<p>For signature verification to work, <code>TxData</code> must contain the <code>v|r|s</code> value from <code>Signer</code>. Sign computes the secp256k1 ECDSA signature and signs the transaction. According to the EIP155 standard, it requires a keyring signer and chainID to sign Ethereum transactions. This method mutates the transaction when filling the V, R, S fields of the transaction signature. The function will fail if no sender address is defined for the message or if the sender is not registered on the keyring.</p> <pre><code>// Sign calculates a secp256k1 ECDSA signature and signs the transaction. It\n// takes a keyring signer and the chainID to sign an Ethereum transaction according to\n// EIP155 standard.\n// This method mutates the transaction as it populates the V, R, S\n// fields of the Transaction's Signature.\n// The function will fail if the sender address is not defined for the msg or if\n// the sender is not registered on the keyring\nfunc (msg *MsgEthereumTx) Sign(ethSigner ethtypes.Signer, keyringSigner keyring.Signer) error {\n from := msg.GetFrom()\n if from.Empty() {\n  return fmt.Errorf(\"sender address not defined for message\")\n }\n\n tx := msg.AsTransaction()\n txHash := ethSigner.Hash(tx)\n\n sig, _, err := keyringSigner.SignByAddress(from, txHash.Bytes())\n if err != nil {\n  return err\n }\n\n tx, err = tx.WithSignature(ethSigner, sig)\n if err != nil {\n  return err\n }\n\n msg.FromEthereumTx(tx)\n return nil\n}\n</code></pre>"},{"location":"evm/#txdata","title":"TxData","text":"<p><code>MsgEthereumTx</code> supports 3 valid Ethereum transaction data types from go-ethereum: <code>LegacyTx</code>, <code>AccessListTx</code>, and <code>DynamicFeeTx</code>. These types are defined as protobuf messages and packed into the <code>proto.Any</code> interface type in the <code>MsgEthereumTx</code> field.</p> <ul> <li><code>LegacyTx</code>: EIP-155 transaction type</li> <li><code>DynamicFeeTx</code>: EIP-1559 transaction type.</li> <li><code>AccessListTx</code>: EIP-2930 transaction type.</li> </ul>"},{"location":"evm/#legacytx","title":"<code>LegacyTx</code>","text":"<p>Transaction data for regular Ethereum transactions.</p> <pre><code>type LegacyTx struct {\n // nonce corresponds to the account nonce (transaction sequence).\n Nonce uint64 `protobuf:\"varint,1,opt,name=nonce,proto3\" json:\"nonce,omitempty\"`\n // gas price defines the value for each gas unit\n GasPrice *github_com_cosmos_cosmos_sdk_types.Int `protobuf:\"bytes,2,opt,name=gas_price,json=gasPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int\" json:\"gas_price,omitempty\"`\n // gas defines the gas limit defined for the transaction.\n GasLimit uint64 `protobuf:\"varint,3,opt,name=gas,proto3\" json:\"gas,omitempty\"`\n // hex formatted address of the recipient\n To string `protobuf:\"bytes,4,opt,name=to,proto3\" json:\"to,omitempty\"`\n // value defines the unsigned integer value of the transaction amount.\n Amount *github_com_cosmos_cosmos_sdk_types.Int `protobuf:\"bytes,5,opt,name=value,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int\" json:\"value,omitempty\"`\n // input defines the data payload bytes of the transaction.\n Data []byte `protobuf:\"bytes,6,opt,name=data,proto3\" json:\"data,omitempty\"`\n // v defines the signature value\n V []byte `protobuf:\"bytes,7,opt,name=v,proto3\" json:\"v,omitempty\"`\n // r defines the signature value\n R []byte `protobuf:\"bytes,8,opt,name=r,proto3\" json:\"r,omitempty\"`\n // s define the signature value\n S []byte `protobuf:\"bytes,9,opt,name=s,proto3\" json:\"s,omitempty\"`\n}\n</code></pre> <p>This message field validation is expected to fail if:</p> <ul> <li><code>GasPrice</code> is invalid (<code>nil</code>, negative or out of range of int256)</li> <li><code>Fee</code> (gasprice * gaslimit) is invalid</li> <li><code>Amount</code> is invalid (negative or out of range of int256)</li> <li>Invalid <code>To</code> address (invalid Ethereum hex address)</li> </ul>"},{"location":"evm/#dynamicfeetx","title":"<code>DynamicFeeTx</code>","text":"<p>Transaction data for EIP-1559 dynamic fee transactions.</p> <pre><code>type DynamicFeeTx struct {\n // destination EVM chain ID\n ChainID *github_com_cosmos_cosmos_sdk_types.Int `protobuf:\"bytes,1,opt,name=chain_id,json=chainId,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int\" json:\"chainID\"`\n // nonce corresponds to the account nonce (transaction sequence).\n Nonce uint64 `protobuf:\"varint,2,opt,name=nonce,proto3\" json:\"nonce,omitempty\"`\n // gas tip cap defines the max value for the gas tip\n GasTipCap *github_com_cosmos_cosmos_sdk_types.Int `protobuf:\"bytes,3,opt,name=gas_tip_cap,json=gasTipCap,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int\" json:\"gas_tip_cap,omitempty\"`\n // gas fee cap defines the max value for the gas fee\n GasFeeCap *github_com_cosmos_cosmos_sdk_types.Int `protobuf:\"bytes,4,opt,name=gas_fee_cap,json=gasFeeCap,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int\" json:\"gas_fee_cap,omitempty\"`\n // gas defines the gas limit defined for the transaction.\n GasLimit uint64 `protobuf:\"varint,5,opt,name=gas,proto3\" json:\"gas,omitempty\"`\n // hex formatted address of the recipient\n To string `protobuf:\"bytes,6,opt,name=to,proto3\" json:\"to,omitempty\"`\n // value defines the the transaction amount.\n Amount *github_com_cosmos_cosmos_sdk_types.Int `protobuf:\"bytes,7,opt,name=value,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int\" json:\"value,omitempty\"`\n // input defines the data payload bytes of the transaction.\n Data     []byte     `protobuf:\"bytes,8,opt,name=data,proto3\" json:\"data,omitempty\"`\n Accesses AccessList `protobuf:\"bytes,9,rep,name=accesses,proto3,castrepeated=AccessList\" json:\"accessList\"`\n // v defines the signature value\n V []byte `protobuf:\"bytes,10,opt,name=v,proto3\" json:\"v,omitempty\"`\n // r defines the signature value\n R []byte `protobuf:\"bytes,11,opt,name=r,proto3\" json:\"r,omitempty\"`\n // s define the signature value\n S []byte `protobuf:\"bytes,12,opt,name=s,proto3\" json:\"s,omitempty\"`\n}\n</code></pre> <p>This message field validation is expected to fail if:</p> <ul> <li><code>GasTipCap</code> is invalid (<code>nil</code>, negative value or overflow int256)</li> <li><code>GasFeeCap</code> is invalid (<code>nil</code>, negative value or overflow int256)</li> <li><code>GasFeeCap</code> is less than <code>GasTipCap</code></li> <li><code>Fee</code> (gas price * gas limit) is invalid (overflow int256)</li> <li>Invalid <code>Amount</code> (negative or overflow int256)</li> <li>Invalid <code>To</code> address (invalid Ethereum hex address)</li> <li><code>ChainID</code> is <code>nil</code></li> </ul>"},{"location":"evm/#accesslisttx","title":"<code>AccessListTx</code>","text":"<p>EIP-2930 Access transaction data for list transactions.</p> <pre><code>type AccessListTx struct {\n // destination EVM chain ID\n ChainID *github_com_cosmos_cosmos_sdk_types.Int `protobuf:\"bytes,1,opt,name=chain_id,json=chainId,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int\" json:\"chainID\"`\n // nonce corresponds to the account nonce (transaction sequence).\n Nonce uint64 `protobuf:\"varint,2,opt,name=nonce,proto3\" json:\"nonce,omitempty\"`\n // gas price defines the value for each gas unit\n GasPrice *github_com_cosmos_cosmos_sdk_types.Int `protobuf:\"bytes,3,opt,name=gas_price,json=gasPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int\" json:\"gas_price,omitempty\"`\n // gas defines the gas limit defined for the transaction.\n GasLimit uint64 `protobuf:\"varint,4,opt,name=gas,proto3\" json:\"gas,omitempty\"`\n // hex formatted address of the recipient\n To string `protobuf:\"bytes,5,opt,name=to,proto3\" json:\"to,omitempty\"`\n // value defines the unsigned integer value of the transaction amount.\n Amount *github_com_cosmos_cosmos_sdk_types.Int `protobuf:\"bytes,6,opt,name=value,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int\" json:\"value,omitempty\"`\n // input defines the data payload bytes of the transaction.\n Data     []byte     `protobuf:\"bytes,7,opt,name=data,proto3\" json:\"data,omitempty\"`\n Accesses AccessList `protobuf:\"bytes,8,rep,name=accesses,proto3,castrepeated=AccessList\" json:\"accessList\"`\n // v defines the signature value\n V []byte `protobuf:\"bytes,9,opt,name=v,proto3\" json:\"v,omitempty\"`\n // r defines the signature value\n R []byte `protobuf:\"bytes,10,opt,name=r,proto3\" json:\"r,omitempty\"`\n // s define the signature value\n S []byte `protobuf:\"bytes,11,opt,name=s,proto3\" json:\"s,omitempty\"`\n}\n</code></pre> <p>This message field validation is expected to fail if:</p> <ul> <li><code>GasPrice</code> is invalid (<code>nil</code>, negative, or overflow int256)</li> <li><code>Fee</code> (gas price * gas limit) is invalid (overflow int256)</li> <li>Invalid <code>Amount</code> (negative or overflow int256)</li> <li>Invalid <code>To</code> address (invalid Ethereum hex address)</li> <li><code>ChainID</code> is <code>nil</code></li> </ul>"},{"location":"evm/#abci","title":"ABCI","text":"<p>The Application Blockchain Interface (ABCI) allows applications to interact with the Tendermint consensus engine. The application maintains multiple ABCI connections to Tendermint. Most relevant to <code>x/evm</code> is Consensus Connection at Commit. This connection is responsible for block execution and calls functions <code>InitChain</code> (contains <code>InitGenesis</code>), <code>BeginBlock</code>, <code>DeliverTx</code>, <code>EndBlock</code>, <code>Commit</code>. <code>InitChain</code> is only called the first time a new blockchain is started, and <code>DeliverTx</code> is called for every transaction in a block.</p>"},{"location":"evm/#initialize-genesis","title":"Initialize Genesis","text":"<p><code>InitGenesis</code> initializes the EVM module genesis state by setting the <code>GenesisState</code> field to storage. In particular, it sets parameters and genesis accounts (state and code).</p>"},{"location":"evm/#export-genesis","title":"Export Genesis","text":"<p>The <code>ExportGenesis</code> ABCI function exports the genesis state of an EVM module. In particular, it retrieves all accounts and their bytecodes, balances and storage, transaction logs, As well as EVM parameters and chain configuration.</p>"},{"location":"evm/#begin-block","title":"Begin Block","text":"<p>The EVM module <code>BeginBlock</code> logic is executed before the state transitions that process transactions. The main goals of this function are:</p> <ul> <li>Set the context of the current block for block headers, storage, gas meters, etc.   Once one of the StateDB functions is called during an EVM state transition, these functions are available to the Keeper.</li> <li>Set the EIP155 <code>ChainID</code> number (obtained from the full chain ID) in case it was not previously set during <code>InitChain</code></li> </ul>"},{"location":"evm/#end-block","title":"End block","text":"<p>The <code>EndBlock</code> logic of the EVM module occurs after all state transitions of the transaction have been executed. The main goals of this function are:</p> <ul> <li>emit block bloom event<ul> <li>This is due to web3 compatibility, since the ethereum header includes this type as a field.   The JSON-RPC service uses this event query to construct Ethereum headers from Tendermint headers.</li> <li>The block bloom filter value is fetched from transient storage and then emitted</li> </ul> </li> </ul>"},{"location":"evm/#hooks","title":"hooks","text":"<p>The <code>x/evm</code> module implements an <code>EvmHooks</code> interface, which can extend and customize <code>Tx</code> processing logic externally.</p> <p>This supports EVM contracts calling native cosmos modules</p> <ol> <li>Define log signatures and emit specific logs from smart contracts,</li> <li>Identify these logs in the native tx handling code, and</li> <li>Convert them to native module calls.</li> </ol> <p>For this, the interface contains a PostTxProcessing hook to register custom Tx hooks in EvmKeeper. These <code>Tx</code> hooks are processed after the EVM state transition is complete and will not fail. Note that there are no default hooks implemented in the EVM module.</p> <pre><code>type EvmHooks interface {\n  // Must be called after tx is processed successfully, if return an error, the whole transaction is reversed.\n  PostTxProcessing(ctx sdk.Context, msg core.Message, receipt *ethtypes.Receipt) error\n}\n</code></pre>"},{"location":"evm/#posttxprocessing","title":"<code>PostTxProcessing</code>","text":"<p><code>PostTxProcessing</code> is only called after the EVM transaction has completed successfully, and delegates the call to the underlying hook. If no hooks are registered, this function returns a <code>nil</code> error. .</p> <pre><code>func (k *Keeper) PostTxProcessing(ctx sdk.Context, msg core.Message, receipt *ethtypes.Receipt) error {\n  if k.hooks == nil {\n   return nil\n  }\n  return k.hooks.PostTxProcessing(k.Ctx(), msg, receipt)\n}\n</code></pre> <p>It executes in the same cache context as the EVM transaction, if it returns an error, the whole EVM transaction will be reverted, if hook implementors don't want to revert tx, they can always return <code>nil</code>.</p> <p>Errors returned by hooks are translated to VM errors <code>Unable to process native log</code>, with detailed error messages stored in the return value. Messages are sent asynchronously to native modules, and callers cannot catch and recover from errors.</p> <p> Use case: calling native ERC20 modules on Daodst </p> <p>The following is an example taken from the Daodst erc20 module showing how <code>EVMHooks</code> support contracts that call native modules to convert ERC-20 tokens to Cosmos native tokens. Follow the steps above.</p> <p>You can define and emit a \"Transfer\" log signature in your smart contract like this:</p> <pre><code>event Transfer(address indexed from, address indexed to, uint256 value);\n\nfunction _transfer(address sender, address recipient, uint256 amount) internal virtual {\n  require(sender != address(0), \"ERC20: transfer from the zero address\");\n  require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n  _beforeTokenTransfer(sender, recipient, amount);\n\n  _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n  _balances[recipient] = _balances[recipient].add(amount);\n  emit Transfer(sender, recipient, amount);\n}\n</code></pre> <p>The application will register a <code>BankSendHook</code> with <code>EvmKeeper</code>. It recognizes the Ethereum tx <code>Log</code> and translates it into a call to the <code>SendCoinsFromAccountToAccount</code> method of the bank module:</p> <pre><code>\nconst ERC20EventTransfer = \"Transfer\"\n\n// PostTxProcessing implements EvmHooks.PostTxProcessing\nfunc (k Keeper) PostTxProcessing(\n ctx sdk.Context,\n msg core.Message,\n receipt *ethtypes.Receipt,\n) error {\n params := h.k.GetParams(ctx)\n if !params.EnableErc20 || !params.EnableEVMHook {\n  // no error is returned to allow for other post-processing txs\n  // to pass\n  return nil\n }\n\n erc20 := contracts.ERC20BurnableContract.ABI\n\n for i, log := range receipt.Logs {\n  if len(log.Topics) &lt; 3 {\n   continue\n  }\n\n  eventID := log.Topics[0] // event ID\n\n  event, err := erc20.EventByID(eventID)\n  if err != nil {\n   // invalid event for ERC20\n   continue\n  }\n\n  if event.Name != types.ERC20EventTransfer {\n   h.k.Logger(ctx).Info(\"emitted event\", \"name\", event.Name, \"signature\", event.Sig)\n   continue\n  }\n\n  transferEvent, err := erc20.Unpack(event.Name, log.Data)\n  if err != nil {\n   h.k.Logger(ctx).Error(\"failed to unpack transfer event\", \"error\", err.Error())\n   continue\n  }\n\n  if len(transferEvent) == 0 {\n   continue\n  }\n\n  tokens, ok := transferEvent[0].(*big.Int)\n  // safety check and ignore if amount not positive\n  if !ok || tokens == nil || tokens.Sign() != 1 {\n   continue\n  }\n\n  // check that the contract is a registered token pair\n  contractAddr := log.Address\n\n  id := h.k.GetERC20Map(ctx, contractAddr)\n\n  if len(id) == 0 {\n   // no token is registered for the caller contract\n   continue\n  }\n\n  pair, found := h.k.GetTokenPair(ctx, id)\n  if !found {\n   continue\n  }\n\n  // check that conversion for the pair is enabled\n  if !pair.Enabled {\n   // continue to allow transfers for the ERC20 in case the token pair is disabled\n   h.k.Logger(ctx).Debug(\n    \"ERC20 token -&gt; Cosmos coin conversion is disabled for pair\",\n    \"coin\", pair.Denom, \"contract\", pair.Erc20Address,\n   )\n   continue\n  }\n\n  // ignore as the burning always transfers to the zero address\n  to := common.BytesToAddress(log.Topics[2].Bytes())\n  if !bytes.Equal(to.Bytes(), types.ModuleAddress.Bytes()) {\n   continue\n  }\n\n  // check that the event is Burn from the ERC20Burnable interface\n  // NOTE: assume that if they are burning the token that has been registered as a pair, they want to mint a Cosmos coin\n\n  // create the corresponding sdk.Coin that is paired with ERC20\n  coins := sdk.Coins{{Denom: pair.Denom, Amount: sdk.NewIntFromBigInt(tokens)}}\n\n  // Mint the coin only if ERC20 is external\n  switch pair.ContractOwner {\n  case types.OWNER_MODULE:\n   _, err = h.k.CallEVM(ctx, erc20, types.ModuleAddress, contractAddr, true, \"burn\", tokens)\n  case types.OWNER_EXTERNAL:\n   err = h.k.bankKeeper.MintCoins(ctx, types.ModuleName, coins)\n  default:\n   err = types.ErrUndefinedOwner\n  }\n\n  if err != nil {\n   h.k.Logger(ctx).Debug(\n    \"failed to process EVM hook for ER20 -&gt; coin conversion\",\n    \"coin\", pair.Denom, \"contract\", pair.Erc20Address, \"error\", err.Error(),\n   )\n   continue\n  }\n\n  // Only need last 20 bytes from log.topics\n  from := common.BytesToAddress(log.Topics[1].Bytes())\n  recipient := sdk.AccAddress(from.Bytes())\n\n  // transfer the tokens from ModuleAccount to sender address\n  if err := h.k.bankKeeper.SendCoinsFromModuleToAccount(ctx, types.ModuleName, recipient, coins); err != nil {\n   h.k.Logger(ctx).Debug(\n    \"failed to process EVM hook for ER20 -&gt; coin conversion\",\n    \"tx-hash\", receipt.TxHash.Hex(), \"log-idx\", i,\n    \"coin\", pair.Denom, \"contract\", pair.Erc20Address, \"error\", err.Error(),\n   )\n   continue\n  }\n }\n\n return nil\n</code></pre> <p>Finally, register the hook in app.go:</p> <pre><code>app.EvmKeeper = app.EvmKeeper.SetHooks(app.Erc20Keeper)\n</code></pre>"},{"location":"evm/#event","title":"event","text":"<p>The <code>x/evm</code> module emits Cosmos SDK events after state execution. The EVM module emits events related to transaction fields, as well as transaction logs (Ethereum events)\u3002</p>"},{"location":"evm/#msgethereumtx_2","title":"MsgEthereumTx","text":"Type Property Key Property Value ethereum_tx <code>\"amount\"</code> <code>{amount}</code> ethereum_tx <code>\"recipient\"</code> <code>{hex_address}</code> ethereum_tx <code>\"contract\"</code> <code>{hex_address}</code> ethereum_tx <code>\"txHash\"</code> <code>{tendermint_hex_hash}</code> ethereum_tx <code>\"ethereumTxHash\"</code> <code>{hex_hash}</code> ethereum_tx <code>\"txIndex\"</code> <code>{tx_index}</code> ethereum_tx <code>\"txGasUsed\"</code> <code>{gas_used}</code> tx_log <code>\"txLog\"</code> <code>{tx_log}</code> message <code>\"sender\"</code> <code>{eth_address}</code> message <code>\"action\"</code> <code>\"ethereum\"</code> message <code>\"module\"</code> <code>\"evm\"</code> <p>Additionally, the EVM module emits an event for the filter query block bloom during <code>EndBlock</code>.</p>"},{"location":"evm/#abci_1","title":"ABCI","text":"Type Property Key Property Value block_bloom <code>\"bloom\"</code> <code>string(bloomBytes)</code>"},{"location":"evm/#parameters","title":"parameters","text":"<p>The evm module contains the following parameters:</p>"},{"location":"evm/#module-parameters","title":"Module parameters","text":"Key Data Type Default <code>EVMDenom</code> string <code>\"dst\"</code> <code>EnableCreate</code> bool <code>true</code> <code>EnableCall</code> bool <code>true</code> <code>ExtraEIPs</code> []int TBD <code>ChainConfig</code> ChainConfig See ChainConfig <p>:::hint Note: SDK applications want to import the EVM module as a dependency Will need to set own <code>evm_denom</code> (i.e. not <code>\"dst\"</code>). :::</p>"},{"location":"evm/#enablecreate","title":"EnableCreate","text":"<p>The EnableCreate parameter toggles state transitions using the <code>vm.Create</code> function. When this parameter is disabled, it blocks all contract creation functions.</p>"},{"location":"evm/#enablecall","title":"EnableCall","text":"<p>The EnableCall parameter toggles state transitions using the <code>vm.Call</code> function. When this parameter is disabled, it prevents transfers between accounts and execution of smart contract calls.</p>"},{"location":"evm/#extra-eips","title":"Extra EIPs","text":"<p>The additional EIPs parameter defines a set of Ethereum Improvement Proposals that can be activated on the Ethereum VM <code>Config</code> applying a custom jump table (EIPs ).</p> <p>:::hint Note: Some of these EIPs are already enabled via chain configuration, depending on the number of hard forks. :::</p> <p>The supported activatable EIPS are:</p> <ul> <li>EIP 1344</li> <li>EIP 1884</li> <li>EIP 2200</li> <li>EIP 2315</li> <li>EIP 2929</li> <li>EIP 3198</li> <li>EIP 3529</li> </ul>"},{"location":"evm/#chain-config","title":"Chain Config","text":"<p><code>ChainConfig</code> is a protobuf wrapper type that contains the same fields as the go-ethereum <code>ChainConfig</code> parameter, but uses <code>*sdk.Int</code> type instead of <code>*big.Int</code>.</p> <p>By default, all block configuration fields except <code>ConstantinopleBlock</code> are enabled at Genesis (height 0).</p>"},{"location":"evm/#default-chainconfig","title":"Default ChainConfig","text":"name default HomesteadBlock 0 DAOForkBlock 0 DAOForkSupport <code>true</code> EIP150Block 0 EIP150Hash <code>0x0000000000000000000000000000000000000000000000000000000000000000</code> EIP155Block 0 EIP158Block 0 ByzantiumBlock 0 ConstantinopleBlock 0 PetersburgBlock 0 IstanbulBlock 0 MuirGlacierBlock 0 BerlinBlock 0 LondonBlock 0 ArrowGlacierBlock 0 GrayGlacierBlock 0 MergeNetsplitBlock 0 ShanghaiBlock 0 CancunBlock. 0"},{"location":"evm/#client_1","title":"client","text":"<p>Users can query and interact with the <code>evm</code> module using CLI, JSON-RPC, gRPC, or REST.</p>"},{"location":"evm/#cli","title":"CLI","text":"<p>Below find a list of <code>stcd</code> commands added using the <code>x/evm</code> module. You can get a complete list with <code>stcd -h</code> command.</p>"},{"location":"evm/#inquire","title":"Inquire","text":"<p>The <code>query</code> command allows the user to query the state of <code>evm</code>.</p> <p><code>code</code></p> <p>Allows users to query the smart contract code for a given address.</p> <pre><code>stcd query evm code ADDRESS [flags]\n</code></pre> <pre><code># Example\n$ stcd query evm code 0x7bf7b17da59880d9bcca24915679668db75f9397\n\n# Output\ncode: \"0xef616c92f3cfc9e92dc270d6acff9cea213cecc7020a76ee4395af09bdceb4837a1ebdb5735e11e7d3adb6104e0c3ac55180b4ddf5e54d022cc5e8837f6a4f971b\"\n</code></pre> <p><code>storage</code></p> <p>Allows users to query the store for accounts with a given key and height\u3002</p> <pre><code>stcd query evm storage ADDRESS KEY [flags]\n</code></pre> <pre><code># Example\n$ stcd query evm storage 0x0f54f47bf9b8e317b214ccd6a7c3e38b893cd7f0 0 --height 0\n\n# Output\nvalue: \"0x0000000000000000000000000000000000000000000000000000000000000000\"\n</code></pre>"},{"location":"evm/#trade_1","title":"trade","text":"<p>The <code>tx</code> command allows the user to interact with the <code>evm</code> module.</p> <p><code>raw</code></p> <p>Allows users to build cosmos transactions from raw Ethereum transactions.</p> <pre><code>stcd tx evm raw TX_HEX [flags]\n</code></pre> <pre><code># Example\n$ stcd tx evm raw 0xf9ff74c86aefeb5f6019d77280bbb44fb695b4d45cfe97e6eed7acd62905f4a85034d5c68ed25a2e7a8eeb9baf1b84\n\n# Output\nvalue: \"0x0000000000000000000000000000000000000000000000000000000000000000\"\n</code></pre>"},{"location":"evm/#grpc","title":"gRPC","text":""},{"location":"evm/#inquire_1","title":"Inquire","text":"Verb Method Description <code>gRPC</code> <code>ethermint.evm.v1.Query/Account</code> Get Ethereum account <code>gRPC</code> <code>ethermint.evm.v1.Query/CosmosAccount</code> Get the Cosmos address of an Ethereum account <code>gRPC</code> <code>ethermint.evm.v1.Query/ValidatorAccount</code> Get Ethereum account from validator consensus address <code>gRPC</code> <code>ethermint.evm.v1.Query/Balance</code> Get the EVM denomination balance of a single EthAccount. <code>gRPC</code> <code>ethermint.evm.v1.Query/Storage</code> Get the balance of all coins in a single account <code>gRPC</code> <code>ethermint.evm.v1.Query/Code</code> Get the balance of all coins in a single account <code>gRPC</code> <code>ethermint.evm.v1.Query/Params</code> Get the parameters of the x/evm module <code>gRPC</code> <code>ethermint.evm.v1.Query/EthCall</code> implements the eth_call rpc api <code>gRPC</code> <code>ethermint.evm.v1.Query/EstimateGas</code> implements the eth_estimateGas rpc api <code>gRPC</code> <code>ethermint.evm.v1.Query/TraceTx</code> implement debug_traceTransaction rpc api <code>gRPC</code> <code>ethermint.evm.v1.Query/TraceBlock</code> implements debug_traceBlockByNumber and debug_traceBlockByHash rpc api <code>GET</code> <code>/ethermint/evm/v1/account/{address}</code> Get Ethereum account <code>GET</code> <code>/ethermint/evm/v1/cosmos_account/{address}</code> Get the Cosmos address of the Ethereum account <code>GET</code> <code>/ethermint/evm/v1/validator_account/{cons_address}</code> Get Ethereum account from validator consensus address <code>GET</code> <code>/ethermint/evm/v1/balances/{address}</code> Get the EVM denomination balance of a single EthAccount. <code>GET</code> <code>/ethermint/evm/v1/storage/{address}/{key}</code> Get the balance of all coins in a single account <code>GET</code> <code>/ethermint/evm/v1/codes/{address}</code> Get the balance of all coins in a single account <code>GET</code> <code>/ethermint/evm/v1/params</code> Get the parameters of the x/evm module <code>GET</code> <code>/ethermint/evm/v1/eth_call</code> implements eth_call rpc api <code>GET</code> <code>/ethermint/evm/v1/estimate_gas</code> implements the eth_estimateGas rpc api <code>GET</code> <code>/ethermint/evm/v1/trace_tx</code> implements debug_traceTransaction rpc api <code>GET</code> <code>/ethermint/evm/v1/trace_block</code> implements debug_traceBlockByNumber and debug_traceBlockByHash rpc api"},{"location":"evm/#trade_2","title":"trade","text":"Verb Method Description <code>gRPC</code> <code>ethermint.evm.v1.Msg/EthereumTx</code> Submit an Ethereum transaction <code>POST</code> <code>/ethermint/evm/v1/ethereum_tx</code> Submit an Ethereum transaction"},{"location":"faq/","title":"General FAQ","text":"<p>View answers to frequently asked questions on DST.</p>"},{"location":"faq/#app","title":"APP","text":"Why does APP query data fail validation? <p> The balance query and TX result query of the APP have an anti cheating verification mechanism. If the verification results are incorrect, you may encounter data query verification failure. </p> <p> When the app starts, it initializes the verification client and extracts the verification nodes from the available gateway nodes. When querying balance and TX status, the query results will be verified with the verification node. If the verification fails, an error will be prompted </p>"},{"location":"faq/#network-related","title":"Network related","text":"What port numbers do servers need to open? <p> TCP Open Port\uff1a1317 , 8545 , 23478 , 26656 , 26657 , 28008 , 28043 , 50327 , 50328 </p> <p> UDP Open Port\uff1a3478, 50000~55000 </p> Why does the gateway address fail verification? How to solve it? <p> 1.First, explain why gateway address verification failed </p> <p> Due to the need for gateway addresses to provide external services, it is required that the gateway address must be open to the public. </p> <p> Therefore, when setting the gateway address, the connectivity of the address will be tested through the internet. When the request fails to be sent or the request result is incorrect, an error will be thrown indicating that the gateway address verification has failed. </p> <p> 2.How to solve the problem of gateway address verification failure </p> <p> The failure of gateway address verification is essentially due to network access failure, which needs to be addressed from the network layer. Solving requires a certain level of hands-on ability. If there are difficulties, it is recommended to find a partner to help. <ul> <li>Firstly, check if the router settings are correct and if the port image is correctly set (refer to the introduction on the current page for a list of port numbers that require an image)</li> <li>If it has not been resolved yet, you can check if the server's firewall is enabled. If it is enabled, please check if the list of ports that need to be opened is already open.</li> <li>If it has not been resolved yet, you can contact the current network supplier and explain the list of ports that need to be opened for their assistance in resolving the issue</li>"},{"location":"gateway/","title":"Overview","text":""},{"location":"gateway/#setup-and-configuration","title":"Setup and configuration","text":""},{"location":"gateway/#run-validator","title":"Run validator","text":""},{"location":"gateway/#configuration","title":"configuration","text":""},{"location":"gateway/#hdd-usage-optimization","title":"HDD usage optimization","text":""},{"location":"gateway/#state-synchronization","title":"State Synchronization","text":""},{"location":"gateway/#memory-pool","title":"memory pool","text":""},{"location":"gateway/#validator-faq","title":"Validator FAQ","text":""},{"location":"gateway/#authenticator-security","title":"Authenticator Security","text":""},{"location":"gateway/#sentinel-node-ddos-protected","title":"Sentinel Node (DDOS Protected)","text":""},{"location":"gateway/#key-backup","title":"Key backup","text":""},{"location":"gateway/#upgrade","title":"upgrade","text":""},{"location":"gateway/#upgrade-checklist","title":"Upgrade Checklist","text":""},{"location":"gateway/#hard-fork-upgrade","title":"Hard Fork Upgrade","text":""},{"location":"gateway/#manual-upgrade","title":"Manual upgrade","text":""},{"location":"gateway/#testnet","title":"Testnet","text":""},{"location":"gateway/#mainnet","title":"Mainnet","text":""},{"location":"mgateway/","title":"Gateway","text":""},{"location":"mgateway/#abstract","title":"Abstract","text":"<p>This module is responsible for the management of data on the gateway chain</p>"},{"location":"mgateway/#contents","title":"Contents","text":"<ol> <li>Concepts</li> <li>Keeper</li> <li>Messages</li> <li>Params</li> </ol> <pre><code>chat/\n\u251c\u2500\u2500 client\n\u2502 \u2514\u2500\u2500 rest\n\u2502 \u251c\u2500\u2500 error.go # interface error collection\n\u2502 \u251c\u2500\u2500 grpc.go # grpc query method\n\u2502 \u251c\u2500\u2500 handle_comm.go # comm module message pre-processing\n\u2502 \u251c\u2500\u2500 handle_msg.go # comm module message pre-processing\n\u2502 \u251c\u2500\u2500 query.go # interface query function\n\u2502 \u251c\u2500\u2500 rest.go # Registration of message and query routing\n\u2502 \u2514\u2500\u2500 tx.go # tx related methods, including broadcasting, etc.\n\u251c\u2500\u2500keeper\n\u2502 \u251c\u2500\u2500 hooks.go # Hook function, triggered by other module logic\n\u2502 \u251c\u2500\u2500 keeper.go # storage manager, handles the business logic of the module, and has permission to access specific subtrees of the state tree\n\u2502 \u251c\u2500\u2500 msg_server.go # Provide service processing logic for uplink messages\n\u2502 \u251c\u2500\u2500 params.go # Setting and obtaining module parameters\n\u2502 \u251c\u2500\u2500 query.go # Status query function\n\u251c\u2500\u2500 types\n\u2502 \u251c\u2500\u2500 codec.go # code registration type\n\u2502 \u251c\u2500\u2500 errors.go # module-specific errors\n\u2502 \u251c\u2500\u2500 events.go # Events exposed to Tendermint PubSub/Websocket\n\u2502 \u251c\u2500\u2500 genesis.go # Genesis state of the module\n\u2502 \u251c\u2500\u2500 interface.go # interface collection of modules\n\u2502 \u251c\u2500\u2500 keys.go # module stores key and some other constants\n\u2502 \u251c\u2500\u2500 msg.go # Chat module transaction message\n\u2502 \u251c\u2500\u2500 params.go # The custom parameters that the module can modify through the governance module\n\u2502 \u251c\u2500\u2500 interface.go # The method implemented by the imported external module\n\u2502 \u2514\u2500\u2500 types.go # module type collection\n\u251c\u2500\u2500 genesis.go # ABCI's genesis state initialization and export function\n\u251c\u2500\u2500 handler.go # message routing\n\u2514\u2500\u2500 module.go # Module settings of the module manager\n</code></pre>"},{"location":"mgateway/#concepts","title":"Concepts","text":""},{"location":"mgateway/#gateway","title":"Gateway","text":"<p>The gateway module is responsible for the management of the data on the gateway chain, including the ownership and acquisition of the number segment</p>"},{"location":"mgateway/#gateway-information","title":"Gateway Information","text":"<p>Gateway registration needs to fill in the name of the gateway, the communication address of the gateway, the name of the APP package, and the first number segment information. The gateway communication address supports IP and domain names, and needs to be bound to the 50327 communication port. The APP package name needs to start with a lowercase letter, and the length cannot exceed 32 characters. Gateways cannot be registered repeatedly, and each DPOS node can only register one gateway. Gateway information supports modifying the name and gateway communication address. \ud83d\udea8 DANGER: Once the communication address of the gateway is modified, the chat information of the gateway will be reset, please proceed with caution.</p>"},{"location":"mgateway/#number-section","title":"Number section","text":"<p>For the first registration of the gateway, a number segment must be filled in, which will be marked as the first number segment of the gateway and used as the communication domain name. The length of the number segment can be 5, 6, or 7. When the quota of the gateway number segment is sufficient, it supports adding multiple number segments. The number segment is divided into three states: binding, redeeming, and unbound. The number segment that has been bound and redeemed cannot be used by other gateways. The number segment that is being redeemed has a default protection period of one year. When the gateway owner pledges again, he can choose the number segment again and bind it. The unbound number segment can be used again by all gateways.</p>"},{"location":"mgateway/#gateway-pledge-and-redemption","title":"Gateway pledge and redemption","text":"<p>By default, every 10 FM pledged can get a gateway number segment quota. When the gateway owner redeems DPOS, corresponding to the redemption of 10 FMs, one number segment must be redeemed or the amount of the corresponding number segment should be reduced. When redeeming in part, the first number segment is not allowed to be redeemed, only other number segments can be selected. If all pledges are redeemed, all number segments will be redeemed. After all pledges are redeemed, the gateway status becomes unavailable.</p>"},{"location":"mgateway/#keeper","title":"Keeper","text":"<p>The contract module 'Keeper' grants access to the state of the chat module And implement 'statedb. Interface to support 'StateDB' implementation. Keeper contains a storage key that allows the repository Write to the concrete subtree of the multibase that can only be accessed by the Chat module. Instead of using trees and databases for querying and persistence (the 'StateDB' implementation), DaoDst uses Cosmos' \"KVStore\" (key-value store) and Cosmos SDK's \"Keeper\" to facilitate state transitions.</p> <p>In order to support the interface function, it imports 7 module Keepers:</p> <ul> <li><code>auth</code>: addition, deletion, modification and query of accounts</li> <li><code>bank</code>: addition, deletion, modification and query of supply and balance</li> <li><code>staking</code>: management of gateway related data</li> <li><code>pledge</code>: management of chat related data</li> <li><code>evm</code>: management of evm related data</li> <li><code>chat</code>: management of chat related data</li> <li><code>gateway</code>: gateway data management</li> </ul> <pre><code>    type Keeper struct {\n        storeKey   sdk.StoreKey\n        cdc        codec.BinaryCodec\n        paramstore paramtypes.Subspace\n\n        stakingKeeper *stakingKeeper.Keeper\n        accountKeeper types.AccountKeeper\n        BankKeeper    types.BankKeeper\n        pledgeKeeper  types.PledgeKeeper\n        evmKeeper     types.EVMKeeper\n        chatKeeper    types.ChatKeeper\n        gatewayKeeper types.GatewayKeeper\n        erc20Keeper   erc20keeper.Keeper\n    }\n</code></pre>"},{"location":"mgateway/#messages","title":"Messages","text":""},{"location":"mgateway/#msgapptokenissue","title":"MsgAppTokenIssue","text":"<pre><code>Through this message, back up the gateway's authenticator key and other information\n</code></pre> <pre><code>    type MsgGatewayUpload struct {\n        FromAddress    string `protobuf:\"bytes,1,opt,name=fromAddress,proto3\" json:\"fromAddress,omitempty\" yaml:\"from_address\"`\n        GatewayKeyInfo []byte `protobuf:\"bytes,2,opt,name=GatewayKeyInfo,proto3\" json:\"GatewayKeyInfo,omitempty\" yaml:\"gateway_key_info\"`\n    }\n</code></pre>"},{"location":"mgateway/#msggatewayregister","title":"MsgGatewayRegister","text":"<pre><code>Through this message, register as a gateway and get the did number segment\n</code></pre> <pre><code>    type MsgGatewayRegister struct {\n        Address string `protobuf:\"bytes,1,opt,name=address,proto3\" json:\"address,omitempty\"`\n        GatewayName string `protobuf:\"bytes,2,opt,name=gateway_name,json=gatewayName,proto3\" json:\"gateway_name,omitempty\"`\n        GatewayUrl string `protobuf:\"bytes,3,opt,name=gateway_url,json=gatewayUrl,proto3\" json:\"gateway_url,omitempty\"`\n        Delegation string `protobuf:\"bytes,4,opt,name=delegation,proto3\" json:\"delegation,omitempty\"`\n        IndexNumber []string `protobuf:\"bytes,5,rep,name=index_number,json=indexNumber,proto3\" json:\"index_number,omitempty\"`\n    }\n</code></pre>"},{"location":"mgateway/#msggatewayindexnum","title":"MsgGatewayIndexNum","text":"<pre><code>Through this message, the gateway can obtain additional did number segments through pledge\n</code></pre> <pre><code>    type MsgGatewayIndexNum struct {\n        DelegatorAddress string `protobuf:\"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3\" json:\"delegator_address,omitempty\" yaml:\"delegator_address\"`\n        ValidatorAddress string `protobuf:\"bytes,2,opt,name=validator_address,json=validatorAddress,proto3\" json:\"validator_address,omitempty\" yaml:\"validator_address\"`\n        IndexNumber []string `protobuf:\"bytes,3,rep,name=index_number,json=indexNumber,proto3\" json:\"index_number,omitempty\"`\n    }\n</code></pre>"},{"location":"mgateway/#msggatewayundelegate","title":"MsgGatewayUndelegate","text":"<pre><code>With this message, the gateway can redeem the stake\n</code></pre> <pre><code>    type MsgGatewayUndelegate struct {\n        DelegatorAddress string      `protobuf:\"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3\" json:\"delegator_address,omitempty\" yaml:\"delegator_address\"`\n        ValidatorAddress string      `protobuf:\"bytes,2,opt,name=validator_address,json=validatorAddress,proto3\" json:\"validator_address,omitempty\" yaml:\"validator_address\"`\n        Amount           types1.Coin `protobuf:\"bytes,3,opt,name=amount,proto3\" json:\"amount\"`\n        IndexNumber []string `protobuf:\"bytes,4,rep,name=index_number,json=indexNumber,proto3\" json:\"index_number,omitempty\"`\n    }\n</code></pre>"},{"location":"mgateway/#parameters","title":"Parameters","text":"<p>The gateway module contains the following module parameters</p>"},{"location":"mgateway/#params","title":"Params","text":"Key Type Default Value <code>IndexNumHeight</code> int64 <code>100</code> <code>RedeemFeeHeight</code> int64 <code>432000</code> <code>RedeemFee</code> github_com_cosmos_cosmos_sdk_types.Dec <code>0.1</code> <code>MinDelegate</code> github_com_cosmos_cosmos_sdk_types.Coin <code>10000000000000000000000fm</code> <code>Validity</code> int64 <code>5256000</code>"},{"location":"modules_accounts/","title":"module account","text":"<p>Some modules have their own module accounts. Think of it as a wallet that can only be controlled by this module. Below is a table of modules, their respective wallet addresses and permissions:</p>"},{"location":"modules_accounts/#list-of-module-accounts","title":"List of module accounts","text":"Name Address Permissions <code>claims</code> dst15cvq3ljql6utxseh0zau9m8ve2j8erz89m5wkz <code>none</code> <code>erc20</code> dst1glht96kr2rseywuvhhay894qw7ekuc4qg9z5nw <code>minter</code> <code>burner</code> <code>fee_collector</code> dst17xpfvakm2amg962yls6f84z3kell8c5ljcjw34 <code>none</code> <code>incentives</code> dst1krxwf5e308jmclyhfd9u92kp369l083wn67k4q <code>minter</code> <code>burner</code> <code>inflation</code> dst1d4e35hk3gk4k6t5gh02dcm923z8ck86qygxf38 <code>minter</code> <code>transfer</code> dst1yl6hdjhmkf37639730gffanpzndzdpmhv788dt <code>minter</code> <code>burner</code> <code>bonded_tokens_pool</code> dst1fl48vsnmsdzcv85q5d2q4z5ajdha8yu3h6cprl <code>burner</code> <code>staking</code> <code>not_bonded_tokens_pool</code> dst1tygms3xhhs3yv487phx3dw4a95jn7t7lr6ys4t <code>burner</code> <code>staking</code> <code>gov</code> dst10d07y265gmmuvt4z0w9aw880jnsr700jcrztvm <code>burner</code> <code>distribution</code> dst1jv65s3grqf6v6jl3dp4t6c9t9rk99cd8974jnh] <code>none</code> <code>evm</code> dst1vqu8rska6swzdmnhf90zuv0xmelej4lq0n56wq <code>minter</code> <code>burner</code> <code>ibc</code> dst1a53udazy8ayufvy0s434pfwjcedzqv345dnt3x <code>minter</code> <code>burner</code> <code>chat</code> dst1x8sx7lvfl6ue5rnvptl7rxr53samt0h4zxqkwg <code>minter</code> <code>burner</code> <code>chat_burn</code> dst1g7z9fjg8zyrj68a6rtqkfgldvjjjc3n7sucath <code>burner</code> <code>gateway</code> dst1f6j7u6875p2cvyrgjr0d2uecyzah0kgexwhr3g <code>none</code> <code>pledge</code> dst1nhta6gsf9x9l2pd2m5qg6lya0h3m0pjy4vtd35 <code>minter</code> <code>burner</code> <code>contract</code> dst1ejpjr43ht3y56pplm5pxpusmcrk9rkkvevc88d <code>none</code> <code>stakeContractDeploy</code> dst16vxjegtg3k5fvqcc55yd6cele9hx0nhv3lxzf0 <code>none</code> <code>tokenFactoryContractDeploy</code> dst10dkh3rvhgcj2vj4h36msncnkr5ps668x9uuva0 <code>none</code>"},{"location":"modules_accounts/#account-permissions","title":"Account Permissions","text":"<ul> <li><code>burner</code> authority means that the account has the authority to burn or burn tokens.</li> <li>The <code>minter</code> permission indicates that this account has permission to mint or create new tokens.</li> <li>The <code>staking</code> permission means that the account has the right to stake tokens on behalf of its owner.</li> </ul>"},{"location":"modules_accounts/#ibc-module-account","title":"IBC module account","text":"<p>Additionally, there are module accounts associated with IBC transfers. For each IBC connection, there is an account of type <code>ModuleAccount</code>, which is used to host the transferred coins when Daodst is the source chain. Their address is derived using the first 20 bytes of the SHA256 checksum of the account name, following ADR 028:</p> <pre><code>// accountName is composed by the current version the IBC tranfer module supports (in this case, ics20-1), the portID (transfer) and the channelID\naccountName := Version + \"\\0\" + portID + \"/\" + channelID\naddr := sha256.Sum256(accountName)[:20]\n\n// example for channel-0\naddr := sha256.Sum256(\"ics20-1\\0transfer/channel-0\")[:20]\n</code></pre> <p>This can be done using the <code>GetEscrowAccount</code> function on IBC-go.</p> <p>\ud83d\udce3 Tip : These hosting accounts are not listed when executing the query:</p> <pre><code>stcd q auth module-accounts\n</code></pre> <p>This happens because the <code>GetModuleAccount</code> function used in the query only Consider accounts on <code>permAddrs</code> map of <code>AccountKeeper</code>.</p> <p>This address mapping is set at compile time and cannot be changed at runtime.</p>"},{"location":"pc/","title":"Instructions for use on the PC side","text":""},{"location":"pc/#install","title":"install","text":"<pre><code>Open the installation package, jump out of the following interface, click OK (some antivirus software will falsely report)\n</code></pre> <pre><code>Select the installation directory (recommended to be larger than 1TB)\n</code></pre> <pre><code>Wait patiently for the installation to complete\n</code></pre>"},{"location":"pc/#process","title":"process","text":"<pre><code>Create or import wallet address --&gt; create dpos --&gt; create gateway --&gt; pledge FM --&gt; receive rewards\n</code></pre>"},{"location":"pc/#new-wallet","title":"new wallet","text":""},{"location":"pc/#import-wallet","title":"import wallet","text":""},{"location":"pc/#create-validator","title":"create validator","text":""},{"location":"pc/#create-gateway","title":"create gateway","text":""},{"location":"pc/#pledge-fm","title":"Pledge FM","text":""},{"location":"pc/#receive-award","title":"Receive award","text":""},{"location":"pc/#front-page","title":"front page","text":"<pre><code>The home page contains some global views and functions\n These include:\n\n\nView block synchronization (top right of the interface)\n</code></pre> <pre><code>View task status (upper right corner of interface)\n</code></pre> <pre><code>Management software settings (bottom left corner of the interface)\n</code></pre>"},{"location":"pc/#actions","title":"Actions","text":"<pre><code>The Actions in the upper right corner can manage DID and modify gateway information\n</code></pre>"},{"location":"pc/#did-segment-management","title":"DID segment management","text":"<pre><code>More DID numbers can be obtained by staking FM\n</code></pre> <pre><code>Select the line on the left side of the homepage, including two tabs for assets and gateways\n</code></pre>"},{"location":"pc/#property","title":"Property","text":"<pre><code>Asset interface management includes balance, transfer, transaction records, and account management\n\nThe three buttons on the left correspond to the three main coins of DST, FM and HASH respectively\n</code></pre> <pre><code>On the right side, you can view the balance quantity, transaction records, and send and receive the main currency\n</code></pre> <pre><code>Here export the mnemonic and change the password\n</code></pre>"},{"location":"pc/#gateway","title":"gateway","text":"<pre><code>Gateway function management dpos pledge, gateway server, gateway app, gateway key, etc.\n</code></pre>"},{"location":"pc/#dpos-pledge-management","title":"DPOS pledge management","text":"<pre><code>After becoming a validator, you can check the DPOS status of this node on the _DPOS pledge management_ page\n\nAvailable for pledge and redemption\n</code></pre> <pre><code>The redemption of DPOS is not immediately received, check the redemption status here\n</code></pre> <pre><code>Can view and claim staking rewards and commissions\n</code></pre> <pre><code>Modify the settings of the gateway here\n</code></pre>"},{"location":"pc/#gateway-server-resources","title":"Gateway server resources","text":""},{"location":"pc/#gateway-app","title":"gateway app","text":""},{"location":"pc/#gateway-key","title":"gateway key","text":"<pre><code>For details on how to use the gateway key, see\n</code></pre>"},{"location":"pc/#how-to-use-the-gateway-key","title":"How to use the gateway key","text":""},{"location":"pc/#setting-method","title":"Setting method","text":"<pre><code>Settings include: version detection, language detection, history clearing settings, node settings, data directory settings, routing layer detection\n</code></pre>"},{"location":"pledge/","title":"Pledge","text":""},{"location":"pledge/#abstract","title":"Abstract","text":"<p>This module is responsible for the pledge, destruction, and reward parts related to DaoDst</p>"},{"location":"pledge/#contents","title":"Contents","text":"<ol> <li>Concepts</li> <li>Messages</li> <li>Parameters</li> </ol> <pre><code>chat/\n\u251c\u2500\u2500 client\n\u2502   \u2514\u2500\u2500 rest\n\u2502        \u251c\u2500\u2500 error.go          # Interface error set\n\u2502        \u251c\u2500\u2500 grpc.go           # GRPC inquiry method\n\u2502        \u251c\u2500\u2500 handle_pledge.go # Pledge module message preprocessing\n\u2502        \u251c\u2500\u2500 query.go          # Interface query function\n\u2502        \u251c\u2500\u2500 rest.go           # Registration of Message and Query Routes\n\u2502        \u2514\u2500\u2500 tx.go             # Tx related methods, including broadcasting, etc\n\u251c\u2500\u2500 keeper\n\u2502   \u251c\u2500\u2500 genesis.go        # Module State and Export\n\u2502   \u251c\u2500\u2500 keeper.go         # Store keeper that handles the business logic of the module and has access to a specific subtree of the state tree.\n\u2502   \u251c\u2500\u2500 msg_server.go     # Provide message service processing logic\n\u2502   \u251c\u2500\u2500 params.go         # Parameter getter and setter\n\u2502   \u251c\u2500\u2500 query.go          # State query functions\n\u2502   \u251c\u2500\u2500 medal.go          # Logic algorithms related to hash coin pledge calculation\n\u2502   \u2514\u2500\u2500 mingkeeper.go     # Logic Algorithm for Foundry Additional Issuance\n\u251c\u2500\u2500 types\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 codec.go          # Type registration for encoding\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 errors.go         # Module-specific errors\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 events.go         # Events exposed to the Tendermint PubSub/Websocket\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 genesis.go        # Genesis state for the module\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 interface.go      # Interface of the module\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 keys.go           # Store keys and utility functions\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 msg.go            # Pledge module transaction messages\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 params.go         # Module parameters that can be customized with governance parameter change proposals\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 types.go          # Type collection of modules\n\u251c\u2500\u2500 genesis.go            # ABCI InitGenesis and ExportGenesis functionality\n\u251c\u2500\u2500 handler.go            # Message routing\n\u2514\u2500\u2500 module.go             # Module setup for the module manager\n</code></pre>"},{"location":"pledge/#concepts","title":"Concepts","text":""},{"location":"pledge/#pledge","title":"Pledge","text":"<pre><code>The pledge module is responsible for the pledge and destruction of DaoDST\n</code></pre>"},{"location":"pledge/#dst-hash","title":"DST &amp; HASH","text":"<pre><code>Users can obtain hash tokens by destroying the dst pipeline, while pledging the hash to continuously obtain and select dst rewards at any time,\nAfter reaching a certain level, the hash can be redeemed and traded\n</code></pre>"},{"location":"pledge/#hash","title":"HASH","text":"<pre><code>When registering for a chat, it is necessary to destroy a certain amount of dsts and exchange them for hashes according to the calculation. The obtained hashes will be automatically pledged, and according to the rules, each block will receive a reward (dst)\nThe redemption and trading of hash requires reaching a certain level of free mason\n</code></pre>"},{"location":"pledge/#freemason-level","title":"Freemason level","text":"<pre><code>There are some benefits to increasing the level of Freemason, such as unlocking the redemption and trading of hashes, increasing the proportion of hashes obtained by destroying dsts, unlocking more chat rooms, and increasing online storage space for chats.\nThe free mason level is linked to the hash pledge amount, and the relationship between the hash pledge amount and level can be changed through voting\n</code></pre>"},{"location":"pledge/#hash-transfer","title":"HASH transfer","text":"<pre><code>Hash transfers will charge more gas, approximately 10000 times that of regular transfers\n</code></pre>"},{"location":"pledge/#destroy-dst","title":"Destroy DST","text":"<pre><code>When destroying DSTs, additional rewards (dsts) will be issued to the registered and current gateways based on the amount of destruction, as well as additional rewards to the miners\n\nThe calculation for exchanging DST for HASH is as follows\n\nDestruction amount/(DST reward issuance amount on the same day/cumulative network HASH acquisition amount)=number of HASH obtained\n</code></pre>"},{"location":"pledge/#pledge-hash","title":"Pledge HASH","text":"<pre><code>Pledging HASH can continuously earn DST rewards\n\nDST will issue additional shares every time a block is issued, and users will receive dst rewards based on the hash pledge proportion\n\nThe calculation of the number of additional issues for each block of dst is as follows\n\nBlock inflation=\uff08\uff080.35-Quantity destroyed in the last 100 days\uff09/ 0.35 *\uff08Maximum inflation rate3.65 -Minimum inflation rate1.21\uff09+Minimum inflation rate1.21\uff09/Number of blocks produced per year5259600\n</code></pre>"},{"location":"pledge/#keeper","title":"Keeper","text":"<p>The Chat module <code>Keeper</code> grants access to the Chat module state and implements <code>statedb.Keeper</code> interface to support the <code>StateDB</code> implementation. The Keeper contains a store key that allows the DB to write to a concrete subtree of the multistore that is only accessible by the Chat module. Instead of using a trie and database for querying and persistence (the <code>StateDB</code> implementation), Daodst uses the Cosmos <code>KVStore</code> (key-value store) and Cosmos SDK <code>Keeper</code> to facilitate state transitions.</p> <p>To support the interface functionality, it imports 4 module Keepers:</p> <ul> <li><code>auth</code>: CURD for accounts</li> <li><code>bank</code>: CURD for supply and balance</li> <li><code>comm</code>: Management of gateway related data</li> <li><code>chat</code>: Management of chat data</li> </ul> <pre><code>type Keeper struct {\n    storeKey   sdk.StoreKey\n    cdc        codec.BinaryCodec\n    paramstore paramtypes.Subspace\n\n    hooks            types.PledgeHooks\n    AccountKeeper    types.AccountKeeper\n    BankKeeper       types.BankKeeper\n    CommKeeper       types.CommKeeper\n    ChatKeeper       types.ChatKeeper\n    FeeCollectorName string\n}\n\n</code></pre>"},{"location":"pledge/#messages","title":"Messages","text":""},{"location":"pledge/#msgpledge","title":"MsgPledge","text":"<pre><code>Initiate the destruction of dst through this message\n</code></pre> <pre><code>    type MsgPledge struct {\n        FromAddress      string     `protobuf:\"bytes,1,opt,name=from_address,json=fromAddress,proto3\" json:\"from_address,omitempty\" yaml:\"from_address\"`\n        DelegatorAddress string     `protobuf:\"bytes,2,opt,name=delegator_address,json=delegatorAddress,proto3\" json:\"delegator_address,omitempty\" yaml:\"delegator_address\"`\n        ValidatorAddress string     `protobuf:\"bytes,3,opt,name=validator_address,json=validatorAddress,proto3\" json:\"validator_address,omitempty\" yaml:\"validator_address\"`\n        Amount           types.Coin `protobuf:\"bytes,4,opt,name=amount,proto3\" json:\"amount\"`\n    }\n</code></pre>"},{"location":"pledge/#msgwithdrawdelegatorreward","title":"MsgWithdrawDelegatorReward","text":"<pre><code>Through this message, select the dst reward for pledge hash\n</code></pre> <pre><code>    type MsgWithdrawDelegatorReward struct {\n        DelegatorAddress string `protobuf:\"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3\" json:\"delegator_address,omitempty\" yaml:\"delegator_address\"`\n    }\n</code></pre>"},{"location":"pledge/#msgunpledge","title":"MsgUnpledge","text":"<pre><code>Through this message, redeem the pledged hash\n</code></pre> <pre><code>    type MsgUnpledge struct {\n        DelegatorAddress string     `protobuf:\"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3\" json:\"delegator_address,omitempty\" yaml:\"delegator_address\"`\n        Amount           types.Coin `protobuf:\"bytes,2,opt,name=amount,proto3\" json:\"amount\"`\n    }\n</code></pre>"},{"location":"pledge/#msgburngetmedal","title":"MsgBurnGetMedal","text":"<pre><code>Destroy dst to obtain Hash\n</code></pre> <pre><code>    type MsgBurnGetMedal struct {\n        FromAddress string     `protobuf:\"bytes,1,opt,name=from_address,json=fromAddress,proto3\" json:\"from_address,omitempty\" yaml:\"from_address\"`\n        ToAddress   string     `protobuf:\"bytes,2,opt,name=to_address,json=toAddress,proto3\" json:\"to_address,omitempty\" yaml:\"to_address\"`\n        Gateway     string     `protobuf:\"bytes,3,opt,name=gateway,proto3\" json:\"gateway,omitempty\" yaml:\"gateway\"`\n        BurnCoin    types.Coin `protobuf:\"bytes,4,opt,name=burn_coin,json=burnCoin,proto3\" json:\"burn_coin\" yaml:\"burn_coin\"`\n    }\n</code></pre>"},{"location":"pledge/#parameters","title":"Parameters","text":"<p>The pledge module contains the following module parameters</p>"},{"location":"pledge/#params","title":"Params","text":"Key Type Default Value <code>KeyInflationDays</code> int64 <code>100</code> <code>InflationMax</code> github_com_cosmos_cosmos_sdk_types.Dec <code>3.65</code> <code>InflationMin</code> github_com_cosmos_cosmos_sdk_types.Dec <code>1.21</code> <code>GoalBonded</code> github_com_cosmos_cosmos_sdk_types.Dec <code>0.35</code> <code>BlocksPerYear</code> uint64 <code>5259600</code> <code>UnbondingHeight</code> int64 <code>302400</code> <code>MinBurnCoin</code> github_com_cosmos_cosmos_sdk_types.Coin <code>100000000000000000000dst</code> <code>BurnCurrentGatePercent</code> github_com_cosmos_cosmos_sdk_types.Dec <code>0.1</code> <code>BurnRegisterGatePercent</code> github_com_cosmos_cosmos_sdk_types.Dec <code>0.1</code> <code>BurnDposPercent</code> github_com_cosmos_cosmos_sdk_types.Dec <code>0.1</code> <code>BurnReturnDays</code> int64 <code>120</code> <code>BurnLevels</code> []BurnLevel"},{"location":"pledge/#burnlevels","title":"BurnLevels","text":"<p>BurnLevels defines the relevant benefits that can be enjoyed by a free mason level, including three types of benefits</p> <ol> <li>The ratio of destroying dst to hash</li> <li>Chat storage space</li> <li>The number of chat room unlocked</li> </ol> Level MedalAmount AddPercent RoomAmount <code>1</code> <code>100</code> <code>1</code> <code>0</code> <code>2</code> <code>200</code> <code>2</code> <code>0</code> <code>3</code> <code>400</code> <code>3</code> <code>0</code> <code>4</code> <code>800</code> <code>4</code> <code>0</code> <code>5</code> <code>1600</code> <code>5</code> <code>1</code> <code>6</code> <code>3200</code> <code>6</code> <code>2</code> <code>7</code> <code>6400</code> <code>7</code> <code>3</code> <code>8</code> <code>12800</code> <code>8</code> <code>4</code> <code>9</code> <code>25600</code> <code>9</code> <code>5</code> <code>10</code> <code>51200</code> <code>12</code> <code>6</code> <code>11</code> <code>102400</code> <code>15</code> <code>7</code> <code>12</code> <code>204800</code> <code>18</code> <code>8</code> <code>13</code> <code>409600</code> <code>21</code> <code>9</code> <code>14</code> <code>819200</code> <code>24</code> <code>10</code> <code>15</code> <code>1638400</code> <code>27</code> <code>11</code> <code>16</code> <code>3276800</code> <code>30</code> <code>12</code> <code>17</code> <code>6553600</code> <code>33</code> <code>13</code> <code>18</code> <code>13107200</code> <code>36</code> <code>14</code> <code>19</code> <code>26214400</code> <code>39</code> <code>15</code> <code>20</code> <code>52428800</code> <code>43</code> <code>16</code> <code>21</code> <code>104857600</code> <code>47</code> <code>17</code> <code>22</code> <code>209715200</code> <code>51</code> <code>18</code> <code>23</code> <code>419430400</code> <code>55</code> <code>19</code> <code>24</code> <code>838860800</code> <code>59</code> <code>20</code> <code>25</code> <code>1677721600</code> <code>63</code> <code>21</code> <code>26</code> <code>3355443200</code> <code>67</code> <code>22</code> <code>27</code> <code>6710886400</code> <code>71</code> <code>23</code> <code>28</code> <code>13421772800</code> <code>75</code> <code>24</code> <code>29</code> <code>26843545600</code> <code>79</code> <code>25</code> <code>30</code> <code>53687091200</code> <code>84</code> <code>26</code> <code>31</code> <code>107374182400</code> <code>89</code> <code>27</code> <code>32</code> <code>214748364800</code> <code>94</code> <code>28</code> <code>33</code> <code>429496729600</code> <code>100</code> <code>29</code>"},{"location":"protocol/","title":"Protocol","text":""},{"location":"protocol/#account","title":"account","text":"<p>Crypto wallets (or accounts) can be created and represented in unique ways on different blockchains. For developers interacting with account types on Daodst, during wallet integration on their dApp frontend, it is important to understand that accounts on Daodst are implemented to be compatible with Ethereum type addresses.</p>"},{"location":"protocol/#create-an-account","title":"Create an account","text":"<p>To create an account, you create a private key, a keystore file (a password-protected private key), or a seed phrase (a string of words that gives access to multiple private keys).</p> <p>Besides having different security features, the biggest difference between them is that the private key or keystore file only creates an account. Creating a seed phrase can give you control over many accounts, all of which can be accessed using the same phrase.</p> <p>The Cosmos blockchain, like Daodst, supports account creation using mnemonic phrases, also known as Hierarchical Deterministic Key Generation (HD Keys). This allows users to create accounts on multiple blockchains without having to manage multiple keys.</p> <p>HD keys generate addresses by taking a mnemonic phrase and combining it with a piece of information called a derivation path. Blockchains can differ in the derivation paths they support. Therefore, to access all accounts via a mnemonic phrase on a blockchain, it is important to use a specific derivation path for that blockchain.</p>"},{"location":"protocol/#agent-account","title":"Agent Account","text":"<p>The terms \"account\" and \"address\" are often used interchangeably to describe crypto wallets. In the Cosmos SDK, an account specifies a pair of public key (PubKey) and private key (PrivKey). Derivation paths define private keys, public keys, and addresses.</p> <p>A PubKey can be derived to generate various addresses in different formats, which are used to identify users (among other parties) within the application. A common address form for Cosmos chains is the bech32 format (e.g. dst1 ...). Addresses are also associated with messages to identify the sender of the message.</p> <p>A PrivKey is used to generate a digital signature attesting that the address associated with the PrivKey approves a given message. Attestation is performed by applying a cryptographic scheme called the Elliptic Curve Digital Signature Algorithm (ECDSA) to the PrivKey to generate a public key that is compared to the address in the message.</p>"},{"location":"protocol/#daodst-account","title":"Daodst Account","text":"<p>Daodst defines its own custom account type to implement HD wallets compatible with Ethereum type addresses. It uses Ethereum's ECDSA secp256k1 curve as the key (eth_secp265k1) and satisfies the full BIP44 path of EIP84. Do not confuse this cryptographic curve with Bitcoin's ECDSA secp256k1 curve.</p> <p>The root HD path for Daodst based accounts is <code>m/44'/60'/0'/0</code>. Daodst uses Coin type 60 to support Ethereum type accounts, unlike many other Cosmos chains which use Coin type 118 (list of coin types</p> <p>The custom Daodst EthAccount satisfies the AccountI interface from the Cosmos SDK authentication module and contains additional fields required for Ethereum type addresses:</p> <pre><code>// EthAccountI represents the interface of an EVM compatible account\ntype EthAccountI interface {\n    authtypes.AccountI\n    // EthAddress returns the ethereum Address representation of the AccAddress\n    EthAddress() common.Address\n    // CodeHash is the keccak256 hash of the contract code (if any)\n    GetCodeHash() common.Hash\n    // SetCodeHash sets the code hash to the account fields\n    SetCodeHash(code common.Hash) error\n    // Type returns the type of Ethereum Account (EOA or Contract)\n    Type() int8\n}\n</code></pre>"},{"location":"protocol/#address-and-public-key","title":"address and public key","text":"<p>BIP-0173 defines a new format for Segregated Witness output addresses that includes a human-readable portion identifying Bech32 usage. Daodst uses the following HRPs (human-readable prefixes) as base HRPs:</p> Network Mainnet Testnet daodst daodst daodst <p>There are 3 main types of HRP for addresses/public keys available by default on Daodst:</p> <ul> <li>The account's address and key, which identify the user (such as the sender of a message). They are derived using the eth_secp256k1 curve.</li> <li>The validator operator's address and key, used to identify the validator's operator. They are derived using the eth_secp256k1 curve.</li> <li>The address and key of the consensus node, used to identify the verification nodes participating in the consensus. They are derived using the ed25519 curve</li> </ul> Name bech32 address prefix bech32 public key prefix curve address byte length public key byte length account dst dstpub eth_secp256k1 20 33(compressed) validator operation dstvaloper dstvaloperpub eth_secp256k1 20 33(compressed) consensus node dstvalcons dstvalconspub ed25519 dst 32"},{"location":"protocol/#customer-address-format","title":"Customer address format","text":"<p>Eth account number can be represented in Bech32 (dst1...) and hexadecimal (0x...) formats for Ethereum's Web3 tools compatibility.</p> <p>The Bech32 format is the default format for Cosmos-SDK queries and transactions via CLI and REST clients. On the other hand, the hexadecimal format is Ethereum common.Address represents Cosmos sdk.AccAddress.</p> <ul> <li>Address (Bech32): <code>dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw</code></li> <li>Address (EIP55 hexadecimal): <code>0x91defC7fE5603DFA8CC9B655cF5772459BF10c6f</code></li> <li>Compress public key: <code>{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2\"}</code></li> </ul>"},{"location":"protocol/#address-translation","title":"address translation","text":"<p>stcd debug addr  can be used to convert addresses between hexadecimal and bech32 formats. For example: Bech32 <pre><code> $ stcd debug addr dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw\n  Address: [20 87 74 109 255 45 223 158 7 130 139 67 69 211 4 9 25 175 86 82]\n  Address (hex): 14574A6DFF2DDF9E07828B4345D3040919AF5652\n  Bech32 Acc: dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw\n  Bech32 Val: dstvaloper1z3t55m0l9h0eupuz3dp5t5cypyv674jjn4d6nn\n</code></pre> <p>Hex</p> <pre><code> $ stcd debug addr 14574A6DFF2DDF9E07828B4345D3040919AF5652\n  Address: [20 87 74 109 255 45 223 158 7 130 139 67 69 211 4 9 25 175 86 82]\n  Address (hex): 14574A6DFF2DDF9E07828B4345D3040919AF5652\n  Bech32 Acc: dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw\n  Bech32 Val: dstvaloper1z3t55m0l9h0eupuz3dp5t5cypyv674jjn4d6nn\n</code></pre>"},{"location":"protocol/#key-export","title":"Key export","text":"<p>We can use stcd's keys show command with flags --bech  (acc|val|cons) to get addresses and keys, as described above, <p>Ordinary account</p> <pre><code>  $ stcd keys show dev0 --bech acc\n- name: dev0\n   type: local\n   address: dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw\n   pubkey: '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2\"}'\n   mnemonic: \"\"\n</code></pre> <p>validator</p> <pre><code>  $ stcd keys show dev0 --bech val\n- name: dev0\n   type: local\n   address: dstvaloper1z3t55m0l9h0eupuz3dp5t5cypyv674jjn4d6nn\n   pubkey: '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2\"}'\n   mnemonic: \"\"\n</code></pre> <p>consensus</p> <pre><code>  $ stcd keys show dev0 --bech cons\n- name: dev0\n   type: local\n   address: dstvalcons1rllqa5d97n6zyjhy6cnscc7zu30zjn3f7wyj2n\n   pubkey: '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"A/fVLgIqiLykFQxum96JkSOoTemrXD0tFaFQ1B0cpB2c\"}'\n   mnemonic: \"\"\n</code></pre>"},{"location":"protocol/#account-query","title":"Account Query","text":"<p>You can use CLI, gRPC or</p> <p>command line interface</p> <pre><code># NOTE: the --output (-o) flag will define the output format in JSON or YAML (text)\nstcd q auth account $(stcd keys show dev0 -a) -o text\n\n'@type': /ethermint.types.v1.EthAccount\nbase_account:\naccount_number: \"0\"\naddress: dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw\npub_key:\n  '@type': /ethermint.crypto.v1.ethsecp256k1.PubKey\n  key: AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2\nsequence: \"1\"\ncode_hash: 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\n</code></pre> <p>Cosmos gRPC and REST</p> <pre><code># GET /cosmos/auth/v1beta1/accounts/{address}\ncurl -X GET \"http://localhost:10337/cosmos/auth/v1beta1/accounts/dst14au322k9munkmx5wrchz9q30juf5wjgz2cfqku\" -H \"accept: application/json\"\n</code></pre> <p>JSON-RPC To retrieve Ethereum hex addresses using Web3, use the JSON-RPC eth_accounts or personal_listAccounts endpoints</p> <pre><code># query against a local node\ncurl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_accounts\",\"params\":[],\"id\":1}' -H \"Content-Type: application/json\" http://localhost:8545\n\ncurl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"personal_listAccounts\",\"params\":[],\"id\":1}' -H \"Content-Type: application/json\" http://localhost:8545\n</code></pre>"},{"location":"protocol/#chain-id","title":"Chain ID","text":"<p>A chain ID is a unique identifier that represents a blockchain network. We use it to differentiate between different blockchain networks and ensure transactions and messages are sent to the correct network. The Daodst network follows the format of identifier_EIP155-version.</p>"},{"location":"protocol/#mainnet","title":"Mainnet","text":"Name Chain ID Identifier EIP155 Number Version activation Daodst2 <code>daodst_7001-2</code> dst 7002 2 yes Daodst1 <code>daodst_7001-1</code> dst 7001 1 no"},{"location":"protocol/#testnet","title":"testnet","text":"Name Chain ID Identifier EIP155 Number Version activation Daodst Public Testnet <code>daodst_7000-2</code> dst 7000 2 yes Daodst Public Testnet <code>daodst_7000-1</code> dst 7000 1 no"},{"location":"protocol/#chain-identity","title":"Chain identity","text":"<p>Every chain must have a unique identifier or <code>chain-id</code>. Tendermint requires each application to define its own <code>chain-id</code> in the genesis.json fields. However, in order to comply with both EIP155 and the Cosmos chain upgrade standard, Daodst-compatible chains must implement a special structure for their chain identifiers.</p> <p> Structure </p> <p>The Daodst chain ID consists of 3 main components</p> <ul> <li>Identifier: An unstructured string defining the name of the application.</li> <li>EIP155 Number: Immutable EIP155 <code>CHAIN_ID</code>   Defines the number of replay attack protections.</li> <li>version number: is the version number of the chain currently running (always a positive number). This number MUST be incremented every time the chain is upgraded or forked to avoid network or consensus errors.</li> </ul> <p>  Format </p> <p>The format of the Daodst-compatible chain-id specified in genesis is as follows:</p> <pre><code>{identifier}_{EIP155}-{version}\n</code></pre> <p>The following table provides an example, where the second row corresponds to an upgrade of the first row:</p> ChainID Identifier EIP155 Number Version Number <code>daodst_7000-1</code> dst 7000 1 <code>daodst_7000-2</code> dst 7000 2 <code>...</code> ... ... ... <code>daodst_7000-N</code> dst 7000 N"},{"location":"protocol/#encoding","title":"encoding","text":"<p>Encoding refers to the process of converting data from one format to another to make it more secure and efficient.</p> <p>In the context of blockchain, encoding is used to ensure that data is stored and transmitted in a secure and easily accessible manner.</p> <p>Recursive Length Prefix (RLP) is a serialization format widely used in Ethereum execution clients.</p> <p>Its purpose is to encode arbitrarily nested arrays of binary data, and is the primary encoding used to serialize objects in Ethereum.</p> <p>RLP only encodes structures, leaving the encoding of specific atomic data types (such as strings, integers, and floats) to higher-level protocols.</p> <p>In Ethereum, integers must be represented in big-endian binary form without leading zeros, such that an integer value of zero is equivalent to an empty byte array.</p> <p>The RLP encoding function accepts an item, which is defined as a single byte with a value in the range [0x00, 0x7f] or a string 0-55 bytes long.</p> <p>If the string is longer than 55 bytes, the RLP encoding contains a byte with the value 0xb7 (dec.183) plus the length The length of the string in bytes in binary, followed by the length of the string, followed by the string.</p> <p>RLP is used for hash verification, where a transaction is signed by signing the RLP hash of the transaction data, and a block is identified by the RLP hash of its header.</p> <p>RLP is also used to encode data over networks, and in some cases should support efficient encoding of Merkle tree data structures.</p> <p>The Ethereum execution layer uses RLP as the primary encoding for serializing objects, but the newer Simple Serialize (SSZ) replaces RLP as the encoding for the new consensus layer in Ethereum 2.0.</p> <p>The Cosmos Stargate release introduced protobuf as the primary encoding format for client and state serialization.</p> <p>All EVM module types for state and clients, such as transaction messages, genesis, query services, etc., will be implemented as protocol buffer messages.</p> <p>The Cosmos SDK also supports traditional Amino encoding.</p> <p>Protocol Buffers (protobuf) is a language-independent binary serialization format that is smaller and faster than JSON.</p> <p>It is used to serialize structured data, such as messages, and is designed to be efficient and scalable.</p> <p>The encoding format is defined in a language-independent language called Protocol Buffers Language (proto3), and encoded messages can be used to generate code for various programming languages.</p> <p>The main advantage of protobuf is its efficiency, which results in smaller message sizes and faster serialization and deserialization times.</p> <p>The RLP decoding process is as follows: decode the data type, actual data length and offset according to the first byte of the input data (that is, the prefix); decode the data accordingly according to the data type and offset.</p>"},{"location":"protocol/#prerequisites-reading","title":"Prerequisites Reading","text":"<ul> <li>Cosmos SDK Encoding</li> <li>Ethereum RLP</li> </ul>"},{"location":"protocol/#encoding-format","title":"Encoding format","text":"<p> Protocol Buffers </p> <p>The Cosmos Stargate release introduces protobuf as the primary encoding format for client and state serialization.</p> <p>All EVM module types for state and clients (transaction messages, genesis, query services, etc.) will be implemented as protocol buffer messages.</p> <p> Amino </p> <p>The Cosmos SDK also supports the legacy Amino encoding format for backward compatibility with previous versions, especially for client-side encoding and signing with Ledger devices.</p> <p>Daodst does not support Amino in the EVM module, but all other Cosmos SDK modules that enable it support it.</p> <p> RLP </p> <p>Recursive Length Prefix (RLP) is an encoding/decoding algorithm that serializes messages and allows fast reconstruction of encoded data.</p> <p>Daodst uses RLP to encode/decode Ethereum messages for JSON-RPC processing so that messages conform to the correct Ethereum format. This allows messages to be encoded and decoded in the exact same format as Ethereum's.</p> <p><code>x/evm</code> transaction (<code>MsgEthereumTx</code>) encoding is performed by converting the message to go-ethereum's <code>Transaction</code> and then using RLP to marshal the transaction data:</p> <pre><code>// TxEncoder overwrites sdk.TxEncoder to support MsgEthereumTx\nfunc (g txConfig) TxEncoder() sdk.TxEncoder {\nreturn func(tx sdk.Tx) ([]byte, error) {\n  msg, ok := tx.(*evmtypes.MsgEthereumTx)\n  if ok {\n    return msg.AsTransaction().MarshalBinary()\n  }\n  return g.TxConfig.TxEncoder()(tx)\n}\n}\n\n// TxDecoder overwrites sdk.TxDecoder to support MsgEthereumTx\nfunc (g txConfig) TxDecoder() sdk.TxDecoder {\nreturn func(txBytes []byte) (sdk.Tx, error) {\n  tx := &amp;ethtypes.Transaction{}\n\n  err := tx.UnmarshalBinary(txBytes)\n  if err == nil {\n    msg := &amp;evmtypes.MsgEthereumTx{}\n    msg.FromEthereumTx(tx)\n    return msg, nil\n  }\n\n  return g.TxConfig.TxDecoder()(txBytes)\n}\n}\n</code></pre>"},{"location":"protocol/#gas-and-handling-fee","title":"Gas and handling fee","text":"<p>Users need to pay fees to submit transactions on the Daodst network. Since fees are handled differently in Ethereum and Cosmos, it is important to understand how the Daodst blockchain implements Ethereum-type fee calculations that are compatible with the Cosmos SDK.</p> <p>Thus, this overview explains the basics of gas calculations, how fees are provided for transactions, and how Ethereum-style fee calculations use the fee market (EIP1559) to prioritize transactions.</p> <p>Also note that fees paid to interact with smart contracts on Daodst can earn revenue for smart contract deployers. For information on this, go to develop.</p> <p> Prerequisite Reading </p> <ul> <li>Cosmos SDK Gas</li> <li>Ethereum Gas</li> </ul> <p> Basics </p> <p> Why is there a transaction fee? </p> <p>If anyone could submit transactions to the network for free, the network could be overwhelmed by a small number of participants sending fraudulent transactions to clog the network and make it non-functional.</p> <p>The solution to this problem is a concept called \"gas\", which is the resource consumed throughout the execution of a transaction.</p> <p>In practice, each step of code execution consumes a small amount of gas, effectively charging validator resource usage and preventing malicious actors from disrupting the network at will.</p> <p> What is Gas? </p> <p>In general, gas is a unit of measure for the computational intensity of a particular transaction \u2014 in other words, how much work is required to evaluate and execute it.</p> <p>Complex multi-step transactions, such as a Cosmos transaction that delegates to a dozen validators, require more gas than simple single-step transactions (such as a Cosmos transaction that sends tokens to another address).</p> <p>When referring to a transaction, \"gas\" refers to the total amount of gas required for the transaction.</p> <p>For example, a transaction may require 300,000 units of gas to execute.</p> <p>Think of gas as electricity (kWh) in a house or factory, or as fuel for a car.</p> <p>The idea is that it costs some money to get somewhere.</p> <p>More Gas introduction:</p> <ul> <li>Cosmos Gas Fees</li> <li>Cosmos Tx Lifecycle</li> <li>Ethereum Gas</li> </ul> <p> How Gas is Calculated </p> <p>In general, there is no way to know exactly how much gas a transaction will cost without simply running it.</p> <p>Using the Cosmos SDK, this can be done with Simulating a Tx.</p> <p>Otherwise, there are ways to estimate the gas a transaction will require based on details of the transaction fields and data.</p> <p>For example, in the case of the EVM, each bytecode operation has a corresponding amount of gas.</p> <p>More about Gas calculation:</p> <ul> <li>Estimate Gas</li> <li>Executing EVM Bytecode</li> <li>Simulate a Cosmos SDK Tx</li> </ul> <p> What is the relationship between Gas and transaction fee? </p> <p>Gas refers to the computational work required to perform it, while the fee refers to the amount of tokens you actually spend to execute the transaction.</p> <p>They are derived using the following formulas:</p> <pre><code>Total Fees = Gas * Gas Price (the price per unit of gas)\n</code></pre> <p>If <code>gas</code> is in kWh, then \"gas price\" will be the rate determined by your energy supplier in USD/kWh, and <code>fees</code> will be your bill.</p> <p>Like electricity, gas prices can fluctuate on a given day, depending on network traffic.</p> <p>More about Gas and Fees:</p> <ul> <li>Cosmos Gas and Fees</li> <li>Ethereum Gas and Fees</li> </ul> <p> How does Cosmos handle transaction fees? </p> <p>Gas fees in Cosmos are relatively simple. As a user, you specify two fields:</p> <ol> <li>Corresponding to <code>GasLimit</code> of the execution gas limit, defined as <code>GasWanted</code></li> <li>One of <code>Fees</code> or <code>GasPrice</code>, which will be used to specify or calculate the transaction fee</li> </ol> <p>The node will fully consume the provided fee and then start executing the transaction. If the <code>GasLimit</code> is found to be insufficient during execution, the transaction will fail and any changes will be rolled back, the provided fee will not be refunded.</p> <p>Validators of Cosmos SDK-based chains can specify a \"minimum gas price\" that they will enforce when selecting transactions to include in a block.</p> <p>As a result, transactions with insufficient fees will experience delays or fail outright.</p> <p>At the beginning of each block, the previous block's fees are distributed to validators and delegators, after which they can be withdrawn and spent.</p> <p> How are fees handled on Ethereum? </p> <p>Ethereum fees include multiple implementations introduced over time.</p> <p>Initially, the user will specify the <code>GasPrice</code> and <code>GasLimit</code> in the transaction - much like a Cosmos SDK transaction.</p> <p>Block proposers will receive the full gas fee from each transaction in the block, and they will choose which transactions to include accordingly.</p> <p>With the proposal EIP-1559 and the London hard fork, the gas calculation has changed.</p> <p>The above <code>GasPrice</code> is now split into two separate parts: <code>BaseFee</code> and <code>PriorityFee</code>.</p> <p><code>BaseFee</code> is automatically calculated based on the block size and will be destroyed once the block is mined.</p> <p><code>PriorityFee</code> is given to the proposer and represents a tip, or incentive for the proposer to include the transaction in a block.</p> <pre><code>Gas Price = Base Fee + Priority Fee\n</code></pre> <p>In a transaction, in addition to specifying a <code>gas_limit</code> as before, the user can specify a <code>max_fee_per_gas</code> corresponding to the total <code>GasPrice</code> and a <code>max_priority_fee_per_gas</code> corresponding to the maximum <code>PriorityFee</code>.</p> <p>All excess gas not required for execution is returned to the user.</p> <p>More about Ethereum fees:</p> <ul> <li>Gas Calculation Docs</li> <li>Proposal EIP-1559</li> </ul> <p> Implementation </p> <p> How to deal with Gas and transaction fees on Daodst? </p> <p>Fundamentally, Daodst is a Cosmos SDK chain that enables EVM compatibility as part of the Cosmos SDK module. Due to this architecture, all EVM transactions are ultimately encoded as Cosmos SDK transactions and update the state managed by the Cosmos SDK. Since all transactions are represented as Cosmos SDK transactions, transaction fees can be at different execution layers.</p> <p>In fact, processing fees include standard Cosmos SDK logic, some Ethereum logic, and customDaodst logic. In most cases, fees are collected by the <code>fee_collector</code> module and then paid to validators and delegators. Some key differences are as follows:</p> <ol> <li>Fee market module</li> </ol> <p>To support EIP-1559 gas and fee calculations on Daodst' EVM layer, Daodst tracks the gas supplied for each block and uses it to calculate base fees for future EVM transactions, enabling EIP-specified EVM dynamic fees and transaction prioritization Level -1559.</p> <p>For EVM transactions, each node bypasses its local <code>min-gas-prices</code> configuration and instead applies EIP-1559 fee logic - the gas price must simply be greater than the global <code>min-gas-price</code> and the block's <code>BaseFee</code>, the remainder is considered the priority tip.</p> <p>This allows validators to calculate Ethereum fees without applying the Cosmos SDK fee logic.</p> <p>Unlike Ethereum, the \"BaseFee\" on Daodst is not destroyed, but distributed to validators and delegators</p> <p>Additionally, <code>BaseFee</code> is bounded by the global <code>min-gas-price</code> (currently, the global <code>min-gas-price</code> parameter is set to zero, although it can be updated via governance).</p> <ol> <li>EVM Gas return</li> </ol> <p>Daodst refunds a small portion (at least 50% by default) of unspent gas for EVM transactions to approximate the current behavior on Ethereum.</p> <ol> <li>Revenue module</li> </ol> <p>Daodst develops the revenue module as a way to reward developers for creating useful dApps - any contract that registers with the Daodst revenue module rewards the contract developer with a small portion of transaction fees (currently 95% ). Validators and delegators earn the remainder.</p> <p> Detailed Schedule </p> <ol> <li> <p>The node executes the previous block and runs the <code>EndBlock</code> hook * As part of this hook, the FeeMarket (EIP-1559) module tracks the total <code>TransientGasWanted</code> from transactions on that block.    This will be used for the <code>BaseFee</code> of the next block.</p> </li> <li> <p>Nodes receive transactions for subsequent blocks and gossip about these transactions to their peers *These can be sorted and prioritized by included fee price (EVM transactions using EIP-1559 fee priority mechanism - [code snippet], will be included in the next block</p> </li> <li> <p>The node runs <code>BeginBlock</code> * FeeMarket module to calculate <code>BaseFee</code> for subsequent blocks Apply to this block using the total <code>GasWanted</code> from the previous block.</p> </li> <li> <p>Distribution module distributes The previous block's fee rewards to validators and delegators</p> </li> <li> <p>For each valid transaction to be included in this block, the node does the following:</p> </li> </ol> <p> They run an <code>AnteHandler</code> corresponding to the transaction type .</p> <p>This process:</p> <ol> <li>Perform basic transaction validation</li> <li>Verify that the provided fee is greater than the global and local minimum validator values and greater than the computed <code>BaseFee</code><ol> <li>(For Ethereum transactions) Preempting EVM transaction consumption gas</li> </ol> </li> <li>Deduct the user's transaction fee and transfer it to the <code>fee_collector</code> module</li> <li>Increase the <code>TransientGasWanted</code> in the current block to calculate the <code>BaseFee</code> of the next block</li> </ol> <p>Then, for standard Cosmos transactions, nodes</p> <ul> <li>Execute transactions and update status</li> <li>Transaction consumes gas</li> </ul> <p>For Ethereum transactions, nodes:</p> <ul> <li>Execute transactions and update status</li> <li>Calculates the gas used and compares it to the supplied gas, then refunds the remainder of the specified portion</li> <li> <p>If the transaction interacts with a registered smart contract, a small portion of the fee used as revenue is sent to the contract developer as part of the revenue module</p> </li> <li> <p>The node runs <code>EndBlock</code> for this block and stores the <code>GasWanted</code> of the block</p> </li> </ul> <p> DETAILED APPROACH </p> <p> Cosmos <code>Gas</code> </p> <p>In the Cosmos SDK, gas is mainly tracked in <code>GasMeter</code> and <code>BlockGasMeter</code>:</p> <ul> <li><code>GasMeter</code>: Tracks gas consumed during executions that lead to state transitions. It is reset every time a transaction is executed.</li> <li><code>BlockGasMeter</code>: Tracks gas consumed in a block and enforces gas not exceeding a predefined limit. This limit is defined in the Tendermint consensus parameters and can be changed through governance parameter change proposals.</li> </ul> <p>Since gas is priced in bytes, the same interaction with larger parameter values will cost more gas than smaller parameter values (unlike Ethereum's <code>uint256</code> values, Cosmos SDK values use Big.Int types, which are dynamically resized).</p> <p>More information on gas as part of the Cosmos SDK can be found here.</p> <p> Match EVM Gas Consumption </p> <p>Daodst is an EVM compatible chain that supports Ethereum Web3 tools. For this reason, gas consumption must be comparable to other EVMs, most importantly Ethereum.</p> <p>The main difference between EVM and Cosmos state transitions is that the EVM uses a gas table for each opcode, Instead, Cosmos uses <code>GasConfig</code> to charge gas for each CRUD operation by setting a fixed per-byte cost for accessing the database.</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/3fd376bd5659f076a4dc79b644573299fd1ec1bf/store/types/gas.go#L187-L196</p> <p>To match the gas consumed by the EVM, the gas consumption logic in the SDK is ignored, instead the gas consumed is calculated by subtracting the state transition remaining gas plus the refund from the gas limit defined on the message.</p> <p>To ignore the SDK's gas consumption, we reset the transaction <code>GasMeter</code> count to 0 and manually set it to the <code>gasUsed</code> value calculated by the EVM module at the end of execution.</p> <p> <code>AnteHandler</code> </p> <p>The Cosmos SDK <code>AnteHandler</code> performs basic checks before transaction execution.</p> <p>These checks are typically signature verification, transaction field verification, transaction fees, etc.</p> <p>Regarding gas consumption and fees, <code>AnteHandler</code> checks that the user has enough balance to cover the tx cost (amount plus the fee), and checks that the gas limit defined in the message is greater than or equal to the computed intrinsic gas message.</p> <p> Gas refund </p> <p>In EVM, gas can be specified before execution. The full amount of gas specified is consumed at the start of execution (during the <code>AnteHandler</code> step), if any gas remains after execution, the remaining gas will be refunded to the user.</p> <p>Additionally, the EVM can also define gas to be returned to the user, but these will be limited to a fraction of the gas used, depending on the fork/version used.</p> <p> Zero Fee Transactions </p> <p>In Cosmos, <code>AnteHandler</code> does not enforce minimum gas prices, because <code>min-gas-prices</code> are checked against local nodes/validators.</p> <p>In other words, the minimum fee accepted is determined by the validators of the network, and each validator can specify a different minimum value for their fee.</p> <p>This may allow end users to submit 0-fee transactions if at least one validator is willing to include a <code>0</code> gas price transaction in their proposed block.</p> <p>For the same reason, in Daodst it is possible to send transactions with a <code>0</code> fee for transaction types other than those defined by the <code>evm</code> module.</p> <p>EVM module transactions cannot have a \"0\" fee because the EVM itself requires gas.</p> <p>This check is done by the EVM transaction stateless validation (i.e. <code>ValidateBasic</code>) function as well as a custom <code>AnteHandler</code> defined by Daodst.</p> <p> Gas estimate </p> <p>Ethereum provides a JSON-RPC endpoint <code>eth_estimateGas</code> to help users set the correct gas limit in their transactions.</p> <p>Therefore, a specific query API <code>EstimateGas</code> is implemented in Daodst. It will apply the transaction against the current block/state and perform a binary search to find the best gas value to return to the user (the same transaction will be applied over and over until we find the minimum gas required before failing).</p> <p>The reason we need to use binary search is that the gas required by the transaction may be higher than the value returned by the EVM after applying the transaction, so we need to try until we find the optimal value.</p> <p>A cached context will be used throughout execution to avoid persisting changes in state.</p> <p>For Cosmos Tx, developers can use Cosmos SDK's \u3010Transaction Simulation\u3011(https://docs.cosmos.network/main/run-node/txs#simulating-a-transaction) to create accurate estimates.</p> <p> Cross-chain Gas and Fees </p> <p>Suppose a user transfers tokens from Chain A to Daodst via an IBC transfer and wishes to perform an Daodst transaction - however, they don't have any Daodst tokens to pay for. The Cosmos SDK introduces <code>Tips</code> to solve this problem; users can pay fees with different tokens - in this case, tokens from chain A.</p> <p>To pay a transaction fee with a tip, the user signs a transaction without a tip, and then sends the transaction to a fee relayer. The fee relayer will then pay the fee in the local currency (dst in this case) and receive a payment tip, acting as an intermediary exchange.</p> <p>More information on Cosmos:</p> <ul> <li>Cosmos Tips Documentation</li> </ul> <p> Use Daodst CLI to process gas and transaction fees </p> <p>Users should consider the available options when broadcasting transactions using the Daodst CLI client. There are three flags to consider when sending a transaction to the network:</p> <ul> <li><code>--fees</code>: Fees to pay with the transaction; eg: 10dst. Defaults to required fee.</li> <li><code>--gas</code>: Gas limit to set per transaction; default is 200000.</li> <li><code>--gas-prices</code>: gas prices to determine transaction fees (e.g. 10dst).</li> </ul> <p>However, not all of these need to be defined in every transaction. The correct combination is:</p> <ul> <li><code>--fees=auto</code>: Automatically estimate fees and gas (same behavior as --gas=auto ).   An error is thrown if any other fee-related flags are used (e.g. <code>--gas-prices</code>, <code>--fees</code>)</li> <li><code>--gas=auto</code>: Same behavior as <code>--fees=auto</code>.   An error is thrown if any other fee-related flags are used (e.g. <code>--gas-prices</code>, <code>--fees</code>)</li> <li><code>--gas={int}</code>: use the specified amount of gas and the transaction fee</li> <li><code>--fees={int}{denom}</code>: use the specified fee for tx. Use the gas default (200000) for tx.</li> <li><code>--fees={int}{denom} --gas={int}</code>: Use the specified gas and fee. Computes the gas-price using the provided parameters</li> <li><code>--gas-prices={int}{denom}</code>: Use provided gas prices and default gas amount (200000)</li> <li><code>--gas-prices={int}{denom} --gas={int}</code>: Use the gas specified for tx and calculate the price with the corresponding parameters.</li> </ul> <p>Readers should note that the first two options provide a more user-friendly experience for new users, while the latter are intended for more advanced users who want more control over these parameters.</p> <p>The team introduced the 'auto' flag option, which automatically calculates the gas and fees required to execute a transaction. In this way, new users or developers can execute transactions without defining specific gas and fee values.</p> <p>Using the <code>auto</code> flag may sometimes not estimate the correct gas and fees based on network traffic. To overcome this, you can use a higher value for the <code>--gas-adjustment</code> flag. By default it is set to <code>1.2</code>. When the estimate is insufficient, retry a higher gas adjustment, such as <code>--gas-adjustment 1.3</code>.</p> <p>The <code>--gas-prices</code> and <code>--fees</code> flags cannot be combined. If so, the user will receive an error message stating that fees and gas prices cannot be provided at the same time.</p> <p>Keep in mind that the above combo may fail if the fee or gas amount offered is insufficient. If this is the case, the CLI will return an error message with the specific reason. For example:</p> <pre><code>raw_log: 'out of gas in location: submit proposal; gasWanted: 200000, gasUsed: 263940.\n  Please retry with a gas (--gas flag) amount higher than gasUsed: out of gas'\n</code></pre>"},{"location":"protocol/#key-management","title":"key management","text":"<p>A mnemonic phrase, also known as a seed phrase, is a set of words used to recover or restore a cryptocurrency wallet. It acts as a backup to access your digital assets in case you lose access to the original wallet. The phrase is typically a series of 12-24 words that are generated when you create a wallet, and it should be kept secure and  private.</p> <p>The importance of mnemonic phrases lies in the fact that cryptocurrencies are stored in a decentralized manner, meaning that there is no central authority or institution that holds or controls your funds. This means that if you lose access to your wallet (e.g. forget your password, lose your device), you will not be able to recover your funds without the mnemonic phrase.</p> <p>Therefore, it is crucial to store your mnemonic phrase in a safe and secure place, such as a physical paper or a secure digital file. Additionally, it is recommended to make multiple copies and store them in different locations, so that you can access your funds in case of any emergency.</p> <p>:::note Mnemonic Phrase and Private Key A seed phrase, also known as a recovery phrase or backup phrase, is a sequence of words used to generate a private key. It is typically a set of 12 or 24 words, and it's used to recover or restore access to a cryptocurrency wallet in case the original private key is lost or damaged. A seed phrase can be used to generate multiple private keys, which can be used to access multiple cryptocurrency addresses and balances.</p> <p>On the other hand, a private key is a long string of characters that is used to sign transactions and provide access to your cryptocurrency funds. The private key is generated from the seed phrase and is unique to each cryptocurrency address. It is used to create digital signatures for transactions, which ensure that the transaction is legitimate and has been authorized by the rightful owner of the funds.</p> <p>In conclusion, the security of your private keys and mnemonic phrase is of utmost importance. If your private keys  are compromised, it can put all associated accounts at risk. However, the loss of your mnemonic phrase can have  even more severe consequences as it is used to generate multiple private keys. Therefore, it is crucial to take   proper measures to safeguard both your private keys and mnemonic phrase to avoid any catastrophic loss.</p> <p>:::</p> <p> Mnemons in Daodst CLI </p> <p>:::note Before proceeding with the CLI, please insure you have <code>stcd</code> installed. Installation instruction are located. :::</p> <p>When you create a new key, you'll receive a mnemonic phrase that can be used to restore that key. Backup the mnemonic phrase:</p> <pre><code>stcd keys add dev0\n{\n  \"name\": \"dev0\",\n  \"type\": \"local\",\n  \"address\": \"dst1n253dl2tgyhxjm592p580c38r4dn8023ctv28d\",\n  \"pubkey\": '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"ArJhve4v5HkLm+F7ViASU/rAGx7YrwU4+XKV2MNJt+Cq\"}',\n  \"mnemonic\": \"\"\n}\n\n**Important** write this mnemonic phrase in a safe place.\nIt is the only way to recover your account if you ever forget your password.\n\n# &lt;24 word mnemonic phrase&gt;\n</code></pre> <p>To restore the key:</p> <pre><code>$ stcd keys add dev0-restored --recover\n&gt; Enter your bip39 mnemonic\nbanner genuine height east ghost oak toward reflect asset marble else explain foster car nest make van divide twice culture announce shuffle net peanut\n{\n  \"name\": \"dev0-restored\",\n  \"type\": \"local\",\n  \"address\": \"dst1n253dl2tgyhxjm592p580c38r4dn8023ctv28d\",\n  \"pubkey\": '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"ArJhve4v5HkLm+F7ViASU/rAGx7YrwU4+XKV2MNJt+Cq\"}'\n}\n</code></pre>"},{"location":"protocol/#_1","title":"\u5bc6\u9470\u5c0e\u51fa","text":"<p> Tendermint-\u79c1\u9470\u683c\u5f0f </p> <p>To backup this type of key without the mnemonic phrase, do the following:</p> <pre><code>stcd keys export dev0\nEnter passphrase to decrypt your key:\nEnter passphrase to encrypt the exported key:\n-----BEGIN TENDERMINT PRIVATE KEY-----\nkdf: bcrypt\nsalt: 14559BB13D881A86E0F4D3872B8B2C82\ntype: secp256k1\n\n# &lt;Tendermint private key&gt;\n-----END TENDERMINT PRIVATE KEY-----\n\n$ echo \"\\\n-----BEGIN TENDERMINT PRIVATE KEY-----\nkdf: bcrypt\nsalt: 14559BB13D881A86E0F4D3872B8B2C82\ntype: secp256k1\n\n# &lt;Tendermint private key&gt;\n-----END TENDERMINT PRIVATE KEY-----\" &gt; dev0.export\n</code></pre> <p> Ethereum-\u79c1\u9470\u683c\u5f0f </p> <p>:::tip Note: These types of keys are MetaMask-compatible. :::</p> <p>To backup this type of key without the mnemonic phrase, do the following:</p> <pre><code>stcd keys unsafe-export-eth-key dev0 &gt; dev0.export\n**WARNING** this is an unsafe way to export your unencrypted private key, are you sure? [y/N]: y\nEnter keyring passphrase:\n</code></pre>"},{"location":"protocol/#key-import","title":"Key Import","text":"<p> Tendermint-Private Key Format s</p> <pre><code>$ stcd keys import dev0-imported ./dev0.export\nEnter passphrase to decrypt your key:\n</code></pre> <p> Ethereum-Private Key Format </p> <pre><code>$ stcd keys unsafe-import-eth-key dev0-imported ./dev0.export\nEnter passphrase to encrypt your key:\n</code></pre>"},{"location":"protocol/#verify","title":"verify","text":"<p>Verify that your key has been restored using the following command:</p> <pre><code>$ stcd keys list\n[\n  {\n    \"name\": \"dev0-imported\",\n    \"type\": \"local\",\n    \"address\": \"dst1n253dl2tgyhxjm592p580c38r4dn8023ctv28d\",\n    \"pubkey\": '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"ArJhve4v5HkLm+F7ViASU/rAGx7YrwU4+XKV2MNJt+Cq\"}'\n  },\n  {\n    \"name\": \"dev0-restored\",\n    \"type\": \"local\",\n    \"address\": \"dst1n253dl2tgyhxjm592p580c38r4dn8023ctv28d\",\n    \"pubkey\": '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"ArJhve4v5HkLm+F7ViASU/rAGx7YrwU4+XKV2MNJt+Cq\"}'\n  },\n  {\n    \"name\": \"dev0\",\n    \"type\": \"local\",\n    \"address\": \"dst1n253dl2tgyhxjm592p580c38r4dn8023ctv28d\",\n    \"pubkey\": '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"ArJhve4v5HkLm+F7ViASU/rAGx7YrwU4+XKV2MNJt+Cq\"}'\n  }\n]\n</code></pre>"},{"location":"protocol/#importexport-status","title":"Import/Export Status","text":"<p>Daodst can dump the entire application state to a JSON file. This, besides upgrades, can be useful for manual analysis of the state at a given height.</p>"},{"location":"protocol/#export-status","title":"export status","text":"<p>Export state with:</p> <pre><code>stcd export &gt; new_genesis.json\n</code></pre> <p>You can also export state from a particular height (at the end of processing the block of that height):</p> <pre><code>stcd export --height [height] &gt; new_genesis.json\n</code></pre> <p>If you plan to start a new network for 0 height (i.e genesis) from the exported state, export with the <code>--for-zero-height</code> flag:</p> <pre><code>stcd export --height [height] --for-zero-height &gt; new_genesis.json\n</code></pre>"},{"location":"protocol/#manually-migrate-state","title":"Manually migrate state","text":"<p>If you want to migrate state manually, e.g. for local testing purpose. Note that for regular chain upgrades, a manual state migration is not required.</p> <p>After exporting your state into a json file, you can replace the old <code>genesis.json</code> with <code>new_genesis.json</code>.</p> <pre><code>cp -f genesis.json new_genesis.json\nmv new_genesis.json genesis.json\n</code></pre> <p>At this point, you might want to run a script to update the exported genesis into a genesis state that is compatible with your new version.</p> <p>You can use the <code>migrate</code> command to migrate from a given version to the next one (eg: <code>v0.X.X</code> to <code>v1.X.X</code>):</p> <pre><code>stcd migrate TARGET_VERSION GENESIS_FILE --chain-id=&lt;new_chain_id&gt; --genesis-time=&lt;yyyy-mm-ddThh:mm:ssZ&gt;\n</code></pre>"},{"location":"protocol/#multi-sig","title":"multi-sig","text":"<p>Learn how to generate, sign and broadcast a transaction using the keyring multisig.</p> <p>A multisig account is an Daodst account with a special key that can require more than one signature to sign transactions. This can be useful for increasing the security of the account or for requiring the consent of multiple parties to make transactions. Multisig accounts can be created by specifying:</p> <ul> <li>threshold number of signatures required</li> <li>the public keys involved in signing</li> </ul> <p>To sign with a multisig account, the transaction must be signed individually by the different keys specified for the account. Then, the signatures will be combined into a multi-signature which can be used to sign the transaction. If fewer than the threshold number of signatures needed are present, the resultant multi-signature is considered invalid.</p>"},{"location":"protocol/#generate-a-multi-signature-key-pair","title":"Generate a multi-signature key pair","text":"<pre><code>stcd keys add --multisig=name1,name2,name3[...] --multisig-threshold=K new_key_name\n</code></pre> <p><code>K</code> is the minimum number of private keys that must have signed the transactions that carry the public key's address as signer.</p> <p>The <code>--multisig</code> flag must contain the name of public keys that will be combined into a public key that will be generated and stored as <code>new_key_name</code> in the local database. All names supplied through <code>--multisig</code> must already exist  in the local database.</p> <p>Unless the flag <code>--nosort</code> is set, the order in which the keys are supplied on the command line does not matter, i.e. the  following commands generate two identical keys:</p> <pre><code>stcd keys add --multisig=p1,p2,p3 --multisig-threshold=2 multisig_address\nstcd keys add --multisig=p2,p3,p1 --multisig-threshold=2 multisig_address\n</code></pre> <p>Multisig addresses can also be generated on-the-fly and printed through the which command:</p> <pre><code>stcd keys show --multisig-threshold=K name1 name2 name3 [...]\n</code></pre>"},{"location":"protocol/#signature-transaction","title":"signature transaction","text":"<p> Step 1: Create a multi-signature key </p> <p>Let's assume that you have <code>test1</code> and <code>test2</code> want to make a multisig account with <code>test3</code>.</p> <p>First import the public keys of <code>test3</code> into your keyring.</p> <pre><code>stcd keys add \\\n    test3 \\\n    --pubkey=dstpub1addwnpepqgcxazmq6wgt2j4rdfumsfwla0zfk8e5sws3p3zg5dkm9007hmfysxas0u2\n</code></pre> <p>Generate the multisig key with 2/3 threshold.</p> <pre><code>stcd keys add \\\n    multi \\\n    --multisig=test1,test2,test3 \\\n    --multisig-threshold=2\n</code></pre> <p>You can see its address and details:</p> <pre><code>stcd keys show multi\n\n- name: multi\n  type: multi\n  address: dst1e0fx0q9meawrcq7fmma9x60gk35lpr4xk3884m\n  pubkey: dstpub1ytql0csgqgfzd666axrjzq3mxw59ys6yqcd3ydjvhgs0uzs6kdk5fp4t73gmkl8t6y02yfq7tvfzd666axrjzq3sd69kp5usk492x6nehqjal67ynv0nfqapzrzy3gmdk27la0kjfqfzd666axrjzq6utqt639ka2j3xkncgk65dup06t297ccljmxhvhu3rmk92u3afjuyz9dg9\n  mnemonic: \"\"\n  threshold: 0\n  pubkeys: []\n</code></pre> <p>Let's add 10 dst to the multisig wallet:</p> <pre><code>stcd tx bank send \\\n    test1 \\\n    dst1e0fx0q9meawrcq7fmma9x60gk35lpr4xk3884m \\\n    10000000000000000000dst \\\n    --chain-id=daodst_7000-4 \\\n    --gas=auto \\\n    --fees=1000000dst \\\n    --broadcast-mode=block\n</code></pre> <p> Step 2: Create a multi-signature transaction </p> <p>We want to send 5 Daodst from our multisig account to <code>dst1rgjxswhuxhcrhmyxlval0qa70vxwvqn2e0srft</code>.</p> <pre><code>stcd tx bank send \\\n    dst1rgjxswhuxhcrhmyxlval0qa70vxwvqn2e0srft \\\n    dst157g6rn6t6k5rl0dl57zha2wx72t633axqyvvwq \\\n    5000000000000000000dst \\\n    --gas=200000 \\\n    --fees=1000000dst \\\n    --chain-id=daodst_7000-4 \\\n    --generate-only &gt; unsignedTx.json\n</code></pre> <p>The file <code>unsignedTx.json</code> contains the unsigned transaction encoded in JSON.</p> <pre><code>{\n  \"body\": {\n    \"messages\": [\n      {\n        \"@type\": \"/cosmos.bank.v1beta1.MsgSend\",\n        \"from_address\": \"dst1rgjxswhuxhcrhmyxlval0qa70vxwvqn2e0srft\",\n        \"to_address\": \"dst157g6rn6t6k5rl0dl57zha2wx72t633axqyvvwq\",\n        \"amount\": [\n          {\n            \"denom\": \"dst\",\n            \"amount\": \"5000000000000000000\"\n          }\n        ]\n      }\n    ],\n    \"memo\": \"\",\n    \"timeout_height\": \"0\",\n    \"extension_options\": [],\n    \"non_critical_extension_options\": []\n  },\n  \"auth_info\": {\n    \"signer_infos\": [],\n    \"fee\": {\n      \"amount\": [\n        {\n          \"denom\": \"dst\",\n          \"amount\": \"1000000\"\n        }\n      ],\n      \"gas_limit\": \"200000\",\n      \"payer\": \"\",\n      \"granter\": \"\"\n    }\n  },\n  \"signatures\": []\n}\n</code></pre> <p> Step 3: signed separately </p> <p>Sign with <code>test1</code> and <code>test2</code> and create individual signatures.</p> <pre><code>stcd tx sign \\\n    unsignedTx.json \\\n    --multisig=dst1e0fx0q9meawrcq7fmma9x60gk35lpr4xk3884m \\\n    --from=test1 \\\n    --output-document=test1sig.json \\\n    --chain-id=daodst_7000-4\n</code></pre> <pre><code>stcd tx sign \\\n    unsignedTx.json \\\n    --multisig=dst1e0fx0q9meawrcq7fmma9x60gk35lpr4xk3884m \\\n    --from=test2 \\\n    --output-document=test2sig.json \\\n    --chain-id=daodst_7000-4\n</code></pre> <p> Step 4: Create a multi-signature </p> <p>Combine signatures to sign transaction.</p> <pre><code>stcd tx multisign \\\n    unsignedTx.json \\\n    multi \\\n    test1sig.json test2sig.json \\\n    --output-document=signedTx.json \\\n    --chain-id=daodst_7000-4\n</code></pre> <p>The TX is now signed:</p> <pre><code>{\n  \"body\": {\n    \"messages\": [\n      {\n        \"@type\": \"/cosmos.bank.v1beta1.MsgSend\",\n        \"from_address\": \"dst1rgjxswhuxhcrhmyxlval0qa70vxwvqn2e0srft\",\n        \"to_address\": \"dst157g6rn6t6k5rl0dl57zha2wx72t633axqyvvwq\",\n        \"amount\": [\n          {\n            \"denom\": \"dst\",\n            \"amount\": \"5000000000000000000\"\n          }\n        ]\n      }\n    ],\n    \"memo\": \"\",\n    \"timeout_height\": \"0\",\n    \"extension_options\": [],\n    \"non_critical_extension_options\": []\n  },\n  \"auth_info\": {\n    \"signer_infos\": [\n      {\n        \"public_key\": {\n          \"@type\": \"/cosmos.crypto.multisig.LegacyAminoPubKey\",\n          \"threshold\": 2,\n          \"public_keys\": [\n            {\n              \"@type\": \"/cosmos.crypto.secp256k1.PubKey\",\n              \"key\": \"ApCzSG8k7Tr4aM6e4OJRExN7cNtvH21L9azbh+uRrvt4\"\n            },\n            {\n              \"@type\": \"/cosmos.crypto.secp256k1.PubKey\",\n              \"key\": \"Ah91erz8ChNanqLe9ea948rvAiXMCRlR5Ka7EE/c0xUK\"\n            },\n            {\n              \"@type\": \"/cosmos.crypto.secp256k1.PubKey\",\n              \"key\": \"A0OjtIUCFJM3AobJ9HJTWKP9RZV2+WPcwVjLgsAidrZ/\"\n            }\n          ]\n        },\n        \"mode_info\": {\n          \"multi\": {\n            \"bitarray\": {\n              \"extra_bits_stored\": 3,\n              \"elems\": \"wA==\"\n            },\n            \"mode_infos\": [\n              {\n                \"single\": {\n                  \"mode\": \"SIGN_MODE_LEGACY_AMINO_JSON\"\n                }\n              },\n              {\n                \"single\": {\n                  \"mode\": \"SIGN_MODE_LEGACY_AMINO_JSON\"\n                }\n              }\n            ]\n          }\n        },\n        \"sequence\": \"1\"\n      }\n    ],\n    \"fee\": {\n      \"amount\": [\n        {\n          \"denom\": \"dst\",\n          \"amount\": \"1000000\"\n        }\n      ],\n      \"gas_limit\": \"200000\",\n      \"payer\": \"\",\n      \"granter\": \"\"\n    }\n  },\n  \"signatures\": [\n    \"CkCEeIbeGc+I1ipZuhp/0KhVNnWAv2tTlvgo5x61lzk1KHmLPV38m/YFurrFt5cm5+fqIXrn+FlOjrJuzBhw8ogYCkCawm9mpXsBHk0CFsE5618fVnvScEkfrzW0c2jCcjqV8EPuj3ut74UWzZyQkwtJGxUWtro9EgnGsB7Di1Gzizst\"\n  ]\n}\n</code></pre> <p> Step 5: broadcast transaction </p> <pre><code>stcd tx broadcast signedTx.json \\\n    --chain-id=daodst_7000-4 \\\n    --broadcast-mode=block\n</code></pre>"},{"location":"protocol/#pending-status","title":"Pending status","text":"<p>When a transaction is submitted to the Ethereum network, it first enters the pending state, waiting for the node to execute it.</p> <p>If the gas price in a transaction is set very low and the node is busy processing other transactions with higher gas prices, the transaction may remain pending for a longer period of time.</p> <p>During the pending state, transaction initiators are allowed to change transaction fields at any time.</p> <p>They can do this by sending another transaction with the same nonce.</p> <p> Prerequisite Reading </p> <ul> <li>Cosmos SDK Mempool</li> </ul> <p> Daodst vs. Ethereum </p> <p>In Ethereum, pending blocks are generated when miners are queued for production.</p> <p>These pending blocks consist of pending transactions picked by miners based on the highest gas reward paid.</p> <p>This mechanism exists because block finality is not possible on the Ethereum network.</p> <p>Blocks are committed with probabilistic determinism, meaning that over time (and blocks) transactions and blocks become less likely to be reverted.</p> <p>Daodst is designed completely differently in this regard, as there is no concept of a \"pending state\".</p> <p>Daodst uses Tendermint Core BFT consensus to provide instant finality for transactions.</p> <p>For this reason, Ethermint does not need to suspend the state mechanism, since all (if not most) transactions will be committed to the next block (the average block time on the Cosmos chain is about 8 seconds).</p> <p>However, this causes problems with some Ethereum Web3 compatible queries, which may enter a pending state.</p> <p>Another notable difference from Ethereum is that blocks are generated by validators, or block producers, who include transactions from their local mempool into blocks in a first-in-first-out (FIFO) fashion.</p> <p>Transactions on Daodst cannot be ordered or picked from the Tendermint node mempool.</p> <p> Pending state queue </p> <p>Daodst will make queries to account for any unconfirmed transactions that exist in the node's transaction mempool.</p> <p>Pending state queries made will be subjective and will be queried on the mempool of the target node.</p> <p>So for the same query on two different nodes, the pending status will not be the same.</p> <p> JSON-RPC Calls on Pending Transactions </p> <ul> <li><code>eth_getBalance</code></li> <li><code>eth_getTransactionCount</code></li> <li><code>eth_getBlockTransactionCountByNumber</code></li> <li><code>eth_getBlockByNumber</code></li> <li><code>eth_getTransactionByHash</code></li> <li><code>eth_getTransactionByBlockNumberAndIndex</code></li> <li><code>eth_sendTransaction</code></li> </ul>"},{"location":"protocol/#token","title":"Token","text":""},{"location":"protocol/#daodst-token","title":"Daodst Token","text":"<p>The denomination used for staking, governance, and gas consumption on the EVM is Daodst. Daodst provides the following utilities: securing proof-of-stake chains, tokens for governance proposals, distributing fees to validators and users, and as fuel for running smart contracts on the EVM.</p> <p>Daodst uses Atto Daodst as the base denomination to maintain parity with Ethereum. Assets are divided into three categories:</p> <p>This matches the denomination of Ethereum:</p> <p><code>1 ETH = 10&lt;sup&gt;18&lt;/sup&gt; wei</code></p>"},{"location":"protocol/#cosmos-tokens","title":"Cosmos Tokens","text":"<p>Accounts can have Cosmos coins in their balances, which are used for operations and transactions with other Cosmos. Examples of these include staking with tokens, IBC transfers, governance deposits, and EVM.</p>"},{"location":"protocol/#evm-token","title":"EVM Token","text":"<p>Daodst is compatible with ERC20 tokens and other non-fungible token standards natively supported by EVM (EIP721, EIP1155).</p> <p> Daodst asset page </p> <p>See how we represent ERC-20 tokens and Cosmos IBC coins through our Single Token Representation Features on the Daodst Dashboard.</p> <p>Daodst enables this feature to help improve user experience by obfuscating asset types away from the user and allowing them to focus on the interaction.</p> <p>The protocol simplifies the process by handling conversions and provides users with simplified denominations and the amount of assets they hold.</p> <p>More information on how we handle token registration can be found here.</p>"},{"location":"protocol/#trade","title":"trade","text":"<p>A transaction is an action initiated by an account that changes the state of the blockchain.</p> <p>In order to perform state changes efficiently, each transaction is broadcast to the entire network.</p> <p>Any node can broadcast requests for transactions to be executed on the blockchain state machine;</p> <p>Once this happens, validators will validate, execute the transaction, and propagate the resulting state change to the rest of the network.</p> <p>To process each transaction, computing resources on the network are consumed.</p> <p>Thus, the concept of \"gas\" emerged as a reference to the computation required by a validator to process a transaction.</p> <p>Users have to pay for this computation, and all transactions have an associated fee.</p> <p>The fee is calculated based on the gas and gas price required to execute the transaction.</p> <p>Additionally, transactions need to be signed with the sender's private key.</p> <p>This proves that transactions can only come from the sender and not sent fraudulently.</p> <p>In short, the transaction life cycle after submitting a signed transaction to the network is as follows:</p> <ul> <li>Transaction hashes are cryptographically generated.</li> <li>The transaction is broadcast to the network and added to the pool of all other pending network transactions.</li> <li>A validator has to pick your transaction and include it in a block in order to validate the transaction and consider it \"successful\".</li> </ul> <p>For a more detailed explanation of the transaction lifecycle, see the corresponding section.</p> <p>A transaction hash is a unique identifier that can be used to check transaction information, for example, whether the emitted event was successful.</p> <p>Transactions can fail for various reasons.</p> <p>For example, the gas or fee provided may not be sufficient.</p> <p>Additionally, transaction validation may fail.</p> <p>Each transaction has specific conditions that must be met in order to be considered valid.</p> <p>A broad verification is that the sender is the transaction signer.</p> <p>In this case, if you send the transaction where the sender's address is different from the signer's address, the transaction will fail even if the fee is sufficient.</p> <p>Today, transactions can not only make state transitions on the chain they were committed to, but they can also be transacted on another blockchain.</p> <p>Inter-chain transactions can be implemented through the Inter-Blockchain Communication Protocol (IBC).</p> <p>Find a more detailed explanation in the sections below.</p>"},{"location":"protocol/#transaction-type","title":"Transaction Type","text":"<p>Daodst supports two transaction types:</p> <ol> <li>Cosmos transactions</li> <li>Ethereum transactions</li> </ol> <p>This is possible because Daodst uses the Cosmos-SDK and implements the Ethereum Virtual Machine as a module.</p> <p>In this way, Daodst provides the combined features and functionality of Ethereum and Cosmos chains, among other things.</p> <p>Although most of the information contained in these two transaction types is similar, there are differences between them.</p> <p>An important difference is that Cosmos transactions allow multiple messages to be sent in the same transaction.</p> <p>In contrast, Ethereum transactions do not have this possibility.</p> <p>To bring these two types together, Daodst implements Ethereum transactions as a single <code>sdk.Msg</code> Included in <code>auth.StdTx</code>.</p> <p>This message contains all relevant Ethereum transaction information.</p> <p>This includes signatures, gases, payloads, etc.</p> <p>Find out more about both types in the following sections.</p>"},{"location":"protocol/#cosmos-trade","title":"Cosmos trade","text":"<p>On Cosmos chains, transactions are comprised of metadata held in contexts and <code>sdk.Msg</code>s that trigger state changes within a module through the module's Protobuf Msg service.</p> <p>When users want to interact with an application and make state changes (e.g. sending coins), they create transactions. Cosmos transactions can have multiple <code>sdk.Msg</code>s. Each of these must be signed using the private key associated with the appropriate account(s), before the transaction is broadcasted to the network.</p> <p>A Cosmos transaction includes the following information:</p> <ul> <li><code>Msgs</code>: an array of msgs (<code>sdk.Msg</code>)</li> <li><code>GasLimit</code>: option chosen by the users for how to calculate how much gas they will need to pay</li> <li><code>FeeAmount</code>: max amount user is willing to pay in fees</li> <li><code>TimeoutHeight</code>: block height until which the transaction is valid</li> <li><code>Signatures</code>: array of signatures from all signers of the tx</li> <li><code>Memo</code>: a note or comment to send with the transaction</li> </ul> <p>To submit a Cosmos transaction, users must use one of the provided clients.</p>"},{"location":"protocol/#ethereum-trade","title":"Ethereum trade","text":"<p>Ethereum transactions refer to actions initiated by EOAs (externally-owned accounts, managed by humans), rather than internal smart contract calls. Ethereum transactions transform the state of the EVM and therefore must be broadcasted to the entire network.</p> <p>Ethereum transactions also require a fee, known as <code>gas</code>. (EIP-1559) introduced the idea of a base fee, along with a priority fee which serves as an incentive for miners to include specific transactions in blocks.</p> <p>There are several categories of Ethereum transactions:</p> <ul> <li>regular transactions: transactions from one account to another</li> <li>contract deployment transactions: transactions without a <code>to</code> address, where the contract code is sent in the <code>data</code> field</li> <li>execution of a contract: transactions that interact with a deployed smart contract,   where the <code>to</code> address is the smart contract address</li> </ul> <p>An Ethereum transaction includes the following information:</p> <ul> <li><code>recipient</code>: receiving address</li> <li><code>signature</code>: sender's signature</li> <li><code>nonce</code>: counter of tx number from account</li> <li><code>value</code>: amount of ETH to transfer (in wei)</li> <li><code>data</code>: include arbitrary data. Used when deploying a smart contract or making a smart contract method call</li> <li><code>gasLimit</code>: max amount of gas to be consumed</li> <li><code>maxPriorityFeePerGas</code>: mas gas to be included as tip to validators</li> <li><code>maxFeePerGas</code>: max amount of gas to be paid for tx</li> </ul> <p>For more information on Ethereum transactions and the transaction lifecycle, go here.</p> <p>Daodst supports the following Ethereum transactions.</p> <p>:::tip Note: Unprotected legacy transactions are not supported by default. :::</p> <ul> <li>Dynamic Fee Transactions (EIP-1559)</li> <li>Access List Transactions (EIP-2930)</li> <li>Legacy Transactions (EIP-2718)</li> </ul> <p>Daodst is capable of processing Ethereum transactions by wrapping them on a <code>sdk.Msg</code>. Daodst achieves this by using the <code>MsgEthereumTx</code>. This message encapsulates an Ethereum transaction as an SDK message and contains the necessary transaction data fields.</p> <p>One remark about the <code>MsgEthereumTx</code> is that it implements both the <code>sdk.Msg</code> and <code>sdk.Tx</code> interfaces (generally SDK messages only implement the former, while the latter is a group of messages bundled together). The reason of this, is because the <code>MsgEthereumTx</code> must not be included in a <code>auth.StdTx</code> (SDK's standard transaction type) as it performs gas and fee checks using the Ethereum logic from Geth instead of the Cosmos SDK checks done on the auth module <code>AnteHandler</code>.</p>"},{"location":"protocol/#interchain-transaction","title":"Interchain transaction","text":"<p>Interchain transactions refer to the transfer of digital assets or data between two or more different blockchain networks.</p> <p>Each blockchain network has its own unique protocol and data structure, making it difficult to directly transfer assets or data from one blockchain to another. Interchain transactions allow for the transfer of assets and data between different blockchains by using intermediary mechanisms or protocols.</p> <p>One such mechanism is a cross-chain bridge, which acts as a connector between different blockchains, enabling the transfer of assets or data. Cross-chain bridges typically require some form of trust or consensus mechanism to ensure the security and integrity of the transaction.</p> <p>Another possibility is to use the IBC (Inter-Blockchain Communication) protocol. To make an interchain transaction using IBC a user needs to:</p> <ul> <li>Choose the source and destination blockchain networks that the user wants to transfer assets or data between.</li> <li>Ensure that both blockchain networks have implemented the IBC protocol</li> <li>Ensure there's a connection and channel established between the two blockchain networks using IBC</li> <li>Initiate the transfer of assets or data: this is done by sending a transaction from the source blockchain   to the destination blockchain through the IBC channel</li> </ul> <p>Interchain transactions are becoming increasingly important as the number of different blockchain networks and applications continues to grow. They enable the interoperability of different blockchain networks, allowing for greater flexibility and efficiency in the transfer of digital assets and data.</p>"},{"location":"protocol/#transaction-certificate","title":"transaction certificate","text":"<p>A transaction receipt shows data returned by an Ethereum client to represent the result of a particular transaction, including a hash of the transaction, its block number, the amount of gas used, and, in case of deployment of a smart contract, the address of the contract. Additionally, it includes custom information from the events emitted in the smart contract.</p> <p>A receipt contains the following information:</p> <ul> <li><code>transactionHash</code> : hash of the transaction.</li> <li><code>transactionIndex</code>: integer of the transactions index position in the block.</li> <li><code>blockHash</code>: hash of the block where this transaction was in.</li> <li><code>blockNumber</code>: block number where this transaction was in.</li> <li><code>from</code>: address of the sender.</li> <li><code>to</code>: address of the receiver. null when its a contract creation transaction.</li> <li><code>cumulativeGasUsed</code> : The total amount of gas used when this transaction was executed in the block.</li> <li><code>effectiveGasPrice</code> : The sum of the base fee and tip paid per unit of gas.</li> <li><code>gasUsed</code> : The amount of gas used by this specific transaction alone.</li> <li><code>contractAddress</code> : The contract address created, if the transaction was a contract creation, otherwise null.</li> <li><code>logs</code>: Array of log objects, which this transaction generated.</li> <li><code>logsBloom</code>: Bloom filter for light clients to quickly retrieve related logs.</li> <li><code>type</code>: integer of the transaction type, 0x00 for legacy transactions, 0x01 for access list types,   0x02 for dynamic fees. It also returns either.</li> <li><code>root</code> : transaction stateroot (pre Byzantium)</li> <li><code>status</code>: either 1 (success) or 0 (failure)</li> </ul>"},{"location":"validator/","title":"Overview","text":""},{"location":"validator/#setup-and-configuration","title":"Setup and configuration","text":""},{"location":"validator/#run-validator","title":"Run validator","text":""},{"location":"validator/#configuration","title":"configuration","text":""},{"location":"validator/#hdd-usage-optimization","title":"HDD usage optimization","text":""},{"location":"validator/#state-synchronization","title":"State Synchronization","text":""},{"location":"validator/#memory-pool","title":"memory pool","text":""},{"location":"validator/#validator-faq","title":"Validator FAQ","text":""},{"location":"validator/#authenticator-security","title":"Authenticator Security","text":""},{"location":"validator/#sentinel-node-ddos-protected","title":"Sentinel Node (DDOS Protected)","text":""},{"location":"validator/#key-backup","title":"Key backup","text":""},{"location":"validator/#upgrade","title":"upgrade","text":""},{"location":"validator/#upgrade-checklist","title":"Upgrade Checklist","text":""},{"location":"validator/#hard-fork-upgrade","title":"Hard Fork Upgrade","text":""},{"location":"validator/#manual-upgrade","title":"Manual upgrade","text":""},{"location":"validator/#testnet","title":"Testnet","text":""},{"location":"validator/#mainnet","title":"Mainnet","text":""},{"location":"chat/chat_doc/","title":"Service Documentation","text":""},{"location":"chat/chat_doc/#overview","title":"Overview","text":"<p>The chat service is a chat service developed based on the matrix protocol, which supports encrypted communication based on rooms and events. At the same time, it supports federated cross-service node communication and point-to-point audio and video calls based on webrtc.</p> <p>Communication across service nodes</p> <pre><code>    { Matrix client A }                             { Matrix client B }\n        ^          |                                    ^          |\n        |  events  |  Client-Server API                 |  events  |\n        |          V                                    |          V\n    +------------------+                            +------------------+\n    |                  |---------( HTTP )---------&gt; |                  |\n    |   homeserver     |                            |   homeserver     |\n    |                  |&lt;--------( HTTP )---------- |                  |\n    +------------------+      Server-Server API     +------------------+\n                          History Synchronisation\n                              (Federation)\n</code></pre>"},{"location":"chat/chat_doc/#basic-concepts","title":"Basic Concepts","text":""},{"location":"chat/chat_doc/#servername-virtual-domain-name","title":"Servername (virtual domain name)","text":"<p>servername is the virtual domain name (domain) of the chat service, and together with the user's wallet address constitutes the user ID</p>"},{"location":"chat/chat_doc/#users","title":"Users","text":"<p>Each client is associated with an account, which is used as the unique identification of the chat system, that is, userID. This account is associated with the homeserver to form a space-separated account, which looks like:</p> <pre><code>@localpart:domain\n</code></pre>"},{"location":"chat/chat_doc/#devices","title":"Devices","text":"<p>The concept of a device is defined in the chat system, which can be a desktop client, some browsers, an Android device or an iPhone, etc. (currently only Android devices are open). A chat system device is associated with a real physical device or mobile application.</p> <p>The device is mainly used to manage the key used for end-to-end encryption (each device can get its own copy of the decryption key), and at the same time provide assistance when other devices with the same account are connected.</p> <p>When a user uses the client for the first time, the client registers itself as a new device. Different devices are identified by device ID (device_id), which is unique to each user. Users can define a human-readable device name for the device, which is used for them to manage the device.</p>"},{"location":"chat/chat_doc/#events","title":"Events","text":"<p>All data exchange in the chat is based on event events. Client behavior is defined through events, and each event has a type attribute to distinguish data types. Each event type must be globally unique, Follow the naming rules of the Java namespace, for example, m.room.message represents the message event in the room.</p>"},{"location":"chat/chat_doc/#event-graphs","title":"Event Graphs","text":"<p>All event data exchanges in the room are stored in a directed acyclic graph called Event Graphs. Each event in the graph is arranged in chronological order.</p> <p>Typically, an event has only one parent: the latest message in the room at the time the message was sent. However, homeservers may legitimately race with each other in sending messages, resulting in multiple successors to a single event. Therefore, the next event added to the graph will have multiple parents. Every event graph has a root event with no parent event.</p> <p>To sort and simplify chronological comparisons between events in the graph, the home server maintains a deep metadata field on each event. An event's depth is a positive integer strictly greater than the depth of any of its parent events. Root events should have a depth of 1. Therefore, if one event precedes another, its depth must be strictly less than 1.</p>"},{"location":"chat/chat_doc/#room-structure","title":"Room structure","text":"<p>A room is a conceptual place where users can send and receive events. Events are sent to a room where all participants with sufficient access will receive the event. Rooms are uniquely identified internally by a \"room ID\", which has the following form:</p> <pre><code>!room_id:domain # room_id: a 16-bit random string\n</code></pre> <p>Each room has only one room ID. While room IDs do contain domains, it is only used for global namespace room IDs. The room is not in the specified domain.</p> <p>The conceptual diagram below shows an m.room.message event being sent to room !qporfwt:matrix.org:</p> <pre><code>\n    { @alice:matrix.org }                             { @bob:example.org }\n            |                                                 ^\n            |                                                 |\n    [HTTP POST]                                  [HTTP GET]\n    Room ID: !qporfwt:matrix.org                 Room ID: !qporfwt:matrix.org\n    Event type: m.room.message                   Event type: m.room.message\n    Content: { JSON object }                     Content: { JSON object }\n            |                                                 |\n            V                                                 |\n    +------------------+                          +------------------+\n    |   homeserver     |                          |   homeserver     |\n    |   matrix.org     |                          |   example.org    |\n    +------------------+                          +------------------+\n            |                                                 ^\n            |         [HTTP PUT]                              |\n            |         Room ID: !qporfwt:matrix.org            |\n            |         Event type: m.room.message              |\n            |         Content: { JSON object }                |\n            `-------&gt; Pointer to the preceding message  ------`\n                      PKI signature from matrix.org\n                      Transaction-layer metadata\n                      PKI Authorization header\n\n                  ....................................\n                 |           Shared Data              |\n                 | State:                             |\n                 |   Room ID: !qporfwt:matrix.org     |\n                 |   Servers: matrix.org, example.org |\n                 |   Members:                         |\n                 |    - @alice:matrix.org             |\n                 |    - @bob:example.org              |\n                 | Messages:                          |\n                 |   - @alice:matrix.org              |\n                 |     Content: { JSON object }       |\n                 |....................................|\n\n</code></pre> <p>The federation mechanism maintains a shared data structure for each room among multiple homeservers. The data is divided into message events and status events.</p> <p>Messaging Events: These describe transient \"one-off\" activity within the room, such as instant messages, VoIP call setup, file transfers, etc. They generally describe communication activities.</p> <p>State Events: These describe updates to a given persistent information (\"state\") associated with a room, such as the room's name, subject, membership, participating servers, etc. The state is modeled as a lookup table of key/value pairs per room, where each key is a tuple of state_key and the event type. Each state event updates the value for the given key.</p> <p>The room state at a given point is computed by considering all events in the graph preceding and including the given event. In cases where events describe the same state, the merge conflict algorithm is applied. The state resolution algorithm is transitive and does not depend on server state, since it must always select the same event, regardless of the server or the order in which the events were received. Events are signed by the origin server (signature includes parent, type, depth and payload hash) and pushed to participating servers in the room via federation, currently using a full mesh topology. Servers can also request backfill events from other servers participating in the room through federation.</p>"},{"location":"chat/chat_doc/#room-aliases","title":"Room Aliases","text":"<p>Each room can also have multiple \"room aliases\", as follows:</p> <pre><code>   #room_alias:domain\n</code></pre> <p>The room alias \"points to\" the room ID, which is the human-readable label used to advertise and discover the room. The room ID pointed to by the alias can be obtained by accessing the specified domain. Note that the mapping from room aliases to room IDs is not fixed and may change over time to point to different room IDs. Therefore, clients should resolve the room alias to a room ID once, and then use that ID in subsequent requests.</p> <p>When resolving a room alias, the server will also respond with a list of servers in the room that are available to join.</p> <pre><code>    HTTP GET\n    #matrix:example.org      !aaabaa:matrix.org\n       |                    ^\n       |                    |\n    _______V____________________|____\n    |          example.org           |\n    | Mappings:                      |\n    | #matrix &gt;&gt; !aaabaa:matrix.org  |\n    | #golf   &gt;&gt; !wfeiofh:sport.com  |\n    | #bike   &gt;&gt; !4rguxf:matrix.org  |\n    |________________________________|\n</code></pre>"},{"location":"chat/chat_doc/#identity","title":"Identity","text":"<p>Users in Matrix are identified by their Matrix User ID. However, it is also possible to use existing 3rd party ID namespaces to identify Matrix users. The matrix \"identity\" describes the user ID and any other existing IDs in the third-party namespace linked to their account. Matrix users can link third-party IDs (3PIDs) such as email addresses, social networking accounts, and phone numbers to their user IDs. Linking 3PIDs creates a mapping from 3PIDs to user IDs. Matrix users can then use this map to discover the user IDs of their contacts. To ensure that the mapping from 3PIDs to user IDs is authentic, a globally federated cluster of trusted \"Identity Servers\" (ISs) is used to verify the 3PIDs and to save and replicate the mappings.</p> <p>In order for a client application to be part of the Matrix ecosystem, the use of IS is not required. However, without a client there will be no way to use 3PID to look up the user ID.</p>"},{"location":"chat/chat_doc/#private-user-data","title":"Private User Data","text":"<p>Users can also store arbitrary private key/value data in their accounts -- such as client preferences or server configuration settings lacking any other dedicated APIs. The API is symmetric with the management profile data.</p>"},{"location":"chat/customise_doc/","title":"Service customization","text":""},{"location":"chat/customise_doc/#overview","title":"Overview","text":"<p>Based on the matrix protocol, we have done some customization work to adapt to the cosmos ecology. Including customized cosmos signature verification login, and a series of chat restrictions increase.</p>"},{"location":"chat/customise_doc/#cosmos-signature-verification-login","title":"Cosmos signature verification login","text":"<p>Add com.xs.cosmos_sign_auth login type on the basis of the original login API, and realize automatic registration if the user is not registered when logging in. The process is as follows:</p> <pre><code>     1. Verify signature\n     2. Determine whether the signature is consistent with the public key export address\n     3. Determine whether the user exists\n     4. If 3, it is judged that it does not exist, automatically register the user to the chat system\n</code></pre>"},{"location":"chat/customise_doc/#space-limits","title":"Space Limits","text":"<pre><code>Usage Quota Calculation Method\n\nMedal level, each level increases the bonus by 3%, and level 33 can get a maximum bonus of 100%\n\nUser base = remaining disk used by the node / number of users who have uploaded today on the node / data cleaning cycle / 2\n\nUser bonus amount = user base amount x medal level increase\n\nRoll over the oldest file when the quota is insufficient\n\n\n++++++++++ Example: ++++++++++++++\n\nThe remaining disk available for the node is 100G, the data cleaning cycle is 3 days, and the number of daily active users on the node today is 500\n\n100G / 500 / 3 /2 = 35M (base storage capacity of node users)\n\nUser A's medal level is level 10, and the bonus ratio is 9%\n\n35M x (1 + 0.09) = 38.15M (the actual storage capacity after medal bonus)\n</code></pre>"},{"location":"chat/customise_doc/#bandwidth-limit","title":"Bandwidth limit","text":""},{"location":"chat/customise_doc/#public-room-limit","title":"Public room limit","text":"<p>Users are not allowed to create public rooms before level 5, and after level 5, each level increases the permission to create a public room</p>"},{"location":"chat/customise_doc/#tourist-mode","title":"Tourist Mode","text":"<p>Tourist mode is different from official users. Tourist representatives only register in the chat service, but users who have not registered on the chain for pledge, tourists are not allowed to send messages when they have not pledged enough.</p>"},{"location":"chat/faq/","title":"common problem","text":""},{"location":"chat/installation/","title":"Install start","text":""},{"location":"chat/installation/#install","title":"Install","text":""},{"location":"chat/installation/#windows-installation","title":"Windows Installation","text":"<p>It can be installed with the PC program</p>"},{"location":"chat/installation/#linux-installation","title":"Linux installation","text":"<p>Unzip chat_linux.tar.gz to the current folder, a chat/ directory will be generated, including the startup program (completed by the script)</p>"},{"location":"chat/installation/#configuration","title":"Configuration","text":""},{"location":"chat/installation/#configuration-file","title":"configuration file","text":"<ul> <li>matrix_key.pem: server key file</li> <li>dendrite.yaml: service startup configuration file</li> </ul>"},{"location":"chat/installation/#configuration-file-initialization","title":"Configuration file initialization","text":"<p>Generated automatically when the gateway program starts</p>"},{"location":"chat/installation/#start-up","title":"start up","text":""},{"location":"chat/installation/#start-preconditions","title":"Start preconditions","text":"<ul> <li>registered gateway</li> <li>A number segment has been set for this gateway</li> </ul>"},{"location":"chat/installation/#start-command","title":"start command","text":""},{"location":"chat/installation/#notice","title":"Notice","text":"<p>The following commands are all executed by the gateway program without manual calls</p>"},{"location":"chat/installation/#windows","title":"windows","text":"<pre><code>dendrite-monolith-server.exe -public-ip XXX.XXX.XXX.XXX\n</code></pre>"},{"location":"chat/installation/#linux","title":"Linux","text":"<pre><code>dendrite-monolith-server-public-ip XXX.XXX.XXX.XXX\n</code></pre>"},{"location":"chat/optional_cfg/","title":"Optional","text":""},{"location":"chat/optional_cfg/#bandwidth-sharing-node-pool-configuration","title":"Bandwidth sharing node pool configuration","text":"<p>The bandwidth sharing requirement is designed to allow node owners to form an alliance, communicate the turn transfer service internally, and modify the configuration file so that users can use the turn service across nodes. To achieve the purpose of sharing bandwidth during audio and video communication.</p>"},{"location":"chat/optional_cfg/#configuration-changes","title":"Configuration changes","text":"<p>When generating the configuration file, the current node information is added to the trusted_servers configuration item by default. as follows:</p> <pre><code>\n  turn:\n    turn_user_lifetime: \"1m\"\n    turn_uris: [\"turn:192.168.10.242:3478?transport=udp\"]\n    turn_shared_secret: \"\"\n    turn_username: \"test\"\n    turn_password: \"pwd_test\"\n    trusted_servers:\n      - servername: self   # Any name\n        host: 192.168.3.32  # Server public IP\n        bandwidth: 100  # Server network bandwidth (unit: M)\n        turn_uris: [\"turn:192.168.3.32:3478?transport=udp\"]\n        salt_str: salt_str_here # Salt string used for interface parameter signature\n\n</code></pre>"},{"location":"chat/optional_cfg/#share-configuration","title":"Share configuration","text":"<p>When the node owner reaches a shared bandwidth consensus in private, he only needs to configure the first trusted_server under the trusted_servers configuration item of his node, that is, the The configuration is sent to each other, and then the other party appends the received configuration to trusted_servers and restarts the service. The example is as follows:</p> <pre><code>\nturn:\n  turn_user_lifetime: \"1m\"\n  turn_uris: [\"turn:192.168.10.242:3478?transport=udp\"]\n  turn_shared_secret: \"\"\n  turn_username: \"test\"\n  turn_password: \"pwd_test\"\n  trusted_servers:\n    - servername: self # The trusted_server configuration of your own node, the name is taken by yourself\n      host: 192.168.3.32 # server public network IP\n      bandwidth: 100 # server network bandwidth (unit M), this configuration is temporarily useless\n      turn_uris: [\"turn:192.168.3.32:3478?transport=udp\"]\n      salt_str: salt_str_here # Salt string used for interface parameter signature\n\n    - servername: other1 # The trusted_server configuration of the other node, the name is taken by yourself\n      host: 192.168.3.30 # server public network IP\n      bandwidth: 50 # server network bandwidth (unit M), this configuration is temporarily useless\n      turn_uris: [\"turn:192.168.3.30:3478?transport=udp\"]\n      salt_str: other_salt_str_here # Salt string used for interface parameter signature\n\n</code></pre>"},{"location":"chat/optional_cfg/#notice","title":"Notice","text":"<pre><code>     When the file storage cleanup time period configuration of this node is modified, the chat service configuration file will be regenerated.\n     This means that the shared bandwidth configuration here will be invalid, so it needs to be reconfigured\n</code></pre>"},{"location":"chat/prometheus_doc/","title":"Prometheus status monitoring","text":"<pre><code>    # HELP dendrite_caching_ristretto_cost *ristretto cache consumption\n\n    # TYPE dendrite_caching_ristretto_cost gauge\n\n    dendrite_caching_ristretto_cost 0\n\n  # HELP dendrite_caching_ristretto_ratio\n\n  # TYPE dendrite_caching_ristretto_ratio gauge\n\n    dendrite_caching_ristretto_ratio 0\n\n  # HELP dendrite_clientapi_reg_users_total Total number of registered users Total number of registered users\n\n  # TYPE dendrite_clientapi_reg_users_total counter\n\n    dendrite_clientapi_reg_users_total 0\n\n  # HELP dendrite_federationapi_destination_queues_backing_off The number of cross-node event sending\n\n  # TYPE dendrite_federationapi_destination_queues_backing_off gauge\n\n    dendrite_federationapi_destination_queues_backing_off 0\n\n  # HELP dendrite_federationapi_destination_queues_running The number of cross-node event processing\n\n  # TYPE dendrite_federationapi_destination_queues_running gauge\n\n    dendrite_federationapi_destination_queues_running 0\n\n  # HELP dendrite_federationapi_destination_queues_total total number of cross-node events\n\n  # TYPE dendrite_federationapi_destination_queues_total gauge\n\n    dendrite_federationapi_destination_queues_total 0\n\n  # HELP dendrite_federationapi_recv_edus Number of incoming EDUs from remote servers The number of cross-node events received from remote servers\n\n  # TYPE dendrite_federationapi_recv_edus counter\n\n    dendrite_federationapi_recv_edus 0\n\n  # HELP dendrite_syncapi_active_sync_requests The number of sync requests that are active right now The number of sync requests that are active right now\n\n  # TYPE dendrite_syncapi_active_sync_requests gauge\n\n    dendrite_syncapi_active_sync_requests 0\n\n  # HELP dendrite_syncapi_waiting_sync_requests The number of sync requests that are waiting to be woken by a notifier\n\n  # TYPE dendrite_syncapi_waiting_sync_requests gauge\n\n    dendrite_syncapi_waiting_sync_requests 0\n\n  # HELP dendrite_user_online_num_requests_total Total number of internal API calls Total number of internal API calls\n\n  # TYPE dendrite_user_online_num_requests_total counter\n\n    dendrite_user_online_num_requests_total{code=\"200\"} 1214\n\n    # HELP dendrite_user_online_num_response_size_bytes A histogram of response sizes for requests. The historical return data size of user online number requests\n\n    # TYPE dendrite_user_online_num_response_size_bytes histogram\n\n    dendrite_user_online_num_response_size_bytes_bucket{le=\"200\"} 1214\n\n    dendrite_user_online_num_response_size_bytes_bucket{le=\"500\"} 1214\n\n    dendrite_user_online_num_response_size_bytes_bucket{le=\"900\"} 1214\n\n    dendrite_user_online_num_response_size_bytes_bucket{le=\"1500\"} 1214\n\n    dendrite_user_online_num_response_size_bytes_bucket{le=\"5000\"} 1214\n\n    dendrite_user_online_num_response_size_bytes_bucket{le=\"15000\"} 1214\n\n    dendrite_user_online_num_response_size_bytes_bucket{le=\"50000\"} 1214\n\n    dendrite_user_online_num_response_size_bytes_bucket{le=\"100000\"} 1214\n\n    dendrite_user_online_num_response_size_bytes_bucket{le=\"+Inf\"} 1214\n\n    dendrite_user_online_num_response_size_bytes_sum 1214\n\n    dendrite_user_online_num_response_size_bytes_count 1214\n\n    # HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles.\n\n    # TYPE go_gc_duration_seconds summary\n\n    go_gc_duration_seconds{quantile=\"0\"} 2.5635e-05\n\n    go_gc_duration_seconds{quantile=\"0.25\"} 4.6248e-05\n\n    go_gc_duration_seconds{quantile=\"0.5\"} 5.2428e-05\n\n    go_gc_duration_seconds{quantile=\"0.75\"} 6.108e-05\n\n    go_gc_duration_seconds{quantile=\"1\"} 0.0001923\n\n    go_gc_duration_seconds_sum 0.002047596\n\n    go_gc_duration_seconds_count 37\n\n    # HELP go_goroutines Number of goroutines that currently exist.\n\n    # TYPE go_goroutines gauge\n\n    go_goroutines 168\n\n    # HELP go_info Information about the Go environment.\n\n    # TYPE go_info gauge\n\n    go_info{version=\"go1.18.3\"} 1\n\n    # HELP go_memstats_alloc_bytes Number of bytes allocated and still in use.\n\n    # TYPE go_memstats_alloc_bytes gauge\n\n    go_memstats_alloc_bytes 8.1388416e+07\n\n    # HELP go_memstats_alloc_bytes_total Total number of bytes allocated, even if freed.\n\n    # TYPE go_memstats_alloc_bytes_total counter\n\n    go_memstats_alloc_bytes_total 2.02933024e+08\n\n    # HELP go_memstats_buck_hash_sys_bytes Number of bytes used by the profiling bucket hash table.\n\n    # TYPE go_memstats_buck_hash_sys_bytes gauge\n\n    go_memstats_buck_hash_sys_bytes 1.482235e+06\n\n    # HELP go_memstats_frees_total Total number of frees.\n\n    # TYPE go_memstats_frees_total counter\n\n    go_memstats_frees_total 849112\n\n    # HELP go_memstats_gc_sys_bytes Number of bytes used for garbage collection system metadata.\n\n    # TYPE go_memstats_gc_sys_bytes gauge\n\n    go_memstats_gc_sys_bytes 7.936496e+06\n\n    # HELP go_memstats_heap_alloc_bytes Number of heap bytes allocated and still in use.\n\n    # TYPE go_memstats_heap_alloc_bytes gauge\n\n    go_memstats_heap_alloc_bytes 8.1388416e+07\n\n    # HELP go_memstats_heap_idle_bytes Number of heap bytes waiting to be used.\n\n    # TYPE go_memstats_heap_idle_bytes gauge\n\n    go_memstats_heap_idle_bytes 8.8064e+06\n\n    # HELP go_memstats_heap_inuse_bytes Number of heap bytes that are in use.\n\n    # TYPE go_memstats_heap_inuse_bytes gauge\n\n    go_memstats_heap_inuse_bytes 8.5794816e+07\n\n    # HELP go_memstats_heap_objects Number of allocated objects.\n\n    # TYPE go_memstats_heap_objects gauge\n\n    go_memstats_heap_objects 77324\n\n    # HELP go_memstats_heap_released_bytes Number of heap bytes released to OS.\n\n    # TYPE go_memstats_heap_released_bytes gauge\n\n    go_memstats_heap_released_bytes 1.572864e+06\n\n    # HELP go_memstats_heap_sys_bytes Number of heap bytes obtained from system.\n\n    # TYPE go_memstats_heap_sys_bytes gauge\n\n    go_memstats_heap_sys_bytes 9.4601216e+07\n\n    # HELP go_memstats_last_gc_time_seconds Number of seconds since 1970 of last garbage collection.\n\n    # TYPE go_memstats_last_gc_time_seconds gauge\n\n    go_memstats_last_gc_time_seconds 1.6812883440088644e+09\n\n    # HELP go_memstats_lookups_total Total number of pointer lookups.\n\n    # TYPE go_memstats_lookups_total counter\n\n    go_memstats_lookups_total 0\n\n    # HELP go_memstats_mallocs_total Total number of mallocs.\n\n    # TYPE go_memstats_mallocs_total counter\n\n    go_memstats_mallocs_total 926436\n\n    # HELP go_memstats_mcache_inuse_bytes Number of bytes in use by mcache structures.\n\n    # TYPE go_memstats_mcache_inuse_bytes gauge\n\n    go_memstats_mcache_inuse_bytes 9600\n\n    # HELP go_memstats_mcache_sys_bytes Number of bytes used for mcache structures obtained from system.\n\n    # TYPE go_memstats_mcache_sys_bytes gauge\n\n    go_memstats_mcache_sys_bytes 15600\n\n    # HELP go_memstats_mspan_inuse_bytes Number of bytes in use by mspan structures.\n\n    # TYPE go_memstats_mspan_inuse_bytes gauge\n\n    go_memstats_mspan_inuse_bytes 274448\n\n    # HELP go_memstats_mspan_sys_bytes Number of bytes used for mspan structures obtained from system.\n\n    # TYPE go_memstats_mspan_sys_bytes gauge\n\n    go_memstats_mspan_sys_bytes 342720\n\n    # HELP go_memstats_next_gc_bytes Number of heap bytes when next garbage collection will take place.\n\n    # TYPE go_memstats_next_gc_bytes gauge\n\n    go_memstats_next_gc_bytes 1.5774864e+08\n\n    # HELP go_memstats_other_sys_bytes Number of bytes used for other system allocations.\n\n    # TYPE go_memstats_other_sys_bytes gauge\n\n    go_memstats_other_sys_bytes 1.646717e+06\n\n    # HELP go_memstats_stack_inuse_bytes Number of bytes in use by the stack allocator.\n\n    # TYPE go_memstats_stack_inuse_bytes gauge\n\n    go_memstats_stack_inuse_bytes 1.867776e+06\n\n    # HELP go_memstats_stack_sys_bytes Number of bytes obtained from system for stack allocator.\n\n    # TYPE go_memstats_stack_sys_bytes gauge\n\n    go_memstats_stack_sys_bytes 1.867776e+06\n\n    # HELP go_memstats_sys_bytes Number of bytes obtained from system.\n\n    # TYPE go_memstats_sys_bytes gauge\n\n    go_memstats_sys_bytes 1.0789276e+08\n\n    # HELP go_threads Number of OS threads created.\n\n    # TYPE go_threads gauge\n\n    go_threads 14\n\n    # HELP process_cpu_seconds_total Total user and system CPU time spent in seconds.\n\n    # TYPE process_cpu_seconds_total counter\n\n    process_cpu_seconds_total 4.27\n\n    # HELP process_max_fds Maximum number of open file descriptors.\n\n    # TYPE process_max_fds gauge\n\n    process_max_fds 65535\n\n    # HELP process_open_fds Number of open file descriptors.\n\n    # TYPE process_open_fds gauge\n\n    process_open_fds 12\n\n    # HELP process_resident_memory_bytes Resident memory size in bytes.\n\n    # TYPE process_resident_memory_bytes gauge\n\n    process_resident_memory_bytes 5.7909248e+07\n\n    # HELP process_start_time_seconds Start time of the process since unix epoch in seconds.\n\n    # TYPE process_start_time_seconds gauge\n\n    process_start_time_seconds 1.68128474314e+09\n\n    # HELP process_virtual_memory_bytes Virtual memory size in bytes.\n\n    # TYPE process_virtual_memory_bytes gauge\n\n    process_virtual_memory_bytes 1.50509568e+09\n\n    # HELP process_virtual_memory_max_bytes Maximum amount of virtual memory available in bytes.\n\n    # TYPE process_virtual_memory_max_bytes gauge\n\n    process_virtual_memory_max_bytes 1.8446744073709552e+19\n\n    # HELP promhttp_metric_handler_requests_in_flight Current number of scrapes being served.\n\n    # TYPE promhttp_metric_handler_requests_in_flight gauge\n\n    promhttp_metric_handler_requests_in_flight 1\n\n    # HELP promhttp_metric_handler_requests_total Total number of scrapes by HTTP status code.\n\n    # TYPE promhttp_metric_handler_requests_total counter\n\n    promhttp_metric_handler_requests_total{code=\"200\"} 1\n\n    promhttp_metric_handler_requests_total{code=\"500\"} 0\n\n    promhttp_metric_handler_requests_total{code=\"503\"} 0\n\n\n</code></pre>"},{"location":"chat/voip_signaling/","title":"Call flow","text":"<p>Useful links: - https://codelabs.developers.google.com/codelabs/webrtc-web/#0 - http://webrtc.github.io/webrtc-org/native-code/android/</p> <p> </p>"},{"location":"gateway/config/","title":"configuration","text":""},{"location":"gateway/config/#block-time","title":"block time","text":"<p>The commit timeout value in the node config defines how long we wait after committing a block before starting a new height (this gives us the chance to receive more precommits even though we already have +2/3) . The current default is <code>6s</code>.</p> <p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p> <p>\ud83d\udce3 Tip: As of v6, this is automatically handled by the server when initializing the node. Validators need to ensure that their local nodes are configured to speed up the network to ~2 second block times. :::</p> <pre><code># In $install_path/.stcd/config/config.toml\n\n#######################################################\n###         Consensus Configuration Options         ###\n#######################################################\n[consensus]\n\n### ... \n\n# How long we wait after committing a block, before starting on the new\n# height (this gives us a chance to receive some more precommits, even\n# though we already have +2/3).\ntimeout_commit = \"1s\"\n</code></pre>"},{"location":"gateway/config/#node","title":"node","text":"<p>In <code>$install_path/.stcd/config/config.toml</code> you can set your peers.</p> <p>See Adding Persistent Nodes in our docs for an automated method, but the fields should look like comma-separated peer strings (don't copy it, just an example):</p> <pre><code>persistent_peers = \"5576b0160761fe81ccdf88e06031a01bc8643d51@195.201.108.97:24656,13e850d14610f966de38fc2f925f6dc35c7f4bf4@176.9.60.27:26656,38eb4984f89899a5d8d1f04a79b356f15681bb78@18.169.155.159:26656,59c4351009223b3652674bd5ee4324926a5a11aa@51.15.133.26:26656,3a5a9022c8aa2214a7af26ebbfac49b77e34e5c5@65.108.1.46:26656,4fc0bea2044c9fd1ea8cc987119bb8bdff91aaf3@65.21.246.124:26656,6624238168de05893ca74c2b0270553189810aa7@95.216.100.80:26656,9d247286cd407dc8d07502240245f836e18c0517@149.248.32.208:26656,37d59371f7578101dee74d5a26c86128a229b8bf@194.163.172.168:26656,b607050b4e5b06e52c12fcf2db6930fd0937ef3b@95.217.107.96:26656,7a6bbbb6f6146cb11aebf77039089cd038003964@94.130.54.247:26656\"\n</code></pre>"},{"location":"gateway/config/#share-your-node","title":"Share your node","text":"<p>You can view and share your peers with the <code>tendermint show-node-id</code> command</p> <pre><code>stcd tendermint show-node-id\nac29d21d0a6885465048a4481d16c12f59b2e58b\n</code></pre> <ul> <li>node format: <code>node-id@ip:port</code></li> <li>Example: <code>ac29d21d0a6885465048a4481d16c12f59b2e58b@143.198.224.124:26656</code></li> </ul>"},{"location":"gateway/config/#health-node","title":"Health Node","text":"<p>If you only rely on seed nodes and have no persistent peers or only a small number, please add the following parameters to <code>config.toml</code>:</p> <pre><code># Maximum number of inbound peers\nmax_num_inbound_peers = 120\n\n# Maximum number of outbound peers to connect to, excluding persistent peers\nmax_num_outbound_peers = 60\n</code></pre>"},{"location":"gateway/disk-usage/","title":"Disk usage optimization","text":"<p>Customize configuration settings to reduce disk requirements for validator nodes.</p> <p>Blockchain databases tend to grow over time, depending on things like block speed and transaction amounts. For Daodst we're talking close to 100GB of disk usage for the first two weeks.</p> <p>Few configurations can significantly reduce the required disk usage. Some of these changes will not fully take effect until you configure and sync from using them.</p>"},{"location":"gateway/disk-usage/#index","title":"index","text":"<p>If you don't need to query transactions from a specific node, you can disable the index. Set it in <code>config.toml</code></p> <pre><code>indexer = \"null\"\n</code></pre> <p>If you do this on a node that is already synced, the collected indexes will not be cleared automatically, you will need to delete them manually. The index is located under the database directory named <code>data/tx_index.db/</code>.</p>"},{"location":"gateway/disk-usage/#state-synchronization-snapshot","title":"State synchronization snapshot","text":"<p>I believe this is disabled by default on Daodst, but will be listed here anyway. In <code>app.toml</code> set</p> <pre><code>snapshot-interval = 0\n</code></pre> <p>Note that if state sync is enabled on the network and working properly, it will allow one to sync a new node in a matter of minutes. But this node will not have history.</p>"},{"location":"gateway/disk-usage/#configure-pruning","title":"Configure pruning","text":"<p>By default, every 500 states are kept, and the last 100 states are kept. In the long run, this consumes a lot of disk space, which can be optimized with the following custom configuration:</p> <pre><code>pruning = \"custom\"\npruning-keep-recent = \"100\"\npruning-keep-every = \"0\"\npruning-interval = \"10\"\n</code></pre>"},{"location":"gateway/disk-usage/#index_1","title":"index","text":"<p>If you don't need to query transactions from a specific node, you can disable the index. Set it in <code>config.toml</code></p> <pre><code>indexer = \"null\"\n</code></pre> <p>If you do this on a node that is already synced, the collected indexes will not be cleared automatically, you will need to delete them manually. The index is located under the database directory named <code>data/tx_index.db/</code>.</p>"},{"location":"gateway/disk-usage/#state-synchronization-snapshot_1","title":"State synchronization snapshot","text":"<p>I believe this is disabled by default on Daodst, but will be listed here anyway. In <code>app.toml</code> set</p> <pre><code>snapshot-interval = 0\n</code></pre> <p>Note that if state sync is enabled on the network and working properly, it will allow one to sync a new node in a matter of minutes. But this node will not have history.</p>"},{"location":"gateway/disk-usage/#configure-pruning_1","title":"Configure pruning","text":"<p>By default, every 500 states are kept, and the last 100 states are kept. In the long run, this consumes a lot of disk space, which can be optimized with the following custom configuration:</p> <pre><code>5.3G    ./state.db\n70G     ./application.db\n20K     ./snapshots/metadata.db\n24K     ./snapshots\n9.0G    ./blockstore.db\n20K     ./evidence.db\n1018M   ./cs.wal\n4.7G    ./tx_index.db\n90G     .\n</code></pre> <p>This optimized configuration has reduced disk usage to 17 GB.</p> <pre><code>17G     .\n1.1G    ./cs.wal\n946M    ./application.db\n20K     ./evidence.db\n9.1G    ./blockstore.db\n24K     ./snapshots\n20K     ./snapshots/metadata.db\n5.3G    ./state.db\n</code></pre>"},{"location":"gateway/faq/","title":"Authenticator FAQ","text":"<p>Review frequently asked questions about running validators on DST.</p>"},{"location":"gateway/faq/#general-concepts","title":"General concepts","text":"What is a validator? <p>DST is powered by [Tendermint](https://docs.tendermint.com/v0.34/introduction/what-is-tendermint.html) Core, which relies on a set of validators to secure the network. </p> <p>Validators run a full node and participate in consensus by broadcasting votes containing cryptographic signatures signed by their private keys. Validators submit new blocks in the blockchain and earn income in exchange for their work. </p> <p>They also participate in financial governance within the protocol by voting on governance proposals. Validators' voting influence is weighted by their total stake. </p> What is \"staking\"? <p>DST is a public proof-of-stake (PoS) blockchain, which means validators are weighted based on the amount of Mortgage Tokens (FM) held as collateral. These staked tokens can be directly staked by validators or delegated to them by FM holders. </p> <p>Any user in the system can declare their intent to become a validator by sending a <code>create-validator</code> transaction. From there, they become validators. A validator's weight (i.e. total stake or voting power) determines whether it is an active validator, and also determines how often the node proposes blocks and how much it will earn. </p> <p>Initially, only the top 150 validators with the highest weight will be active validators. If validators double-sign or are often offline, they risk staked tokens (including user-delegated FMs) being \u201cslashed\u201d by the protocol to punish negligence and misconduct. </p> What is a full node? <p>A full node is a program that fully verifies the transactions and blocks of a blockchain. It differs from light client nodes that only process block headers and a small set of transactions. Running a full node requires more resources than a light client, but it is required to be a validator. </p> <p>In practice, running a full node simply means running an uncompromised and up-to-date version of the software, with low network latency and no downtime. Of course, any user can and is encouraged to run a full node, even if they don't intend to become a validator. </p> What is pos commission? <p>Delegators are FM holders who cannot or do not want to run validator operations themselves. . Users can delegate FM to validators and receive a portion of their revenue in exchange (for more details on how revenue is distributed, see What is the motivation for staking? and What is Validation below? server commissions? section). </p> <p>Because they share revenue with their validators, delegators also share responsibility. If a validator misbehaves, each of its delegators will be partially slashed in proportion to their stake. This is why delegators should do due diligence on validators before delegating and diversify by spreading their stake across multiple validators. </p> <p>Delegators play a key role in the system as they are responsible for selecting validators. Note that being a principal is not a passive role. Delegators are obliged to be vigilant and actively monitor the behavior of their validators and switch if they fail to act responsibly. </p>"},{"location":"gateway/faq/#become-a-validator","title":"Become a validator","text":"How to become a validator? <p> Any participant in the network can indicate their intention to become a validator by creating a validator and registering their validator profile. To do this, candidates broadcast a <code>create-validator</code> transaction in which they must submit the following information: <ul> <li>Validator's PubKey: Validator operators can have different accounts for validating and holding liquidity. </li> The submitted PubKey must be associated with the private key with which the validator intends to sign prevotes and precommits.  <li>Validator's Address: dstvaloper1- address. This is the address used to publicly identify your validator. The private key associated with this address is used for binding, unbinding and claiming rewards. </li> <li>Validator's name (also known as nickname)</li> <li>Validator's website(optional)</li> <li>Validator's description (optional)</li> <li>Initial commission rate: Block rewards and fees charged to delegators.</li> <li>Maximum commission: The maximum commission rate this validator will be allowed to charge. </li> <li>Commission change rate: Maximum daily increase in validator commission. </li> <li>Minimum self-bond amount: The minimum amount of FMs that the validator needs to always bond with. If a validator's self-staking stake falls below this limit, its entire staking pool will be unstaked. </li> <li>Initial self-bond amount: The initial FM amount that the validator wants to self-bond. </li> </ul> <pre><code>stcd tx staking create-validator\n--pubkey dstvalconspub1zcjduepqs5s0vddx5m65h5ntjzwd0x8g3245rgrytpds4ds7vdtlwx06mcesmnkzly\n--amount \"2fm\"\n--from tmp\n--commission-rate=\"0.20\"\n--commission-max-rate=\"1.00\"\n--commission-max-change-rate=\"0.01\"\n--min-self-delegation \"1\"\n--moniker \"validator\"\n--chain-id \"fm_9000-4\"\n--gas auto\n--node tcp://127.0.0.1:26647\n</code></pre> </p> <p> \ud83d\udea8 Dangerous: DO NOT use test as the keyring backend to create your mainnet validator keys. Doing so can result in the loss of funds, as your funds can be accessed remotely via the <code>eth_sendTransaction</code> JSON-RPC endpoint. </p> <p> Once a validator is created and registered, FM holders can delegate FM to it, effectively adding stake to their pool. The total pledge amount of the validator is the sum of the FM staked by the validator operator itself and the FM staked by the external delegator. </p> <p> Only the top 150 validators holding the most stake are considered active and become Bind authenticator. If the validator's total stake falls below the top 150, the validator will lose its validator privileges (meaning it will not generate rewards) and will no longer be part of the active set (i.e. not participate in consensus), enter  to unbind mode and eventually becomes Unbind. </p>"},{"location":"gateway/faq/#authenticator-key-and-state","title":"Authenticator key and state","text":"What are the different types of keys? <p>In short, there are two types of keys:</p> <ul> <li>Tendermint key: This is the unique key used to sign the block hash. It is associated with the public key <code>dstvalconspub</code>.  <ul> <li>Generated when a node is created with <code>stcd init</code>. </li> <li>Use <code>stcd tendermint show-validator</code> to get this value, for example <code>dstvalconspub1zcjduc3qcyj09qc03elte23zwshdx92jm6ce88fgc90rtqhjx8v0608qh5ssp0w94c</code></li> </ul> </li> <li>Application Keys: These keys are created from the application and are used to sign transactions. As a validator, you might use one key to sign staking-related transactions and another key to sign oracle-related transactions. The application key is associated with the public key <code>dstpub-</code> and the address <code>dst-</code>. Both are derived from account keys generated by <code>stcd keys add</code>. </li> </ul> <p> \u26a0\ufe0fNote: The validator's operator key is bound directly to the application key, but the reserved prefixes are used only for this purpose: <code>dstvaloper</code> and <code>dstvaloperpub</code> </p> What are the different states that a validator can be in? <p>Once a validator is created using the create-validator transaction, it can be in three states:</p> <ul> <li>bonded: The validator is in the active set and participating in consensus. Validators are being rewarded and can be slashed for misbehavior. </li> <li>unbonding: The validator is not in the active set and does not participate in the consensus.  Validators are not rewarded, but can still be slashed for misbehavior. This is the transition state from bound to unbound. If a validator does not send a rebond transaction in unbond mode, it takes two weeks to complete the state transition. </li> <li>unbonded: The validator is not in the active set and therefore does not sign blocks.  Unbonded validators cannot be slashed, but do not receive any rewards for their actions. FM can still be delegated to this validator.  Unbonding from an <code>unbonded</code> validator is immediate. Delegators have the same state as their validators. </li> </ul> \u26a0\ufe0fNote: A delegate is not necessarily bound. FM can be delegated and bound, delegated and unbound, delegated and unbound, or liquid.  What is a \"self-mortgage\"? How do I increase my \"self-mortgage\"? <p> A validator operator's self-staking refers to the amount of FM pledged to itself. You can increase your self-staking by delegating more FM to your validator account. </p> Is there a testnet faucet? <p> If you want to get testnet coins, you can use water-tap </p> Is there a minimum amount of FMs that must be staked to be an active (bonded) validator?  <p> There is no minimum. The top 150 validators with the highest total stake (where <code>total stake = self-bonded stake + delegators stake</code>) are active validators. </p> How will delegators choose their validators?  <p> Delegators are free to choose validators based on their own subjective criteria. That said, criteria expected to be important include: </p> <ul> <li>Number of self-bonded FMs: The number of FMs the validator has self-bonded to its staking pool. Validators with more self-bonded FMs have more skin in the game, making them more responsible for their actions. </li> <li>Number of FMs Delegated: The total number of FMs delegated to the validator. A high stake indicates that the community trusts the validator, but also means that the validator is a bigger target for hackers. As the number of delegated FMs grows, validators are expected to become less and less attractive. Larger validators also increase the centralization of the network. </li> <li>Commission Rate: The commission that validators apply to earnings before distributing them to their delegators</li> <li>Track History: Delegators may view the track records of the validators they plan to delegate to. This includes seniority, past votes on proposals, historical average uptime, and how often nodes are compromised. </li> </ul> <p> In addition to these criteria, validators can also provide a website address to complete their resume. Validators need to build a reputation somehow to attract delegators. For example, it is good practice for validators to have their settings audited by a third party. Note, however, that the DST community does not self-approve or conduct any moderation. </p>"},{"location":"gateway/faq/#responsibilities","title":"Responsibilities","text":"Do verifiers need to disclose their identities?  <p> No they don't. Each delegator will evaluate validators according to their own criteria. Validators will be able to (and be advised to) register a website address when they nominate themselves so they can advertise their operations as they see fit. Some delegators may prefer a website that clearly shows the team running the validator and their bio, while others may prefer an anonymous validator with a good track record. Authenticators and anonymous verifiers will most likely co-exist in the validator set. </p> What is the role of a validator? <p> Validators have three main responsibilities:  <ul> <li> Be able to consistently run the correct version of the software: Validators need to ensure that their servers are always online and their private keys are not compromised. </li> <li> Provide oversight and feedback on the proper deployment of community pool funds: The Daodst Protocol includes a proposal governance system to facilitate the adoption of its currency. Validators are expected to hold budget implementers accountable for providing transparency and efficient use of funds. </li> </ul>  Additionally, validators should be active members of the community. They should always be aware of the current state of the ecosystem so they can easily adapt to any changes. </p> What does staking mean? <p> Staking FM can be regarded as a security deposit for verification activities. When a validator or delegator wants to get back some or all of their stake, they send an unbond transaction. Deposits then go through a *two-week unbonding period* during which they may be slashed for potential misconduct by validators before the unbonding process begins. </p> Can a validator run away with a delegator's FM?  <p> By delegating to a validator, a user delegates a stake. The more collateral a validator has, the more weight it has in the consensus and process. This does not mean that validators can take custody of their delegators' FM. Verifiers must never run away with delegator funds.  Even if delegated funds cannot be stolen by their validators, delegators are still liable if their validators misbehave. In this case, each settlor's stake will be partially cut in proportion to their relative stake. </p> How often will a validator be elected to propose the next block? Will it increase with the number of staked FM <p> The verifier selected to mine the next block is called the proposer, which is the `leader`\"` in this round of consensus. Each proposer is deterministically selected and is selected by The selected frequency is equal to the validator's relative total stake (where total stake = self-mortgaged stake + delegator's stake). For example, if the total stake of all validators is 100 FM, and the total stake of a validator is 10 FM, then that validator will have a 10% chance of being elected as a proposer.  To learn more about the proposer selection process in the Tendermint BFT consensus, read more (https://docs.tendermint.com/master/spec/consensus/proposer-selection.html) </p>"},{"location":"gateway/faq/#incentives","title":"Incentives","text":"What is the motivation for staking?   Each member of a validator stake pool receives a different type of income:  <p> Block Reward: The native token of the application run by the validator (e.g. FM on Daodst) is inflated to generate block terms. These terms exist to incentivize FM holders to bind their stake, as unbound FM will Diluted over time. </p> <p> Transaction Fees: Daodst maintains a whitelist of tokens that are accepted as payment for fees. The initial fee token is `dst`. <p>  This total revenue is distributed to validators' stake pools according to each validator's weight. Then, in each The validator\u2019s staking pool revenue is distributed to delegators in proportion to each delegator\u2019s stake. commission The delegator's income is applied by the validators before being distributed.   What is the motivation for running the validator?   Validators earn more than their delegators due to commissions.  Validators also play an important role in governance. If a delegator does not vote, they will inherit their voting rights validator. This gives validators primary responsibility in the ecosystem.   What is a validator commission?   The revenue received by the validator pool is distributed between the validator and its delegators. Validators can apply A commission allocated to a portion of the principal's income. This commission is set as a percentage.  Each validator is free to set its initial commission, maximum daily commission change rate, and maximum commission. Daodst enforces parameters set by each validator. These parameters can only be defined when initially declaring Candidature, and can be further restricted only if declared.   How are collective provisions assigned?  <p> Block terms (rewards) are distributed among all validators proportional to their total stake (voting power). This means that even though each validator earns FM per supply, all validators will remain equal weight. </p> <p> Let's take an example where we have 10 validators with the same stake and 1% commission rate. let us also Suppose the supply of a block is 1000 FM, and each validator has 20% self-mortgaged FM. these tokens Do not go directly to the proposer. Instead, they are evenly distributed among validators. So now each validator's pool There are 100 FMs. The 100 FM will be distributed according to each participant's stake: </p> <ul> <li>Commission: `100*80%*1% = 0.8 FM`</li> <li>Validator gets: `100\\*20% + commission = 20.8 FM`</li> <li>All principals get: `100\\*80% - commission = 79.2 FM`</li> </ul> Each delegator can then claim a portion of the 79.2 FM in proportion to their stake in the validator's stake pool. Note that validator commissions do not apply to block terms. Note that block rewards are distributed according to the same mechanism.   How will costs be allocated?  <p> Fees are distributed in a similar manner, except block proposers get a block fee bonus Suggest if it contains more than the strict minimum required precommit. </p> <p> When a validator is chosen to propose the next block, it must include at least \u2154 precommits of the previous block The form of the verifier's signature. However, there is an incentive to include more than \u2154 of pre-commits bonus. Rewards are linear: if a proposer includes \u2154rd precommits (the minimum for a block), the reward ranges from 1% valid) to 5%, if the proposer includes 100% pre-commit. Of course suitors can't wait too long or whatever A validator may timeout and move on to the next proposer. Therefore, validators must find a balance between The wait time for getting the most signatures and the risk of losing the proposed next block. The mechanism is designed to Incentivizes non-empty block proposals, better networking among validators, and mitigation of censorship. </p> <p> Let us take a concrete example to illustrate the above concept. In this example, there are 10 validators equal interest. They charge 1% commission each and have a 20% self-insured FM. Now comes a successful block A total of 1005 dst will be charged. Suppose the proposer includes 100% of the signatures in its proposal clogged. Get a full 5% bonus. </p> <p> We have to solve this simple equation to find the reward for each validator: </p>  $$9R ~ + ~ R ~ + ~ 5\\%(R) ~ = ~ 1005 ~ \\left and right arrows ~ R ~ = ~ 1005 ~/ ~10.05 ~ = ~ 100$$  <p> For proposer validators: </p> <ul> <li>Pool gets $R ~ + ~ 5\\%(R)$: 105 DST</li> <li>Commission: $105 ~ *~ 80\\% ~* ~ 1\\%$ = 0.84 DST</li> <li>Validator reward: $105 ~ * ~ 20\\% ~ + ~ commission = 21.84 DST</li> <li>Delegator Rewards: $105 ~ * ~ 80\\% ~ - ~ Commission = 83.16 DST (each delegator can claim his own portion These rewards are proportional to their stake)</li> <li>Pool gets $R$: 100 DST</li> <li>Commission: $100 ~ *~ 80\\% ~* ~ 1\\%$ = 0.8 DST</li> <li>Validator reward: $100 ~ * ~ 20\\% ~ + ~ commission = 20.8 DST</li> <li>Delegator Rewards: $100 ~ * ~ 80\\% ~ - ~ Commission = 79.2 DST (each delegator can claim his own portion These rewards are proportional to their stake)</li> </ul> What are the cut conditions?  <p> If a validator misbehaves, its pledged stake and its delegator's stake will be slashed. the severity of Penalties depend on the type of error. There are 3 major bugs that could result in a validator's funds being slashed and its principals: </p> <p> Double Signature: If someone on chain A reports that the validator signed two blocks at the same height on chain A and Chain B, if chain A and chain B share a common ancestor, then this validator will be slashed on chain A. punish Double sign is 10.00% of the total shares. </p> <ul> <li>Downtime: If validators miss more than 50% of the last 90.000 blocks, they will be slashed by 0.50%. </li> <li>Unavailability: If the validator's signature is not included in the last X blocks, the validator will get is cut by a marginal quantity proportional to X. If X is above some limit Y, the validator will unbind. </li> </ul> <p> Note that even if a validator does not misbehave intentionally, it will still be slashed if its node crashes, loses Connectivity, get DDoSed, or have their private key compromised. </p> Do validators need to self-bind FM?  <p> No they don't. A validator's total stake is equal to the sum of its own collateral stake and its delegated stake. This means that validators can compensate their small self-staking stake by attracting more delegators. This is Why reputation is very important for validators. </p> <p> Even though validators are not obliged to bind FM themselves, delegators should expect their validators to have Self-bond FM in their staking pool. In other words, validators should participate. </p> <p> To give delegators some assurance about how much stake their validators have, the latter can signal Minimal amount of self-bonded FM. If the validator's self-constraint is lower than its predefined limit, then this The validator and all its delegators will be unbound. </p> How to prevent the concentration of stake in the hands of a few top validators?  <p> For now, the community should act in a smart and self-protective manner. When bitcoin mining pools become too The community usually stops contributing much mining power to the pool. Daodst will initially rely on the same effect. In the future, other mechanisms will be deployed to smooth this process as much as possible: </p> <p> Penalty-free re-delegation: This is to allow delegators to easily switch from one validator to another so that To reduce the stickiness of the verifier. </p> <p> UI warning: Wallets can implement warnings that will be shown to users if they want to delegate to a validator Already owns a substantial mortgage. </p>"},{"location":"gateway/faq/#skills-requirement","title":"skills requirement","text":"What are the hardware requirements?  <p> Validators should expect redundant power, network, firewall, HSMs and servers. </p>  We anticipate that modest hardware specifications will be required initially, and that they may increase as the network grows Use increased. Participating in the testnet is the best way to learn more.   What are the software requirements?   In addition to running Daodst nodes, validators should also develop monitoring, alerting, and management solutions.   What are the bandwidth requirements?  <p> Daodst has very high throughput compared to chains like Ethereum or Bitcoin. </p> <p> Therefore, we recommend that data center nodes only connect to trusted full nodes or other validators in the cloud Get to know each other socially. This offloads data center nodes from mitigating denial-of-service attacks. </p> <p> Eventually, as the network is used more and more, one can actually expect bandwidth on the order of several gigabytes per day. </p> What does it mean to run a validator?   A successful validator operation will require the effort and ongoing operation of multiple highly skilled personnel attention. This is much more complicated than running a bitcoin miner, for example.   How is key management handled?   Validators should expect to run HSMs that support ed25519 keys  <p> The Daodst team does not recommend one solution over another. Encourage the community to step up efforts to Improved security for HSMs and key management. </p> What can validators expect in terms of operations?   Running efficient operations is key to avoiding accidental unbundling or hacking. This includes being able to Respond to attacks, outages, and maintain data center security and isolation.   What are the maintenance requirements?   Validators should expect to perform regular software updates to accommodate upgrades and bug fixes. inevitably there will be Problems early in the network boot phase require a high level of vigilance.   How do validators protect themselves from denial of service attacks?  <p> A denial of service attack occurs when an attacker sends a large amount of Internet traffic to an IP address to prevent server access On an IP address connected to the Internet. </p> <p> The attacker scans the network, trying to learn the IP addresses of various validator nodes and disconnect them from Communicate by flooding them with traffic. </p> <p> A recommended way to mitigate these risks is for validators to carefully structure their network topology in a so-called Sentinel node architecture. </p> <p> Validator nodes should only connect to full nodes they trust because they operate themselves or are run by others Validators they know socially. Validator nodes typically run in data centers. Most data centers provide direct Links to the network of major cloud providers. Validators can use these links to connect to Sentinel nodes in the cloud. This shifts the burden of denial of service from the validator's node directly to its sentinel nodes, and may require new Start or activate Sentinel nodes to mitigate attacks on existing nodes. </p> <p> Sentinel nodes can quickly start or change their IP address. Because the link to the Sentinel node is private IPspace, Internet-based attacks cannot directly interfere with them. This will ensure validators block proposals and votes Always let it reach the rest of the network. </p> <p> It is expected that good operating procedures by this subset of validators will fully mitigate these threats. </p>"},{"location":"gateway/guide-linux/","title":"Instructions for use on the PC side","text":""},{"location":"gateway/guide-win/","title":"Instructions for use on the PC side","text":""},{"location":"gateway/guide-win/#install","title":"install","text":"<pre><code>Open the installation package, jump out of the following interface, click OK (some antivirus software will falsely report)\n</code></pre> <pre><code>Select the installation directory (recommended to be larger than 1TB)\n</code></pre> <pre><code>Wait patiently for the installation to complete\n</code></pre>"},{"location":"gateway/guide-win/#process","title":"process","text":"<pre><code>Create or import wallet address --&gt; create dpos --&gt; create gateway --&gt; pledge FM --&gt; receive rewards\n</code></pre>"},{"location":"gateway/guide-win/#new-wallet","title":"new wallet","text":""},{"location":"gateway/guide-win/#import-wallet","title":"import wallet","text":""},{"location":"gateway/guide-win/#create-validator","title":"create validator","text":""},{"location":"gateway/guide-win/#create-gateway","title":"create gateway","text":""},{"location":"gateway/guide-win/#pledge-fm","title":"Pledge FM","text":""},{"location":"gateway/guide-win/#receive-award","title":"Receive award","text":""},{"location":"gateway/guide-win/#front-page","title":"front page","text":"<pre><code>The home page contains some global views and functions\n These include:\n\n\nView block synchronization (top right of the interface)\n</code></pre> <pre><code>View task status (upper right corner of interface)\n</code></pre> <pre><code>Management software settings (bottom left corner of the interface)\n</code></pre>"},{"location":"gateway/guide-win/#actions","title":"Actions","text":"<pre><code>The Actions in the upper right corner can manage DID and modify gateway information\n</code></pre>"},{"location":"gateway/guide-win/#did-segment-management","title":"DID segment management","text":"<pre><code>More DID numbers can be obtained by staking FM\n</code></pre> <pre><code>Select the line on the left side of the homepage, including two tabs for assets and gateways\n</code></pre>"},{"location":"gateway/guide-win/#property","title":"Property","text":"<pre><code>Asset interface management includes balance, transfer, transaction records, and account management\n\nThe three buttons on the left correspond to the three main coins of DST, FM and HASH respectively\n</code></pre> <pre><code>On the right side, you can view the balance quantity, transaction records, and send and receive the main currency\n</code></pre> <pre><code>Here export the mnemonic and change the password\n</code></pre>"},{"location":"gateway/guide-win/#gateway","title":"gateway","text":"<pre><code>Gateway function management dpos pledge, gateway server, gateway app, gateway key, etc.\n</code></pre>"},{"location":"gateway/guide-win/#dpos-pledge-management","title":"DPOS pledge management","text":"<pre><code>After becoming a validator, you can check the DPOS status of this node on the _DPOS pledge management_ page\n\nAvailable for pledge and redemption\n</code></pre> <pre><code>The redemption of DPOS is not immediately received, check the redemption status here\n</code></pre> <pre><code>Can view and claim staking rewards and commissions\n</code></pre> <pre><code>Modify the settings of the gateway here\n</code></pre>"},{"location":"gateway/guide-win/#gateway-server-resources","title":"Gateway server resources","text":""},{"location":"gateway/guide-win/#gateway-app","title":"gateway app","text":""},{"location":"gateway/guide-win/#gateway-key","title":"gateway key","text":"<pre><code>For details on how to use the gateway key, see\n</code></pre>"},{"location":"gateway/guide-win/#how-to-use-the-gateway-key","title":"How to use the gateway key","text":""},{"location":"gateway/guide-win/#setting-method","title":"Setting method","text":"<pre><code>Settings include: version detection, language detection, history clearing settings, node settings, data directory settings, routing layer detection\n</code></pre>"},{"location":"gateway/guide-win/#upgrade","title":"upgrade","text":"<pre><code>Check for updates by checking for updates\n</code></pre> <pre><code>Wait for the download to complete\n</code></pre> <pre><code>Just exit the update\n</code></pre>"},{"location":"gateway/key-backup/","title":"backup","text":"<p> Users can choose to back up the gateway key, authenticator key and app encryption file for recovery when needed</p> <p>Backup is divided into manual backup and on-chain backup. On-chain backup only needs a small amount of gas to back up to the chain and can be downloaded at any time</p>"},{"location":"gateway/key-backup/#manual-backup","title":"Manual backup","text":"<p>Click the gateway option on the left, click the [Download Key File] button, and save it to the specified location</p>"},{"location":"gateway/key-backup/#on-chain-backup","title":"On-chain backup","text":"<p>Click the gateway option on the left, click the [Storage on Gateway Key Chain] button, enter the password, and the storage will be completed after the chain is successfully uploaded</p>"},{"location":"gateway/key-backup/#restore","title":"restore","text":"<p>If it is stored on the chain, the [Storage button on the gateway key chain] button will be changed to [Download the key on the chain], after clicking, the three files will be saved in the GatewayKey directory under the gateway directory</p> <pre><code> GatewayKey/\n \u251c\u2500\u2500 fmc.jks # app signature file\n \u2502\u2500\u2500 node_key.json # Gateway key file\n \u2514\u2500\u2500 priv_validator_key.json # validator private key file\n</code></pre> <p>in the chain stop state Move fmc.jks to the home directory Move node_ key.json and priv_ validator_ key.json to the gateway directory .stcd/config/ Down</p> <p>If it is stored manually, similarly, restore the corresponding file to the corresponding location</p>"},{"location":"gateway/mainnet/","title":"mainnet","text":"<p>This document outlines the steps to join an existing mainnet.</p>"},{"location":"gateway/mainnet/#prerequisites-to-read","title":"Prerequisites to read","text":"<ul> <li>Authenticator Security</li> </ul>"},{"location":"gateway/mainnet/#mainnet_1","title":"Mainnet","text":"<p>You need to setup a genesis file and a seed node. If you need more information on past networks, check out our mainnet repo. The table below outlines all mainnet chain IDs. Note that the displayed version may differ when there is an active software upgrade proposal on-chain.</p> Chain ID describe Location Version state <code>daodst_7777-1</code> Daodst Mainnet 1 Daodst <code>v1.0.0</code> <code>active</code> <p>\u26a0\ufe0f IMPORTANT: If you join mainnet as a validator, please make sure you follow all security recommendations!</p>"},{"location":"gateway/mainnet/#install-daodst","title":"Install <code>daodst</code>","text":"<p>Follow the installation documentation to install the program</p> <p>\u26a0\ufe0f Note : Make sure you have the correct version of the program installed.</p>"},{"location":"gateway/mainnet/#save-chain-id","title":"Save Chain ID","text":"<p>We recommend saving the mainnet <code>chain-id</code> to your app's <code>client.toml</code>. This will save you from having to manually pass the <code>chain-id</code> flag for every CLI command.</p> <p>\ud83d\udce3 Tip : Please refer to the official chain ID for reference.</p> <pre><code>stcd config chain-id daodst_7777-1\n</code></pre>"},{"location":"gateway/mainnet/#initialize-node","title":"Initialize node","text":"<p>We need to initialize the node to create all necessary validators and node configuration files:</p> <pre><code>stcd init &lt;your_custom_moniker&gt; --chain-id daodst_7777-1\n</code></pre> <p>\u26a0\ufe0fDangerous : Name objects can only contain ASCII characters. Using Unicode characters will make your node inaccessible.</p> <p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p> <p>By default, the <code>init</code> command creates the <code>$install_path/.stcd</code> (ie <code>$HOME</code>) directory with subfolders <code>config/</code> and <code>data/</code>. In the <code>config</code> directory, the most important configuration files are <code>app.toml</code> and <code>config.toml</code>.</p>"},{"location":"gateway/mainnet/#genesis-seed-nodes","title":"Genesis &amp; Seed Nodes","text":""},{"location":"gateway/mainnet/#copy-the-genesis-file","title":"Copy the genesis file","text":"<p>Download the <code>genesis.json</code> file from <code>github</code> and copy it to the <code>config</code> directory: <code>$install_path/.stcd/config/genesis.json</code>. This is a genesis file that contains the chain ID and the balance of the genesis account.</p> <pre><code>wget https://github.com/daodst/mainnet/daodst_7777-1/genesis.json\nmv genesis.json $install_path/.stcd/config/\n</code></pre> <p>Then verify the correctness of the genesis configuration file:</p> <pre><code>stcd validate-genesis\n</code></pre>"},{"location":"gateway/mainnet/#add-seed-node","title":"Add seed node","text":"<p>Your peers need to know how to find peers.</p> <p>You need to add a healthy seed node to <code>$install_path/.stcd/config/config.toml</code> <code>mainnet</code> repository contains some links seed node.</p> <p>Edit the files located in <code>$install_path/.stcd/config/config.toml</code> and <code>seeds</code> to the following:</p> <pre><code>#######################################################\n###           P2P Configuration Options             ###\n#######################################################\n[p2p]\n\n# ...\n\n# Comma separated list of seed nodes to connect to\nseeds = \"&lt;node-id&gt;@&lt;ip&gt;:&lt;p2p port&gt;\"\n</code></pre> <p>You can fetch a seed from the repository and add it to your config with the following code:</p> <pre><code>SEEDS=`curl -sL https://raw.githubusercontent.com/daodst/mainnet/main/daodst_7777-1/seeds.txt | awk '{print $1}' | paste -s -d, -`\nsed -i.bak -e \"s/^seeds =.*/seeds = \\\"$SEEDS\\\"/\" $install_path/.stcd/config/config.toml\n</code></pre> <p>\ud83d\udce3 Tips: For more information on torrents and peers, you can check out the Tendermint P2P Documentation.</p>"},{"location":"gateway/mainnet/#add-persistent-node","title":"Add persistent node","text":"<p>We can set <code>persistent_peers</code> Fields in <code>$install_path/.stcd/config/config.toml</code> specify the peers with which your node will maintain persistent connections. You can retrieve them from the list of available nodes in the <code>mainnet</code> repository.</p> <p>You can grab 10 random entries from the <code>peers.txt</code> file for the <code>PEERS</code> variable by running:</p> <pre><code>PEERS=`curl -sL https://raw.githubusercontent.com/daodst/mainnet/main/daodst_7777-1/peers.txt | sort -R | head -n 10 | awk '{print $1}' | paste -s -d, -`\n</code></pre> <p>Use <code>sed</code> to include them into the configuration. You can also add them manually:</p> <pre><code>sed -i.bak -e \"s/^persistent_peers *=.*/persistent_peers = \\\"$PEERS\\\"/\" $install_path/.stcd/config/config.toml\n</code></pre>"},{"location":"gateway/mainnet/#run-mainnet-validator","title":"Run mainnet validator","text":"<p>\ud83d\udce3 Tips: For more details on how to run a validator, follow the validator these instruct.</p> <pre><code>stcd tx staking create-validator \\\n--amount=1000000000000dst \\\n--pubkey=$(stcd tendermint show-validator) \\\n--moniker=\"Daodst1\" \\\n--chain-id=&lt;chain_id&gt; \\\n--commission-rate=\"0.05\" \\\n--commission-max-rate=\"0.20\" \\\n--commission-max-change-rate=\"0.01\" \\\n--min-self-delegation=\"1000000\" \\\n--gas=\"auto\" \\\n--gas-prices=\"0.025dst\" \\\n--from=&lt;key_name&gt;\n</code></pre> <p>\ud83d\udea8 DANGER: NEVER create validator keys using <code>test</code> as the keyring backend. Doing so may cause your funds to be accessed remotely via the <code>eth_sendTransaction</code> JSON-RPC endpoint, resulting in loss of funds.</p> <p>Reference: Security Advisory: Insecurely configured geth can make funds remotely accessible</p>"},{"location":"gateway/mainnet/#start-the-mainnet","title":"Start the mainnet","text":"<p>The last step is to start the node. Once enough voting power (+2/3) Starting from the genesis validator, nodes will start producing blocks.</p> <pre><code>stcd daemon\n</code></pre>"},{"location":"gateway/mainnet/#share-your-node","title":"Share your node","text":"<p>You can share your peers and post them in the <code>#find-peers</code> channel on the Daodst Discord.</p> <p>\ud83d\udce3 Hint: To get your node ID, use</p> <pre><code>stcd tendermint show-node-id\n</code></pre>"},{"location":"gateway/mainnet/#state-synchronization-node","title":"State synchronization node","text":"<p>If you want to join the network using state-sync (fast, but not for archive nodes), check out our state-sync page.</p>"},{"location":"gateway/mempool/","title":"memory pool","text":"<p>Learn about the memory pool options available in Tendermint.</p>"},{"location":"gateway/mempool/#first-in-first-out-memory-pool","title":"First in first out memory pool","text":"<p>The mempool holds uncommitted transactions, which have not yet been included in a block. The default mempool implementation of the Tendermint blockchain follows the first-in-first-out (FIFO) principle, meaning that the order of transactions is determined only by the order in which they arrive at nodes. The first transaction received will be the first transaction to be processed. This works for gossiping received transactions to other nodes and including them in a block.</p>"},{"location":"gateway/mempool/#priority-memory-pool","title":"Priority memory pool","text":"<p>From Tendermint v0.35 (Also backported to v0.34.20) This can be achieved using a priority memory pool. This allows validators to select transactions based on associated fees or other incentives. It does this by passing a <code>priority</code> field for each <code>CheckTx</code> response , It operates on any transaction trying to enter the mempool.</p> <p>daodst supports EIP-1559 through its EVM transactions. This transaction type uses a base fee and an optional priority tip, which add up to the total transaction fee. Priority memory pools provide an option to automatically use this mechanism for block generation.</p> <p>When using a priority mempool, the next transaction to generate a block is selected in order of priority (i.e. fee) from high to low. If the mempool is full, the priority implementation allows the lowest priority transactions to be dropped until enough disk space is available for incoming, higher priority transactions (see v1/mempool.go for more details).</p> <p>\ud83d\udce3 Tip: Although transactions can be prioritized, transaction gossip will always be FIFO.</p>"},{"location":"gateway/mempool/#configuration","title":"configuration","text":"<p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p> <p>To use the preferred mempool, adjust <code>version = \"v1\"</code> in your node configuration in <code>$install_path/.stcd/config/config.toml</code>. The default value <code>v0</code> means a traditional FIFO memory pool.</p> <p>\ud83d\udce3 Tip: Remember to restart the node for the changes to take effect.</p> <p>See the relevant excerpt from <code>config.toml</code> here:</p> <pre><code>#######################################################\n###          Mempool Configuration Option          ###\n#######################################################\n[mempool]\n\n# Mempool version to use:\n#   1) \"v0\" - (default) FIFO mempool.\n#   2) \"v1\" - prioritized mempool.\nversion = \"v1\"\n</code></pre>"},{"location":"gateway/mempool/#resource","title":"resource","text":"<p>More detailed information can be found here:</p> <ul> <li>Tendermint ADR-067 - Mempool Refactor.</li> <li>Blogpost: Tendermint v0.35 Announcement</li> <li>EIP-1559: Fee market change for ETH 1.0 chain</li> <li>EIP-1559 FAQ</li> <li>Blogpost: What is EIP-1559? How will it change Ethereum?</li> </ul>"},{"location":"gateway/run/","title":"run validator","text":"<p>Learn how to run a validator node.</p>"},{"location":"gateway/run/#prerequisites","title":"prerequisites","text":"<ul> <li>Validator Overview</li> <li>validator-security</li> </ul> <p>\ud83d\udce3 Tips: If you plan to use a Key Management System (KMS), you should first complete the following steps: Use KMS.</p>"},{"location":"gateway/run/#create-your-validator","title":"Create your validator","text":"<p>Your node consensus public key (<code>dstvalconspub...</code>) can be used to create new validators by staking FM tokens. You can find your validator public key by running:</p> <pre><code>stcd tendermint show-validator\n</code></pre> <p>\ud83d\udea8 DANGER: NEVER use the <code>test</code> keying backend to create your mainnet validator keys. Doing so may cause your funds to be accessed remotely via the <code>eth_sendTransaction</code> JSON-RPC endpoint, resulting in loss of funds.</p> <p>Ref: Security Alert: Insecurely configured geth can make funds remotely</p> <p>To create a validator on the testnet, simply use the following command:</p> <pre><code>stcd tx staking create-validator \\\n  --amount=100000000000000000000dst \\\n  --pubkey=$(stcd tendermint show-validator) \\\n  --moniker=\"choose a moniker\" \\\n  --chain-id=&lt;chain_id&gt; \\\n  --commission-rate=\"0.05\" \\\n  --commission-max-rate=\"0.10\" \\\n  --commission-max-change-rate=\"0.01\" \\\n  --min-self-delegation=\"1000000\" \\\n  --gas=\"auto\" \\\n  --gas-prices=\"0.025dst\" \\\n  --from=&lt;key_name&gt;\n</code></pre> <p>\ud83d\udce3 Tip: When specifying commission parameters, <code>commission-max-change-rate</code> is used to measure % point change relative to <code>commission-rate</code>. For example. 1% to 2% is 100% growth, but only 1 percentage point.</p> <p>\ud83d\udce3 Tip: <code>Min-self-delegation</code> is a strictly positive integer representing the minimum self-delegating voting power your validators must always have. <code>min-self-delegation</code> of <code>1000000000000000000</code> means that your validators can never self-delegate below <code>1 dst</code></p> <p>You can use a third-party browser to confirm that you are in the validator set.</p>"},{"location":"gateway/run/#edit-validator-description","title":"Edit validator description","text":"<p>You can edit a validator's public description. This information is used to identify your validators and will be used by delegators to decide which validators to stake with. Make sure to provide input for each of the flags below. If no flag is included in the command, the field will default to empty (<code>--moniker</code> defaults to the machine name), if the field has never been set, or remain unchanged if it was set in the past.</p> <p> specifies the validator you are editing. If you choose not to include certain flags, remember that you must include the --from flag to identify which validators to update. <p><code>--identity</code> can be used to authenticate with systems like Keybase or UPort. When used with Keybase, <code>--identity</code> should be populated with a 16-digit string generated by the keybase.io account. This is an encrypted and secure method of verifying your identity across multiple online networks. The Keybase API allows us to retrieve your Keybase avatar. This is how you can add your logo to your validator profile.</p> <pre><code>stcd tx staking edit-validator\n  --moniker=\"choose a moniker\" \\\n  --website=\"https://daodst.com\" \\\n  --identity=6A0D65E29A4CBC8E \\\n  --details=\"To infinity and beyond!\" \\\n  --chain-id=&lt;chain_id&gt; \\\n  --gas=\"auto\" \\\n  --gas-prices=\"0.025dst\" \\\n  --from=&lt;key_name&gt; \\\n  --commission-rate=\"0.10\"\n</code></pre> <p>\u26a0\ufe0f NOTE: <code>commission-rate</code> value must comply with the following requirements:</p> <ul> <li>Must be between 0 and the validator's <code>commission-max-rate</code></li> <li>MUST NOT exceed the validator's <code>commission-max-change-rate</code>, which is the maximum percentage change rate per day. In other words, a validator can only change its commission once per day in the range <code>commission-max-change-rate</code>.</li> </ul>"},{"location":"gateway/run/#view-validator-description","title":"View validator description","text":"<p>Use this command to view the validator's information:</p> <pre><code>stcd query staking validator &lt;account_cosmos&gt;\n</code></pre>"},{"location":"gateway/run/#signing-info-track-validator-signing-information","title":"signing-info Track validator signing information","text":"<p>In order to keep track of past validator signatures, you can use the <code>signing-info</code> command:</p> <pre><code>stcd query slashing signing-info &lt;validator-pubkey&gt;\\\n   --chain-id=&lt;chain_id&gt;\n</code></pre>"},{"location":"gateway/run/#unjail-unjail-validator","title":"unjail unjail validator","text":"<p>When validators are \"jailed\" due to downtime, you must submit an <code>Unjail</code> transaction from your operator account to be able to receive block proposer rewards again (subject to regional fee distribution).</p> <pre><code>stcd tx slashing unjail \\\n   --from=&lt;key_name&gt; \\\n   --chain-id=&lt;chain_id&gt;\n</code></pre>"},{"location":"gateway/run/#verify-your-validator-is-running","title":"Verify your validator is running","text":"<p>If the following command returns nothing, your validator is active:</p> <pre><code>stcd query tendermint-validator-set | grep \"$(stcd tendermint show-address)\"\n</code></pre> <p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p> <p>You should now see your authenticator in one of the Daodst browsers. You are looking for the <code>bech32</code> encoded <code>address</code> in the <code>$install_path/.stcd/config/priv_validator.json</code> file.</p> <p>\u26a0\ufe0f NOTE To enter the validator set, you need to have more total voting power than the 100th validator.</p>"},{"location":"gateway/run/#stop-your-validator","title":"Stop your validator","text":"<p>Having your validators stop systematically and gracefully is useful when trying to perform routine maintenance or plan for an upcoming coordinated upgrade.</p> <p>You can do this by setting <code>halt-height</code> to the height you want the node to be closed at or by passing the <code>--halt-height</code> flag to <code>stcd</code>.</p> <p>After committing a block, the node will shut down with a zero exit code at the given height.</p>"},{"location":"gateway/run/#common-problem","title":"common problem","text":""},{"location":"gateway/run/#problem-1-my-validator-is-voting_power-0","title":"Problem #1: My validator is <code>voting_power: 0</code>","text":"<p>Your validator is in jail. If a validator does not vote for <code>500</code> out of the last <code>10000</code> blocks, or if they double-sign, the validator will be jailed, i.e. removed from the set of active validators.</p> <p>If you go to jail for downtime, you can give your voting power back to your validators. First, restart <code>stcd</code> if it is not running:</p> <pre><code>stcd daemon\n</code></pre> <p>Wait for your full nodes to catch up with the latest blocks. You can then unjail your validator Finally, check your validator again to see if your voting power is restored.</p> <pre><code>stcd status\n</code></pre> <p>You may notice that your voting rights are less than before. That's because you got cut for downtime!</p>"},{"location":"gateway/run/#problem-2-my-node-crashes-with-too-many-open-files","title":"Problem #2: My node crashes with <code>too many open files</code>","text":"<p>The default number of files (per process) that Linux can open is <code>1024</code>. <code>stcd</code> is known to open more than <code>1024</code> files. This causes the process to crash. A quick fix is to run <code>ulimit -n 40960</code> (increase the number of open files allowed), then restart the process with the <code>stcd daemon</code>. If you use <code>systemd</code> or another process manager to start <code>stcd</code>, this may require some configuration at that level. An example <code>systemd</code> file to fix this is as follows:</p> <pre><code># /etc/systemd/system/stcd.service\n[Unit]\nDescription=Daodst Chain Node\nAfter=network.target\n\n[Service]\nType=simple\nUser=ubuntu\nWorkingDirectory=/home/ubuntu\nExecStart=/home/ubuntu/go/bin/stcd start\nRestart=on-failure\nRestartSec=3\nLimitNOFILE=4096\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"gateway/security/","title":"Authenticator security checklist","text":"<p>Find below a security checklist survey for validator security measurements. Investigate managed data center and node setups and compare your results to the recommended best practices below.</p>"},{"location":"gateway/security/#general-controls-for-hosting-data-centers","title":"General controls for hosting data centers","text":"Control Classes Best Practice Notes Data Center Redundant Power Supply Data Center Redundant Cooling Data Center Redundant Network Data Center Physical Cage / Gated Access Data Center Remote Alarm Security Cameras"},{"location":"gateway/security/#node-settings","title":"node settings","text":"Control Classes Best Practice Notes General System Security Operating system is properly patched. The kernel is updated to the latest stable version. The node must run in x86_64 environment General System Security Automatic updates of the operating system are configured. Toolkits exist for automatic upgrades (e.g. auter, yum-cron, dnf-automatic, unattended-upgrades) General System Security Enables and enforces the security framework. SELinux / AppArmor / Tomoyo / Grsecurity enabled. General System Security No unsafe and unnecessary services installed. (e.g. telnet, rsh, inetd, etc... General System Security GRUB boot loader password configured. Grub2 configuration password General system security Root access to core system files only File directory security Make sure the directory \"~/.stcd\" is only accessible to the owner Binary Configuration The following settings in config.toml are recommended for performance and security - for sentry nodes: <code>max_num_inbound_peers = 500, max_num_outbound_peers = 50, flush_throttle_timeout = \"300ms\"</code> - for validator nodes : <code>max_num_inbound_peers = 100 , max_num_outbound_peers = 10, flush_throttle_timeout = \"100ms\"</code> Account Security and Remote Access The following password policies are enforced: no blank passwords; weak passwords are not allowed Account Security and Remote Access Enable the following SSH configurations: PermitRootLogin: <code>no</code>; PasswordAuthentication <code>no</code>; ChallengeResponseAuthentication <code>no</code>; Use PAM <code>yes</code>; AllowUsers <code>only necessary users</code>; AllowGroups <code>only necessary groups</code>. Networking Use speedtest for network throughput testing. A minimum upload speed of 5 Mbps and a download speed of at least 5 Mbps is recommended) Networking Enable host-based (such as iptables) or cloud-based (such as AWS Security Groups) firewalls to protect all relevant nodes. Remote management ports (eg SSH - TCP 22) should only be exposed to selected IPs and not the Internet. Overly permissive rules should not be set (for example, a broad port range of 1-65535 is allowed). For internal communication channels between nodes, they should be set with specific source and destination addresses. For Internet reachable nodes, set TCP 26656 as the only incoming port if possible. Networking Installing and implementing an intrusion detection/prevention system (e.g. Fail2Ban, Snort, OSSEC) Networking Set up a sentinel architecture to protect validators and firewall rules to limit direct internet access to them. Networking Remote Procedure Calls (RPC) provide sensitive operations and information that should not be exposed on the Internet. By default, RPC is turned on and only connections from <code>127.0.0.1</code> are allowed. Be extra careful if you need to allow RPCs from other IP addresses. Redundancy The hot standby node sets the same configuration as the primary node Redundancy Set up system monitoring and alerts to alert owners of anomalies"},{"location":"gateway/state-sync/","title":"state synchronization","text":"<p>Learn about Tendermint Core state synchronization and support provided by the Cosmos SDK.</p> <p>\ud83d\udce3 Tip: Just concerned about how to sync nodes with the network? Skip to this section.</p>"},{"location":"gateway/state-sync/#tendermint-core-state-synchronization","title":"Tendermint core state synchronization","text":"<p>State synchronization allows new nodes to join the network by taking a snapshot of the most recent state of the network, rather than fetching and replaying all historical blocks. Since the application state is smaller than all blocks combined, and restoring state is faster than replaying blocks, this reduces the time to sync with the network from days to minutes.</p> <p>This part of the document provides a brief overview of the Tendermint state synchronization protocol, and how nodes are synchronized. For more details, see the ABCI Application Guide and the ABCI Reference Documentation.</p>"},{"location":"gateway/state-sync/#state-synchronization-snapshot","title":"State synchronization snapshot","text":"<p>A guiding principle when designing Tendermint state synchronization is to provide as much flexibility as possible for applications. Therefore, Tendermint doesn't care what the snapshots contain, how they were taken or how they were restored. It is only concerned with discovering existing snapshots in the network, fetching them and passing them to the application via ABCI.</p> <p>Tendermint uses light client validation to check the final application hash of the restored application against the chain application hash, but any further validation must be done by the application itself during recovery.</p> <p>Snapshots consist of binary blocks of arbitrary format. Chunks cannot be larger than 16 MB, otherwise there is no limit. Snapshot Metadata, exchanged via ABCI and P2P, contains the following fields:</p> <ul> <li><code>height</code> (<code>uint64</code>): The height at which the snapshot was taken</li> <li><code>format</code> (<code>uint32</code>): Arbitrary application-specific format identifier (e.g. version)</li> <li><code>chunks</code> (<code>uint32</code>): number of binary chunks in the snapshot</li> <li><code>hash</code> (<code>bytes</code>): Arbitrary snapshot hash for comparing snapshots across nodes</li> <li><code>metadata</code> (<code>bytes</code>): Arbitrary binary snapshot metadata for use by the application</li> </ul> <p>The <code>format</code> field allows an application to change its snapshot format in a backwards-compatible manner by providing snapshots in multiple formats and choosing which formats to accept during restore.</p> <p>This is useful, for example, when changing the serialization or compression format: as a node may be able to provide a snapshot to a node running an older version, or use an old snapshot when starting with a newer version.</p> <p>The <code>hash</code> field contains an arbitrary snapshot hash. Snapshots with the same <code>metadata</code> fields (including <code>hash</code>) across nodes are considered to be the same, and <code>chunks</code> will be fetched from any of those nodes.</p> <p>The <code>hash</code> is trustless and not verified by Tendermint itself, which prevents unintentional non-determinism in snapshot generation.</p> <p><code>hash</code> can be verified by the application instead.</p> <p>The <code>metadata</code> field can contain any arbitrary metadata required by the application. For example, applications may wish to include block checksums to discard corrupt <code>chunks</code>, or Merkle proofs validates each block individually against the chain application hash. Snapshot <code>metadata</code> messages cannot exceed 4 MB in Protobuf encoded form.</p>"},{"location":"gateway/state-sync/#take-and-provide-snapshots","title":"Take and provide snapshots","text":"<p>To enable state synchronization, certain nodes in the network must take and provide snapshots. When a peer attempts a state sync, an existing Tendermint node will call the following ABCI method on the application to provide snapshot data to the peer:</p> <ul> <li><code>ListSnapshots</code>: Returns a list of available snapshots, along with metadata</li> <li><code>LoadSnapshotChunk</code>: returns binary chunk data</li> </ul> <p>Snapshots should generally be generated periodically, rather than on-demand: this improves state synchronization performance, since snapshot generation can be slow, and avoids a denial-of-service vector for attackers flooding nodes with such requests.</p> <p>Older snapshots can usually be deleted, but it may be useful to keep at least the two most recent snapshots to avoid deleting previous snapshots when the node recovers.</p> <p>It is entirely up to the application to decide how to take a snapshot, but it should strive to meet the following guarantees:</p> <ul> <li>async: Snapshot should not stop block processing, so it should happen asynchronously, eg. in a separate thread</li> <li>consistent: snapshots should be taken at isolated heights and should not be affected by concurrent writes, eg. Due to the block processing in the main thread</li> <li>Deterministic: For a given <code>height</code> and <code>format</code>, snapshot <code>chunks</code> and <code>metadata</code> should be the same (at byte level) for all nodes to ensure good availability of <code>chunks</code></li> </ul> <p>For example, this can be achieved as follows:</p> <ol> <li>Use a data store that supports transactions with snapshot isolation, such as RocksDB or BadgerDB.</li> <li>Start a read-only database transaction in the main thread after the block is committed.</li> <li>Pass the database transaction handle to the newly spawned thread.</li> <li>Iterate over all data items in a definite order (for example, sort by key)</li> <li>Serialize the data items (e.g. using Protobuf) and write them to a byte stream.</li> <li>Hash the byte stream and split it into fixed size chunks (say 10 MB)</li> <li>Store the chunks as separate files in the file system.</li> <li>Write snapshot metadata to database or file, including byte stream hash.</li> <li>Close the database transaction and exit the thread.</li> </ol> <p>Applications may also need to take additional steps, such as compressing data, validating blocks, generating proofs for incremental verification, and deleting old snapshots.</p>"},{"location":"gateway/state-sync/#restore-snapshot","title":"restore snapshot","text":"<p>When Tendermint starts, it checks to see if the local node has any state (i.e. whether <code>LastBlockHeight == 0</code>), and if not, it will start discovering snapshots over the P2P network. These snapshots will be made available to native applications via the following ABCI calls:</p> <ul> <li><code>OfferSnapshot(snapshot, apphash)</code>: Offer a discovered snapshot to the application</li> <li><code>ApplySnapshotChunk(index, chunk, sender)</code>: apply snapshot chunk</li> </ul> <p>The discovered snapshot is provided to the application, which can respond by accepting the snapshot, rejecting the snapshot, rejecting the format, rejecting the sender, aborting the state synchronization, etc.</p> <p>Once the snapshot is accepted, Tendermint will fetch blocks from available peers and apply them in order to the application, which can choose to accept blocks, refetch, reject snapshot, reject sender, abort state sync, etc.</p> <p>After all blocks are applied, Tendermint will call the <code>Info</code> ABCI method on the application and check the application hash and The height corresponds to the trusted value in the chain. It will then switch to fast sync for any remaining blocks (if enabled), before finally joining normal consensus operations.</p> <p>How snapshots are actually restored is entirely up to the application, but usually the opposite of how they were generated.</p> <p>Note, however, that Tendermint only verifies snapshots after all blocks have been restored, and will not reject any P2P peers on its own.</p> <p>As long as the trusted hash and application code are correct, it is impossible for an adversary to cause a state-sync node to have an incorrect state when joining consensus, but applications can counteract state-sync denial of service (e.g., by implementing incremental verification, denying invalid node).</p> <p>Note that state sync nodes will have a truncated block history from the height of the restored snapshot, there is currently no backfill of all block data. Networks should consider the wider implications and may wish to ensure that at least a few archiving nodes maintain full block history for auditability and backup purposes.</p>"},{"location":"gateway/state-sync/#cosmos-sdk-state-synchronization","title":"Cosmos SDK state synchronization","text":"<p>Cosmos SDK v0.40+ includes automatic support for state synchronization, so app developers just need to enable it to use. They will not need to implement the state sync protocol described in the above section on Tendermint themselves.</p>"},{"location":"gateway/state-sync/#state-synchronization-snapshot_1","title":"State synchronization snapshot","text":"<p>Tendermint Core handles most of the heavy lifting of discovering, exchanging, and validating state data for state synchronization, but applications must periodically take snapshots of their state, provide these snapshots to Tendermint via ABCI calls, and be able to resume these synchronizations when new nodes are created.</p> <p>The Cosmos SDK stores application state in a data store called IAVL, and each module can set its own IAVL store. At a fixed height interval (configurable), the Cosmos SDK will export the content of each store at that height, Protobuf-encode and compress it , and save it to the snapshot store on the local file system. Since IAVL preserves historical versions of the data, these snapshots can be generated concurrently with the execution of new blocks.</p> <p>Tendermint will fetch these snapshots via ABCI when a new node does a state sync.</p> <p>Note that only IAVL storage managed by the Cosmos SDK can be snapshotted. If an app stores additional data in an external data store, there is currently no mechanism to include these in the state sync snapshot, so apps cannot use automatic state sync via the SDK.</p> <p>However, as described in the ABCI documentation, one is free to implement the state-sync protocol itself.</p> <p>When a new node state syncs, Tendermint will take a snapshot from the peers in the network and serve it to the local (empty) application, which will import it into its IAVL storage.</p> <p>Tendermint then verifies the app's application hash against the main blockchain using a light client validation and proceeds to execute blocks as usual.</p> <p>Note that a state sync node will only restore the application state at the snapshot height and will not include historical data or historical blocks.</p>"},{"location":"gateway/state-sync/#enable-state-sync-snapshot","title":"Enable state sync snapshot","text":"<p>To enable state sync snapshots, an application using the CosmosSDK <code>BaseApp</code> needs to set up a snapshot store (with a database and a filesystem directory) and configure the snapshot interval and the number of historical snapshots to keep. A minimal example is as follows:</p> <pre><code>snapshotDir := filepath.Join(\n  cast.ToString(appOpts.Get(flags.FlagHome)), \"data\", \"snapshots\")\nsnapshotDB, err := sdk.NewLevelDB(\"metadata\", snapshotDir)\nif err != nil {\n  panic(err)\n}\nsnapshotStore, err := snapshots.NewStore(snapshotDB, snapshotDir)\nif err != nil {\n  panic(err)\n}\napp := baseapp.NewBaseApp(\n  \"app\", logger, db, txDecoder,\n  baseapp.SetSnapshotStore(snapshotStore),\n  baseapp.SetSnapshotInterval(cast.ToUint64(appOpts.Get(\n    server.FlagStateSyncSnapshotInterval))),\n  baseapp.SetSnapshotKeepRecent(cast.ToUint32(appOpts.Get(\n    server.FlagStateSyncSnapshotKeepRecent))),\n)\n</code></pre> <p>When the application is started with the appropriate flags, (e.g. <code>--state-sync.snapshot-interval 1000 --state-sync.snapshot-keep-recent 2</code>) it should take a snapshot and output a log message:</p> <pre><code>Creating state snapshot module=main height=3000\nCompleted state snapshot module=main height=3000 format=1\n</code></pre> <p>Note that the snapshot interval must currently be a multiple of <code>pruning-keep-every</code> (default 100) to prevent height clipping when snapshots are taken. It's also usually a good idea to keep at least the 2 most recent snapshots, so that when a node tries to use it for state synchronization, previous snapshots are not deleted.</p>"},{"location":"gateway/state-sync/#state-synchronization-node","title":"State synchronization node","text":"<p>\ud83d\udce3 Tip: Looking for a snapshot or archive node to sync your nodes? Check out this page.</p> <p>Once several nodes in the network have taken state sync snapshots, new nodes can join the network using state sync. To do this, the node should first be configured as usual, and the following information must be obtained for light client authentication:</p> <ul> <li>Two available RPC servers (at least)</li> <li>Confidence height</li> <li>Block ID hash with confidence height</li> </ul> <p>A trusted hash must be obtained from a trusted source (such as a block explorer), but the RPC server does not need to be trusted. Tendermint will use the hash to get the trusted application hash from the blockchain to verify the restored application snapshot. The application hash and corresponding height are the only information that can be trusted when restoring a snapshot. Everything else can be faked by an opponent.</p> <p>In this guide we use Ubuntu 20.04</p>"},{"location":"gateway/state-sync/#prepare-the-system","title":"Prepare the system","text":"<p>update system</p> <pre><code>sudo apt update -y\n</code></pre> <p>Upgrading the system</p> <pre><code>sudo apt upgrade -y\n</code></pre> <p>install dependencies</p> <pre><code>sudo apt-get install ca-certificates curl gnupg lsb-release make gcc git jq wget -y\n</code></pre> <p>Install Go</p> <pre><code>wget -q -O - https://raw.githubusercontent.com/canha/golang-tools-install-script/master/goinstall.sh | bash\nsource ~/.bashrc\n</code></pre> <p>set node name</p> <pre><code>moniker=\"NODE_NAME\"\n</code></pre>"},{"location":"gateway/state-sync/#use-the-following-commands-for-mainnet-settings","title":"Use the following commands for mainnet settings","text":"<pre><code>SNAP_RPC1=\"http://xxx1:26657\"\nSNAP_RPC=\"http://xxx:26657\"\nCHAIN_ID=\"daodst_7777-1\"\nPEER=\"96557e26aabf3b23e8ff5282d03196892a7776fc@xxx,dec587d55ff38827ebc6312cedda6085c59683b6@xxx\"\nwget -O $HOME/genesis.json https://raw.githubusercontent.com/daodst/mainnet/genesis.json\n</code></pre>"},{"location":"gateway/state-sync/#install-stcd","title":"Install stcd","text":"<pre><code>git clone https://github.com/daodst/blockchain.git &amp;&amp; \\\ncd cmd &amp;&amp; cd stcd\ngo build\n</code></pre>"},{"location":"gateway/state-sync/#configuration","title":"configuration","text":"<p>node initialization</p> <pre><code>stcd init $moniker --chain-id $CHAIN_ID\n</code></pre> <p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p> <p>Move the genesis file to the $install_path/.stcd/config folder</p> <pre><code>mv $HOME/genesis.json $install_path/.stcd/config/\n</code></pre> <p>reset node</p> <pre><code>stcd tendermint unsafe-reset-all --home .stcd\n</code></pre> <p>Change config file (set node name, add persistent peer, set indexer=\"null\")</p> <pre><code>sed -i -e \"s%^moniker *=.*%moniker = \\\"$moniker\\\"%; \" $install_path/.stcd/config/config.toml\nsed -i -e \"s%^indexer *=.*%indexer = \\\"null\\\"%; \" $install_path/.stcd/config/config.toml\nsed -i -e \"s%^persistent_peers *=.*%persistent_peers = \\\"$PEER\\\"%; \" $install_path/.stcd/config/config.toml\n</code></pre> <p>Set variables starting from snapshot</p> <pre><code>LATEST_HEIGHT=$(curl -s $SNAP_RPC/block | jq -r .result.block.header.height); \\\nBLOCK_HEIGHT=$((LATEST_HEIGHT - 2000)); \\\nTRUST_HASH=$(curl -s \"$SNAP_RPC/block?height=$BLOCK_HEIGHT\" | jq -r .result.block_id.hash)\n</code></pre> <p>examine</p> <pre><code>echo $LATEST_HEIGHT $BLOCK_HEIGHT $TRUST_HASH\n</code></pre> <p>Example output (numbers will vary):</p> <pre><code>376080 374080 F0C78FD4AE4DB5E76A298206AE3C602FF30668C521D753BB7C435771AEA47189\n</code></pre> <p>If the output is normal, the next step</p> <pre><code>sed -i.bak -E \"s|^(enable[[:space:]]+=[[:space:]]+).*$|\\1true| ; \\\n\ns|^(rpc_servers[[:space:]]+=[[:space:]]+).*$|\\1\\\"$SNAP_RPC,$SNAP_RPC1\\\"| ; \\\n\ns|^(trust_height[[:space:]]+=[[:space:]]+).*$|\\1$BLOCK_HEIGHT| ; \\\n\ns|^(trust_hash[[:space:]]+=[[:space:]]+).*$|\\1\\\"$TRUST_HASH\\\"| ; \\\n\ns|^(seeds[[:space:]]+=[[:space:]]+).*$|\\1\\\"\\\"|\" $install_path/.stcd/config/config.toml\n</code></pre>"},{"location":"gateway/state-sync/#create-stcd-service","title":"Create stcd service","text":"<pre><code>echo \"[Unit]\nDescription=Daodst Chain Node\nAfter=network.target\n#\n[Service]\nUser=$USER\nType=simple\nExecStart=$(which stcd) daemon\nRestart=on-failure\nLimitNOFILE=65535\n#\n[Install]\nWantedBy=multi-user.target\" &gt; $HOME/stcd.service; sudo mv $HOME/stcd.service /etc/systemd/system/\n</code></pre> <pre><code>sudo systemctl enable stcd.service &amp;&amp; sudo systemctl daemon-reload\n</code></pre>"},{"location":"gateway/state-sync/#run-stcd","title":"Run stcd","text":"<pre><code>sytemctl start stcd\n</code></pre>"},{"location":"gateway/state-sync/#check-logs","title":"Check logs","text":"<pre><code>journalctl -u stcd -f\n</code></pre> <p>When a node starts up, it will try to find a state sync snapshot in the network, and restore it:</p> <pre><code>Started node module=main nodeInfo=\"...\"\nDiscovering snapshots for 20s\nDiscovered new snapshot height=3000 format=1 hash=0F14A473\nDiscovered new snapshot height=2000 format=1 hash=C6209AF7\nOffering snapshot to ABCI app height=3000 format=1 hash=0F14A473\nSnapshot accepted, restoring height=3000 format=1 hash=0F14A473\nFetching snapshot chunk height=3000 format=1 chunk=0 total=3\nFetching snapshot chunk height=3000 format=1 chunk=1 total=3\nFetching snapshot chunk height=3000 format=1 chunk=2 total=3\nApplied snapshot chunk height=3000 format=1 chunk=0 total=3\nApplied snapshot chunk height=3000 format=1 chunk=1 total=3\nApplied snapshot chunk height=3000 format=1 chunk=2 total=3\nVerified ABCI app height=3000 appHash=F7D66BC9\nSnapshot restored height=3000 format=1 hash=0F14A473\nExecuted block height=3001 validTxs=16 invalidTxs=0\nCommitted state height=3001 txs=16 appHash=0FDBB0D5F\nExecuted block height=3002 validTxs=25 invalidTxs=0\nCommitted state height=3002 txs=25 appHash=40D12E4B3\n</code></pre> <p>Nodes are now in sync and join the network within seconds</p>"},{"location":"gateway/state-sync/#turn-off-state-synchronization-mode","title":"Turn off state synchronization mode","text":"<p>After the node is fully synced, use this command to turn off state sync mode to avoid problems with future node restarts!</p> <pre><code>sed -i.bak -E \"s|^(enable[[:space:]]+=[[:space:]]+).*$|\\1false|\" $install_path/.stcd/config/config.toml\n</code></pre> <p>\u26a0\ufe0f NOTE: The information contained in this document comes from Erik Grinaker, in particular his state synchronization guide Tendermint Core and the Cosmos SDK.</p>"},{"location":"gateway/testnet/","title":"testnet","text":"<p>This document outlines the steps to join an existing testnet.</p>"},{"location":"gateway/testnet/#select-a-testnet","title":"Select a testnet","text":"<p>You can specify the network to join by setting genesis file and seed node. </p> Testnet Chain ID Description Location Version Status <code>daodst_7000-1</code> daodst Testnet Arsia Mons <code>v0.1.x</code> <code>active</code>"},{"location":"gateway/testnet/#install-stcd","title":"Install <code>stcd</code>","text":"<p>Follow the installation documentation to install program.</p> <p>\u26a0\ufe0f Note : Make sure you have the correct version of Program installed.</p>"},{"location":"gateway/testnet/#save-chain-id","title":"Save Chain ID","text":"<p>We recommend saving the testnet <code>chain-id</code> to your <code>client.toml</code>. This will save you from having to manually pass the <code>chain-id</code> flag for every CLI command.</p> <p>\ud83d\udce3 Tips: See the official chain IDs for reference.</p> <pre><code>stcd config chain-id daodst_7000-1\n</code></pre>"},{"location":"gateway/testnet/#initialize-node","title":"Initialize node","text":"<p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p> <p>We need to initialize the node to create all necessary validators and node configuration files:</p> <pre><code>stcd init &lt;your_custom_moniker&gt; --chain-id daodst_7000-4\n</code></pre> <p>\u26a0\ufe0f Note : A moniker can only contain ASCII characters. Using Unicode characters will make your node inaccessible.</p> <p>By default, the <code>init</code> command creates the <code>$install_path/.stcd</code> (ie <code>$HOME</code>) directory with subfolders <code>config/</code> and <code>data/</code>. In the <code>config</code> directory, the most important configuration files are <code>app.toml</code> and <code>config.toml</code>.</p>"},{"location":"gateway/testnet/#genesis-seeds","title":"Genesis &amp; Seeds","text":""},{"location":"gateway/testnet/#copy-the-genesis-file","title":"Copy the genesis file","text":"<p>Download the <code>genesis.json</code> file from <code>github</code> and copy it to the <code>config</code> directory: <code>$install_path/.stcd/config/genesis.json</code>. This is a genesis file that contains the chain ID and the balance of the genesis account.</p> <pre><code>sudo apt install -y unzip wget\nwget -P $install_path/.stcd/config https://github.com/daodst/testnets/daodst_7000-1/genesis.json\n</code></pre> <p>Then verify the correctness of the genesis configuration file:</p> <pre><code>stcd validate-genesis\n</code></pre>"},{"location":"gateway/testnet/#seeds","title":"seeds","text":"<p>Your peers need to know how to find peers. You need to add a healthy seed node to <code>$HOME/.stcd/config/config.toml</code> . The <code>testnets</code> repository contains pointers to some seed nodes.</p> <p>Edit the files located in <code>$install_path/.stcd/config/config.toml</code> and <code>seeds</code> to the following:</p> <pre><code>#################################################### #####\n### P2P Configuration Options ###\n#################################################### #####\n[p2p]\n\n#...\n\n# Comma separated list of seed nodes to connect to\nseeds = \"&lt;node-id&gt;@&lt;ip&gt;:&lt;p2p port&gt;\"\n</code></pre> <p>You can fetch a seed from the repository and add it to your config with the following code:</p> <pre><code>SEEDS=`curl -sL https://raw.githubusercontent.com/daodst/testnets/main/daodst_7000-1/seeds.txt | awk '{print $1}' | paste -s -d, -`\nsed -i.bak -e \"s/^seeds =.*/seeds = \\\"$SEEDS\\\"/\" ~/.stcd/config/config.toml\n</code></pre> <p>\ud83d\udce3 Tips: For more information on torrents and peers, you can visit the Tendermint P2P Documentation.</p>"},{"location":"gateway/testnet/#persistent_peers","title":"persistent_peers","text":"<p>We can set [<code>persistent_peers</code>] in <code>$install_path/.stcd/config/config.toml</code>(https://docs.tendermint.com/v0.34/tendermint-core/using-tendermint.html#persistent- peer) field. to specify the peers with which your node will maintain persistent connections. You can retrieve them from the list of available peers in the <code>testnets</code> repository.</p> <p>You can get 10 random entries from <code>peers.txt</code> by adding the file to the <code>PEERS</code> variable by running:</p> <pre><code>PEERS=`curl -sL https://raw.githubusercontent.com/daodst/testnets/main/daodst_7000-1/peers.txt | sort -R | head -n 10 | awk '{print $1}' | paste -s -d, -`\n</code></pre> <p>Use <code>sed</code> to include them into the configuration. You can also add them manually:</p> <pre><code>sed -i.bak -e \"s/^persistent_peers *=.*/persistent_peers = \\\"$PEERS\\\"/\" $install_path/.stcd/config/config.toml\n</code></pre>"},{"location":"gateway/testnet/#run-the-testnet-validator","title":"Run the testnet validator","text":"<p>Declare your testnet on faucet using your validator account address and submit your validator account address:</p> <p>\ud83d\udce3 Tips: For more details on how to run the validator, please follow these instructions.</p> <pre><code>stcd tx staking create-validator \\\n   --amount=1000000000000dst \\\n   --pubkey=$(stcd tendermint show-validator) \\\n   --moniker=\"Daodst1\" \\\n   --chain-id=&lt;chain_id&gt; \\\n   --commission-rate=\"0.10\" \\\n   --commission-max-rate=\"0.20\" \\\n   --commission-max-change-rate=\"0.01\" \\\n   --min-self-delegation=\"1000000\" \\\n   --gas=\"auto\" \\\n   --gas-prices=\"0.025dst\" \\\n   --from=&lt;key_name&gt;\n</code></pre>"},{"location":"gateway/testnet/#start-the-testnet","title":"Start the testnet","text":"<p>The last step is to start the node. Once enough voting power (+2/3) from genesis validators is up and running, the testnet will start producing blocks.</p> <pre><code>stcd daemon\n</code></pre>"},{"location":"gateway/testnet/#upgrade-your-node","title":"Upgrade your node","text":"<p>\ud83d\udce3 Tip : These instructions are for full nodes who are already running on a previous version and want to upgrade to the latest testnet version.</p> <p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p>"},{"location":"gateway/testnet/#reset-data","title":"Reset Data","text":"<p>\u26a0\ufe0f Note : If the version  you are upgrading to does not conflict with the previous version, you should not reset the data. If this is the case, you can skip to Restart <p>First, delete obsolete files and reset data.</p> <pre><code>rm $install_path/.stcd/config/addrbook.json $install_path/.stcd/config/genesis.json\nstcd tendermint unsafe-reset-all --home $install_path/.stcd\n</code></pre> <p>Your node is now in pristine state, while keeping the original <code>priv_validator.json</code> and <code>config.toml</code>. If you previously set up any sentinel nodes or full nodes, your nodes will still attempt to connect to them, but may fail if they have not been upgraded.</p> <p>\u26a0\ufe0f Note : Make sure each node has a unique <code>priv_validator.json</code>. Do not copy <code>priv_validator.json</code> from old nodes to multiple new nodes. Running two nodes with the same <code>priv_validator.json</code> will cause you to double sign.</p>"},{"location":"gateway/testnet/#restart","title":"restart","text":"<p>To restart your node, just type:</p> <pre><code>stcd daemon\n</code></pre>"},{"location":"gateway/testnet/#share-your-node-information","title":"Share your node information","text":"<p>You can share your companions on the Internet and publish them.</p> <p>\ud83d\udce3 Tips: To get your node ID, use</p> <pre><code>stcd tendermint show-node-id\n</code></pre>"},{"location":"gateway/testnet/#state-synchronization-node","title":"State synchronization node","text":"<p>If you want to join the network using state-sync (fast, but not for archive nodes), check out our state-sync page</p>"},{"location":"protocol/account/","title":"account","text":"<p>Crypto wallets (or accounts) can be created and represented in unique ways on different blockchains. For developers interacting with account types on Daodst, during wallet integration on their dApp frontend, it is important to understand that accounts on Daodst are implemented to be compatible with Ethereum type addresses.</p>"},{"location":"protocol/account/#create-an-account","title":"Create an account","text":"<p>To create an account, you create a private key, a keystore file (a password-protected private key), or a seed phrase (a string of words that gives access to multiple private keys).</p> <p>Besides having different security features, the biggest difference between them is that the private key or keystore file only creates an account. Creating a seed phrase can give you control over many accounts, all of which can be accessed using the same phrase.</p> <p>The Cosmos blockchain, like Daodst, supports account creation using mnemonic phrases, also known as Hierarchical Deterministic Key Generation (HD Keys). This allows users to create accounts on multiple blockchains without having to manage multiple keys.</p> <p>HD keys generate addresses by taking a mnemonic phrase and combining it with a piece of information called a derivation path. Blockchains can differ in the derivation paths they support. Therefore, to access all accounts via a mnemonic phrase on a blockchain, it is important to use a specific derivation path for that blockchain.</p>"},{"location":"protocol/account/#proxy-account","title":"Proxy account","text":"<p>The terms 'account' and 'address' are often used interchangeably to describe crypto wallets. In the Cosmos SDK, an account specifies a pair of public key (PubKey) and private key (PrivKey). Derivation paths define private keys, public keys, and addresses.</p> <p>A PubKey can be derived to generate various addresses in different formats, which are used to identify users (among other parties) within the application. A common address form for Cosmos chains is the bech32 format (eg dst1 ...). Addresses are also associated with messages to identify the sender of the message.</p> <p>A PrivKey is used to generate a digital signature attesting that the address associated with the PrivKey approves a given message. Attestation is performed by applying a cryptographic scheme called the Elliptic Curve Digital Signature Algorithm (ECDSA) to the PrivKey to generate a public key that is compared to the address in the message.</p>"},{"location":"protocol/account/#daodst-account","title":"Daodst Account","text":"<p>Daodst defines its own custom account type to implement HD wallet compatible with Ethereum type addresses. It uses Ethereum's ECDSA secp256k1 curve as the key (eth_secp265k1) and satisfies the full BIP44 path of EIP84. Do not confuse this cryptographic curve with Bitcoin's ECDSA secp256k1 curve.</p> <p>The root HD path for Daodst based accounts is <code>m/44'/60'/0'/0</code>. Daodst uses Coin type 60 to support Ethereum type accounts, unlike many other Cosmos chains which use Coin type 118 (list of coin types</p> <p>The custom Daodst EthAccount satisfies the AccountI interface from the Cosmos SDK authentication module and contains additional fields required for Ethereum type addresses:</p> <pre><code>// EthAccountI represents the interface of an Daodst compatible account\ntype EthAccountI interface {\n    authtypes.AccountI\n    // EthAddress returns the ethereum Address representation of the AccAddress\n    EthAddress() common.Address\n    // CodeHash is the keccak256 hash of the contract code (if any)\n    GetCodeHash() common.Hash\n    // SetCodeHash sets the code hash to the account fields\n    SetCodeHash(code common.Hash) error\n    // Type returns the type of Ethereum Account (EOA or Contract)\n    Type() int8\n}\n</code></pre>"},{"location":"protocol/account/#address-and-public-key","title":"address and public key","text":"<p>BIP-0173 defines a new format for Segregated Witness output addresses that includes a human-readable portion identifying Bech32 usage. Daodst uses the following HRPs (human-readable prefixes) as base HRPs:</p> Network Mainnet Testnet Daodst dst dst <p>There are 3 main types of HRP for addresses/public keys available by default on Daodst:</p> <ul> <li>The account's address and key, which identify the user (such as the sender of a message). They are derived using the eth_secp256k1 curve.</li> <li>The validator operator's address and key, used to identify the validator's operator. They are derived using the eth_secp256k1 curve.</li> <li>The address and key of the consensus node, used to identify the verification nodes participating in the consensus. They are derived using the ed25519 curve</li> </ul> Name bech32 address prefix bech32 public key prefix curve address byte length public key byte length account dst dstpub eth_secp256k1 20 33 (compressed) Validator operations dstvaloper dstvaloperpub eth_secp256k1 20 33 (compressed) consensus node dstvalcons dstvalconspub ed25519 32"},{"location":"protocol/account/#customers-address-format","title":"Customer's address format","text":"<p>Eth account number can be represented in Bech32 (dst1...) and hexadecimal (0x...) formats for Ethereum's Web3 tooling compatibility.</p> <p>The Bech32 format is the default format for Cosmos-SDK queries and transactions via CLI and REST clients. On the other hand, the hexadecimal format is Ethereum common.Address represents Cosmos sdk.AccAddress.</p> <ul> <li>Address (Bech32): <code>dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw</code></li> <li>Address (EIP55 hexadecimal): <code>0x91defC7fE5603DFA8CC9B655cF5772459BF10c6f</code></li> <li>Compress public key: <code>{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2\"}</code></li> </ul>"},{"location":"protocol/account/#address-translation","title":"address translation","text":"<p>stcd debug addr  can be used to convert addresses between hexadecimal and bech32 formats. For example: Bech32 <pre><code>  $ stcd debug addr dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw\n   Address: [20 87 74 109 255 45 223 158 7 130 139 67 69 211 4 9 25 175 86 82]\n   Address (hex): 14574A6DFF2DDF9E07828B4345D3040919AF5652\n   Bech32 Acc: dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw\n   Bech32 Val: dstvaloper1z3t55m0l9h0eupuz3dp5t5cypyv674jjn4d6nn\n</code></pre> <p>Hex</p> <pre><code>  $ stcd debug addr 14574A6DFF2DDF9E07828B4345D3040919AF5652\n   Address: [20 87 74 109 255 45 223 158 7 130 139 67 69 211 4 9 25 175 86 82]\n   Address (hex): 14574A6DFF2DDF9E07828B4345D3040919AF5652\n   Bech32 Acc: dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw\n   Bech32 Val: dstvaloper1z3t55m0l9h0eupuz3dp5t5cypyv674jjn4d6nn\n</code></pre>"},{"location":"protocol/account/#key-export","title":"Key export","text":"<p>We can use stcd's keys show command with the flags --bech  (acc|val|cons) to get addresses and keys, as described above, <p>Ordinary account</p> <pre><code>  $ stcd keys show dev0 --bech acc\n- name: dev0\n   type: local\n   address: dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw\n   pubkey: '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2\"}'\n   mnemonic: \"\"\n</code></pre> <p>validator</p> <pre><code>  $ stcd keys show dev0 --bech val\n- name: dev0\n   type: local\n   address: dstvaloper1z3t55m0l9h0eupuz3dp5t5cypyv674jjn4d6nn\n   pubkey: '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2\"}'\n   mnemonic: \"\"\n</code></pre> <p>consensus</p> <pre><code>  $ stcd keys show dev0 --bech cons\n- name: dev0\n   type: local\n   address: dstvalcons1rllqa5d97n6zyjhy6cnscc7zu30zjn3f7wyj2n\n   pubkey: '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"A/fVLgIqiLykFQxum96JkSOoTemrXD0tFaFQ1B0cpB2c\"}'\n   mnemonic: \"\"\n</code></pre>"},{"location":"protocol/account/#account-query","title":"Account query","text":"<p>You can use CLI, gRPC or</p> <p>command line interface</p> <pre><code># NOTE: the --output (-o) flag will define the output format in JSON or YAML (text)\nstcd q auth account $(stcd keys show dev0 -a) -o text\n\n'@type': /ethermint.types.v1.EthAccount\nbase_account:\naccount_number: \"0\"\naddress: dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw\npub_key:\n   '@type': /ethermint.crypto.v1.ethsecp256k1.PubKey\n   key: AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2\nsequence: \"1\"\ncode_hash: 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\n</code></pre> <p>Cosmos gRPC and REST</p> <pre><code># GET /cosmos/auth/v1beta1/accounts/{address}\ncurl -X GET \"http://localhost:10337/cosmos/auth/v1beta1/accounts/dst14au322k9munkmx5wrchz9q30juf5wjgz2cfqku\" -H \"accept: application/json\"\n</code></pre> <p>JSON-RPC To retrieve Ethereum hex addresses using Web3, use the JSON-RPC eth_accounts or personal_listAccounts endpoints</p> <pre><code># query against a local node\ncurl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_accounts\",\"params\":[],\"id\":1}' -H \"Content-Type: application/json\" http://localhost:8545\n\ncurl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"personal_listAccounts\",\"params\":[],\"id\":1}' -H \"Content-Type: application/json\" http://localhost:8545\n</code></pre>"},{"location":"protocol/chainid/","title":"chain ID","text":"<p>A chain ID is a unique identifier that represents a blockchain network. We use it to differentiate between different blockchain networks and ensure transactions and messages are sent to the correct network. Daodst network follows the format of identifier_EIP155-version.</p>"},{"location":"protocol/chainid/#mainnet","title":"Mainnet","text":"Name Chain ID Identifier EIP155 Number Version activation Daodst1 <code>daodst_7777-1</code> daodst 7777 1 yes"},{"location":"protocol/chainid/#testnet","title":"testnet","text":"Name Chain ID Identifier EIP155 Number Version activation Daodst Public Testnet <code>daodst_7000-1</code> daodst 7000 1 yes"},{"location":"protocol/chainid/#chain-identity","title":"chain identity","text":"<p>Every chain must have a unique identifier or <code>chain-id</code>. Tendermint requires each application to define its own <code>chain-id</code> in the genesis.json fields. However, in order to comply with both EIP155 and the Cosmos chain upgrade standard, Daodst-compatible chains must implement a special structure for their chain identifiers.</p>"},{"location":"protocol/chainid/#structure","title":"structure","text":"<p>The Daodst chain ID consists of 3 main components</p> <ul> <li>Identifier: An unstructured string defining the name of the application.</li> <li>EIP155 Number: Immutable EIP155 <code>CHAIN_ID</code>   Defines the number of replay attack protections.</li> <li>version number: is the version number of the chain currently running (always a positive number). This number MUST be incremented every time the chain is upgraded or forked to avoid network or consensus errors.</li> </ul>"},{"location":"protocol/chainid/#format","title":"Format","text":"<p>The format of the Daodst-compatible chain-id specified in genesis is as follows:</p> <pre><code>{identifier}_{EIP155}-{version}\n</code></pre> <p>The following table provides an example, where the second row corresponds to an upgrade of the first row:</p> ChainID Identifier EIP155 Number Version Number <code>daodst_7777-1</code> daodst 7777 1 <code>daodst_7777-2</code> daodst 7777 2 <code>...</code> ... ... ... <code>daodst_7777-N</code> daodst 7777 N"},{"location":"protocol/coin/","title":"token","text":""},{"location":"protocol/coin/#daodst-token","title":"DAODST Token","text":"<p>The denomination used for staking, governance, and gas consumption on the EVM is FM. FM provides the following utilities: securing proof-of-stake chains, tokens for governance proposals, distributing fees to validators and users, and as fuel for running smart contracts on the EVM.</p> <p>DAODST Assets are divided into three categories:</p> <ul> <li>Native FM, DST, HASH tokens</li> <li>IBC tokens (via IBC)</li> <li>Ethereum-type tokens, such as ERC-20</li> </ul>"},{"location":"protocol/coin/#cosmos-tokens","title":"Cosmos Tokens","text":"<p>Accounts can have Cosmos coins in their balances, which are used for operations and transactions with other Cosmos. Examples of these include staking with tokens, IBC transfers, governance deposits, and EVM.</p>"},{"location":"protocol/coin/#evm-token","title":"EVM token","text":"<p>Daodst is compatible with ERC20 tokens and other non-fungible token standards natively supported by EVM (EIP721, EIP1155).</p>"},{"location":"protocol/encode/","title":"encode","text":"<p>Encoding refers to the process of converting data from one format to another to make it more secure and efficient.</p> <p>In the context of blockchain, encoding is used to ensure that data is stored and transmitted in a secure and easily accessible manner.</p> <p>Recursive Length Prefix (RLP) is a serialization format widely used in Ethereum execution clients.</p> <p>Its purpose is to encode arbitrarily nested arrays of binary data, and is the primary encoding used to serialize objects in Ethereum.</p> <p>RLP only encodes structures, leaving the encoding of specific atomic data types (such as strings, integers, and floats) to higher-level protocols.</p> <p>In Ethereum, integers must be represented in big-endian binary form without leading zeros, such that an integer value of zero is equivalent to an empty byte array.</p> <p>The RLP encoding function accepts an item, which is defined as a single byte with a value in the range [0x00, 0x7f] or a string 0-55 bytes long.</p> <p>If the string is longer than 55 bytes, the RLP encoding contains a byte with the value 0xb7 (dec.183) plus the length The length of the string in bytes in binary, followed by the length of the string, followed by the string.</p> <p>RLP is used for hash verification, where a transaction is signed by signing the RLP hash of the transaction data, and a block is identified by the RLP hash of its header.</p> <p>RLP is also used to encode data over networks, and in some cases should support efficient encoding of Merkle tree data structures.</p> <p>The Ethereum execution layer uses RLP as the primary encoding for serializing objects, but the newer Simple Serialize (SSZ) replaces RLP as the encoding for the new consensus layer in Ethereum 2.0.</p> <p>The Cosmos Stargate release introduced protobuf as the primary encoding format for client and state serialization.</p> <p>All EVM module types for state and clients, such as transaction messages, genesis, query services, etc., will be implemented as protocol buffer messages.</p> <p>The Cosmos SDK also supports traditional Amino encoding.</p> <p>Protocol Buffers (protobuf) is a language-independent binary serialization format that is smaller and faster than JSON.</p> <p>It is used to serialize structured data, such as messages, and is designed to be efficient and scalable.</p> <p>The encoding format is defined in a language-independent language called Protocol Buffers Language (proto3), and encoded messages can be used to generate code for various programming languages.</p> <p>The main advantage of protobuf is its efficiency, which results in smaller message sizes and faster serialization and deserialization times.</p> <p>The RLP decoding process is as follows: decode the data type, actual data length and offset according to the first byte of the input data (that is, the prefix); decode the data accordingly according to the data type and offset.</p>"},{"location":"protocol/encode/#prerequisites-reading","title":"Prerequisites Reading","text":"<ul> <li>Cosmos SDK Encoding</li> <li>Ethereum RLP</li> </ul>"},{"location":"protocol/encode/#encoding-format","title":"Encoding format","text":"<p> Protocol Buffers </p> <p>The Cosmos Stargate release introduces protobuf as the primary encoding format for client and state serialization.</p> <p>All EVM module types for state and clients (transaction messages, genesis, query services, etc.) will be implemented as protocol buffer messages.</p> <p> Amino </p> <p>The Cosmos SDK also supports the legacy Amino encoding format for backward compatibility with previous versions, especially for client-side encoding and signing with Ledger devices.</p> <p>Daodst does not support Amino in the EVM module, but all other Cosmos SDK modules that enable it do.</p> <p> RLP </p> <p>Recursive Length Prefix (RLP) is an encoding/decoding algorithm that serializes messages and allows fast reconstruction of encoded data.</p> <p>Daodst uses RLP to encode/decode Ethereum messages for JSON-RPC processing so that messages conform to the correct Ethereum format. This allows messages to be encoded and decoded in the exact same format as Ethereum's.</p> <p><code>x/evm</code> transaction (<code>MsgEthereumTx</code>) encoding is performed by converting the message to go-ethereum's <code>Transaction</code> and then using RLP to marshal the transaction data:</p> <pre><code>// TxEncoder overwrites sdk.TxEncoder to support MsgEthereumTx\nfunc (g txConfig) TxEncoder() sdk.TxEncoder {\nreturn func(tx sdk.Tx) ([]byte, error) {\n  msg, ok := tx.(*evmtypes.MsgEthereumTx)\n  if ok {\n    return msg.AsTransaction().MarshalBinary()\n  }\n  return g.TxConfig.TxEncoder()(tx)\n}\n}\n\n// TxDecoder overwrites sdk.TxDecoder to support MsgEthereumTx\nfunc (g txConfig) TxDecoder() sdk.TxDecoder {\nreturn func(txBytes []byte) (sdk.Tx, error) {\n  tx := &amp;ethtypes.Transaction{}\n\n  err := tx.UnmarshalBinary(txBytes)\n  if err == nil {\n    msg := &amp;evmtypes.MsgEthereumTx{}\n    msg.FromEthereumTx(tx)\n    return msg, nil\n  }\n\n  return g.TxConfig.TxDecoder()(txBytes)\n}\n}\n</code></pre>"},{"location":"protocol/gas/","title":"Gas and fees","text":"<p>Users need to pay fees to submit transactions on the Daodst network. Since fees are handled differently in Ethereum and Cosmos, it is important to understand how the Daodst blockchain implements Ethereum-type fee calculations that are compatible with the Cosmos SDK.</p> <p>Thus, this overview explains the basics of gas calculations, how fees are provided for transactions, and how Ethereum-style fee calculations use the fee market (EIP1559) to prioritize transactions.</p> <p>Also note that fees paid for interacting with smart contracts on Daodst can earn revenue for smart contract deployers. For information on this, go to develop.</p>"},{"location":"protocol/gas/#prerequisites-to-read","title":"Prerequisites to read","text":"<ul> <li>Cosmos SDK Gas</li> <li>Ethereum Gas</li> </ul>"},{"location":"protocol/gas/#base","title":"Base","text":""},{"location":"protocol/gas/#why-is-there-a-transaction-fee","title":"Why is there a transaction fee?","text":"<p>If anyone could submit transactions to the network for free, the network could be overwhelmed by a small number of participants sending fraudulent transactions to clog the network and make it non-functional.</p> <p>The solution to this problem is a concept called <code>gas</code>, which is the resource consumed throughout the execution of a transaction.</p> <p>In practice, each step of code execution consumes a small amount of gas, effectively charging validator resource usage and preventing malicious actors from disrupting the network at will.</p>"},{"location":"protocol/gas/#what-is-gas","title":"What is Gas?","text":"<p>In general, gas is a unit of measure for the computational intensity of a particular transaction \u2014 in other words, how much work is required to evaluate and execute it.</p> <p>Complex multi-step transactions, such as a Cosmos transaction that delegates to a dozen validators, require more gas than simple single-step transactions (such as a Cosmos transaction that sends tokens to another address).</p> <p>When referring to a transaction, <code>gas</code> refers to the total amount of gas required for the transaction.</p> <p>For example, a transaction may require 300,000 units of gas to execute.</p> <p>Think of gas as electricity (kWh) in a house or factory, or as fuel for a car.</p> <p>The idea is that it costs some money to get somewhere.</p> <p>More Gas introduction:</p> <ul> <li>Cosmos Gas Fees</li> <li>Cosmos Tx Lifecycle</li> <li>Ethereum Gas</li> </ul>"},{"location":"protocol/gas/#how-to-calculate-gas","title":"How to calculate Gas","text":"<p>In general, there is no way to know exactly how much gas a transaction will cost without simply running it.</p> <p>Using the Cosmos SDK, this can be done with Simulating a Tx.</p> <p>Otherwise, there are ways to estimate the gas a transaction will require based on details of the transaction fields and data.</p> <p>For example, in the case of the EVM, each bytecode operation has a corresponding amount of gas.</p> <p>More about Gas calculation:</p> <ul> <li>Estimate Gas</li> <li>Executing EVM Bytecode</li> <li>Simulate a Cosmos SDK Tx</li> </ul>"},{"location":"protocol/gas/#the-relationship-between-gas-and-handling-fee","title":"The relationship between Gas and handling fee?","text":"<p>Gas refers to the computational work required to perform it, while the fee refers to the amount of tokens you actually spend to execute the transaction.</p> <p>They are derived using the following formulas:</p> <pre><code>Total Fees = Gas * Gas Price (the price per unit of gas)\n</code></pre> <p>If <code>gas</code> is in kWh, then \"gas price\" will be the rate determined by your energy supplier in USD/kWh, and <code>fees</code> will be your bill.</p> <p>Like electricity, gas prices can fluctuate on a given day, depending on network traffic.</p> <p>More about Gas and Fees:</p> <ul> <li>Cosmos Gas and Fees</li> <li>Ethereum Gas and Fees</li> </ul>"},{"location":"protocol/gas/#how-does-cosmos-handle-transaction-fees","title":"How does Cosmos handle transaction fees?","text":"<p>Gas fees in Cosmos are relatively simple. As a user, you specify two fields:</p> <ol> <li>Corresponding to <code>GasLimit</code> of the execution gas limit, defined as <code>GasWanted</code></li> <li>One of <code>Fees</code> or <code>GasPrice</code>, which will be used to specify or calculate the transaction fee</li> </ol> <p>The node will fully consume the provided fee and then start executing the transaction. If the <code>GasLimit</code> is found to be insufficient during execution, the transaction will fail and any changes will be rolled back, the provided fee will not be refunded.</p> <p>Validators of Cosmos SDK-based chains can specify a \"minimum gas price\" that they will enforce when selecting transactions to include in a block.</p> <p>As a result, transactions with insufficient fees will experience delays or fail outright.</p> <p>At the beginning of each block, the previous block's fees are distributed to validators and delegators, after which they can be withdrawn and spent.</p>"},{"location":"protocol/gas/#how-to-handle-fees-on-ethereum","title":"How to handle fees on Ethereum?","text":"<p>Ethereum fees include multiple implementations introduced over time.</p> <p>Initially, the user will specify the <code>GasPrice</code> and <code>GasLimit</code> in the transaction - much like a Cosmos SDK transaction.</p> <p>Block proposers will receive the full gas fee from each transaction in the block, and they will choose which transactions to include accordingly.</p> <p>With the proposal EIP-1559 and the London hard fork, the gas calculation has changed.</p> <p>The above <code>GasPrice</code> is now split into two separate parts: <code>BaseFee</code> and <code>PriorityFee</code>.</p> <p><code>BaseFee</code> is automatically calculated based on the block size and will be destroyed once the block is mined.</p> <p><code>PriorityFee</code> is given to the proposer and represents a tip, or incentive for the proposer to include the transaction in a block.</p> <pre><code>Gas Price = Base Fee + Priority Fee\n</code></pre> <p>In a transaction, in addition to specifying a <code>gas_limit</code> as before, the user can specify a <code>max_fee_per_gas</code> corresponding to the total <code>GasPrice</code> and a <code>max_priority_fee_per_gas</code> corresponding to the maximum <code>PriorityFee</code>.</p> <p>All excess gas not required for execution is returned to the user.</p> <p>More about Ethereum fees:</p> <ul> <li>Gas Calculation Docs</li> <li>Proposal EIP-1559</li> </ul>"},{"location":"protocol/gas/#implementation","title":"Implementation","text":""},{"location":"protocol/gas/#how-to-deal-with-gas-and-fees-on-daodst","title":"How to deal with Gas and fees on Daodst?","text":"<p>Fundamentally, Daodst is a Cosmos SDK chain that enables EVM compatibility as part of a Cosmos SDK module. Due to this architecture, all EVM transactions are ultimately encoded as Cosmos SDK transactions and update the state managed by the Cosmos SDK. Since all transactions are represented as Cosmos SDK transactions, transaction fees can be at different execution layers.</p> <p>In fact, processing fees include standard Cosmos SDK logic, some Ethereum logic, and customDaodst logic. In most cases, fees are collected by the <code>fee_collector</code> module and then paid to validators and delegators. Some key differences are as follows:</p> <p>1.Fee Market Module</p> <p>To support EIP-1559 gas and fee calculations on Daodst's EVM layer, Daodst tracks the gas supplied for each block and uses it to calculate the base fee for future EVM transactions, enabling EIP-specified EVM dynamic fees and transaction prioritization Level -1559.</p> <p>For EVM transactions, each node bypasses its local <code>min-gas-prices</code> configuration and instead applies EIP-1559 fee logic - the gas price must simply be greater than the global <code>min-gas-price</code> and the block's <code>BaseFee</code>, the remainder is considered the priority tip.</p> <p>This allows validators to calculate Ethereum fees without applying the Cosmos SDK fee logic.</p> <p>Unlike Ethereum, the <code>BaseFee</code> on Daodst will not be destroyed, but distributed to validators and delegators</p> <p>Additionally, <code>BaseFee</code> is bounded by the global <code>min-gas-price</code> (currently, the global <code>min-gas-price</code> parameter is set to zero, although it can be updated via governance).</p> <p>2. EVM Gas refund</p> <p>Daodst refunds a small portion (at least 50% by default) of unspent gas for EVM transactions to approximate the current behavior on Ethereum.</p> <p>3. Income module</p> <p>Daodst develops the revenue module as a way to reward developers for creating useful dApps - any contract that registers with the Daodst revenue module rewards the contract developer with a small portion of transaction fees (currently 95% ). Validators and delegators earn the remainder.</p>"},{"location":"protocol/gas/#detailed-schedule","title":"Detailed schedule","text":"<ol> <li> <p>The node executes the previous block and runs the <code>EndBlock</code> hook * As part of this hook, the FeeMarket (EIP-1559) module tracks the total <code>TransientGasWanted</code> from transactions on that block.    This will be used for the <code>BaseFee</code> of the next block.</p> </li> <li> <p>Nodes receive transactions for subsequent blocks and gossip about these transactions to their peers *These can be sorted and prioritized by included fee price (EVM transactions using the EIP-1559 fee priority mechanism will be included in the next block</p> </li> <li> <p>The node runs the <code>BeginBlock</code> * FeeMarket module for the subsequent block to calculate the <code>BaseFee</code> to apply to this block using the total <code>GasWanted</code> from the previous block.</p> </li> <li> <p>Distribution module distributes The previous block's fee rewards to validators and delegators</p> </li> <li> <p>For each valid transaction to be included in this block, the node does the following:</p> </li> </ol> <p> They run an <code>AnteHandler</code> corresponding to the transaction type .</p> <p>This process:</p> <ol> <li>Perform basic transaction validation</li> <li>Verify that the provided fee is greater than the global and local minimum validator values and greater than the computed <code>BaseFee</code><ol> <li>(For Ethereum transactions) Preempting EVM transaction consumption gas</li> </ol> </li> <li>Deduct the user's transaction fee and transfer it to the <code>fee_collector</code> module</li> <li>Increase the <code>TransientGasWanted</code> in the current block to calculate the <code>BaseFee</code> of the next block</li> </ol> <p>Then, for standard Cosmos transactions, nodes</p> <ul> <li>Execute transactions and update status</li> <li>Transaction consumes gas</li> </ul> <p>For Ethereum transactions, nodes:</p> <ul> <li>Execute transactions and update status</li> <li>Calculates the gas used and compares it to the supplied gas, then refunds the remainder of the specified portion</li> <li> <p>If the transaction interacts with a registered smart contract, a small portion of the fee used as revenue is sent to the contract developer as part of the revenue module</p> </li> <li> <p>The node runs <code>EndBlock</code> for this block and stores the <code>GasWanted</code> of the block</p> </li> </ul>"},{"location":"protocol/gas/#detailed-practice","title":"Detailed practice","text":""},{"location":"protocol/gas/#cosmos-gas","title":"Cosmos <code>Gas</code>","text":"<p>In the Cosmos SDK, gas is mainly tracked in <code>GasMeter</code> and <code>BlockGasMeter</code>:</p> <ul> <li><code>GasMeter</code>: Tracks gas consumed during executions that lead to state transitions. It is reset every time a transaction is executed.</li> <li><code>BlockGasMeter</code>: Tracks gas consumed in a block and enforces gas not exceeding a predefined limit. This limit is defined in the Tendermint consensus parameters and can be changed through governance parameter change proposals.</li> </ul> <p>Since gas is priced in bytes, the same interaction with larger parameter values will cost more gas than smaller parameter values (unlike Ethereum's <code>uint256</code> values, Cosmos SDK values use Big.Int types, which are dynamically resized).</p> <p>More information on gas as part of the Cosmos SDK can be found here.</p>"},{"location":"protocol/gas/#match-evm-gas-consumption","title":"Match EVM Gas consumption","text":"<p>Daodst is an EVM compatible chain that supports Ethereum Web3 tools. For this reason, gas consumption must be comparable to other EVMs, most importantly Ethereum.</p> <p>The main difference between EVM and Cosmos state transitions is that the EVM uses a gas table for each opcode, Instead, Cosmos uses <code>GasConfig</code> to charge gas for each CRUD operation by setting a fixed per-byte cost for accessing the database.</p> <p>To match the gas consumed by the EVM, the gas consumption logic in the SDK is ignored, instead the gas consumed is calculated by subtracting the state transition remaining gas plus the refund from the gas limit defined on the message.</p> <p>To ignore the SDK's gas consumption, we reset the transaction <code>GasMeter</code> count to 0 and manually set it to the <code>gasUsed</code> value calculated by the EVM module at the end of execution.</p>"},{"location":"protocol/gas/#antehandler","title":"<code>AnteHandler</code>","text":"<p>The Cosmos SDK <code>AnteHandler</code> performs basic checks before transaction execution.</p> <p>These checks are typically signature verification, transaction field verification, transaction fees, etc.</p> <p>Regarding gas consumption and fees, <code>AnteHandler</code> checks that the user has enough balance to cover the tx cost (amount plus the fee), and checks that the gas limit defined in the message is greater than or equal to the computed intrinsic gas message.</p>"},{"location":"protocol/gas/#gas-return","title":"Gas Return","text":"<p>In EVM, gas can be specified before execution. The full amount of gas specified is consumed at the start of execution (during the <code>AnteHandler</code> step), if any gas remains after execution, the remaining gas will be refunded to the user.</p> <p>Additionally, the EVM can also define gas to be returned to the user, but these will be limited to a fraction of the gas used, depending on the fork/version used.</p>"},{"location":"protocol/gas/#zero-fee-transactions","title":"Zero Fee Transactions","text":"<p>In Cosmos, <code>AnteHandler</code> does not enforce minimum gas prices, because <code>min-gas-prices</code> are checked against local nodes/validators.</p> <p>In other words, the minimum fee accepted is determined by the validators of the network, and each validator can specify a different minimum value for their fee.</p> <p>This may allow end users to submit 0-fee transactions if at least one validator is willing to include a <code>0</code> gas price transaction in their proposed block.</p> <p>For the same reason, in Daodst it is possible to send transactions with a <code>0</code> fee for transaction types other than those defined by the <code>evm</code> module.</p> <p>EVM module transactions cannot have a \"0\" fee because the EVM itself requires gas.</p> <p>This check is done by the EVM transaction stateless validation (i.e. <code>ValidateBasic</code>) function as well as a custom <code>AnteHandler</code> defined by Daodst.</p>"},{"location":"protocol/gas/#gas-estimate","title":"Gas Estimate","text":"<p>Ethereum provides a JSON-RPC endpoint <code>eth_estimateGas</code> to help users set the correct gas limit in their transactions.</p> <p>Therefore, a specific query API <code>EstimateGas</code> is implemented in Daodst. It will apply the transaction against the current block/state and perform a binary search to find the best gas value to return to the user (the same transaction will be applied over and over until we find the minimum gas required before failing).</p> <p>The reason we need to use binary search is that the gas required by the transaction may be higher than the value returned by the EVM after applying the transaction, so we need to try until we find the optimal value.</p> <p>A cached context will be used throughout execution to avoid persisting changes in state.</p> <p>For Cosmos Tx, developers can use Cosmos SDK's transaction simulation to create accurate estimates.</p>"},{"location":"protocol/gas/#use-daodst-cli-to-process-gas-and-transaction-fees","title":"Use Daodst CLI to process Gas and transaction fees","text":"<p>Users should consider the available options when broadcasting transactions using the Daodst CLI client. There are three flags to consider when sending a transaction to the network:</p> <ul> <li><code>--fees</code>: Fees to pay with the transaction; eg: 10dst. Defaults to required fee.</li> <li><code>--gas</code>: Gas limit to set per transaction; default is 200000.</li> <li><code>--gas-prices</code>: gas prices to determine transaction fees (e.g. 10dst).</li> </ul> <p>However, not all of these need to be defined in every transaction. The correct combination is:</p> <ul> <li><code>--fees=auto</code>: Automatically estimate fees and gas (same behavior as --gas=auto ).   An error is thrown if any other fee-related flags are used (e.g. <code>--gas-prices</code>, <code>--fees</code>)</li> <li><code>--gas=auto</code>: Same behavior as <code>--fees=auto</code>.   An error is thrown if any other fee-related flags are used (e.g. <code>--gas-prices</code>, <code>--fees</code>)</li> <li><code>--gas={int}</code>: use the specified amount of gas and the transaction fee</li> <li><code>--fees={int}{denom}</code>: use the specified fee for tx. Use the gas default (200000) for tx.</li> <li><code>--fees={int}{denom} --gas={int}</code>: Use the specified gas and fee. Computes the gas-price using the provided parameters</li> <li><code>--gas-prices={int}{denom}</code>: Use provided gas prices and default gas amount (200000)</li> <li><code>--gas-prices={int}{denom} --gas={int}</code>: Use the gas specified for tx and calculate the price with the corresponding parameters.</li> </ul> <p>Readers should note that the first two options provide a more user-friendly experience for new users, while the latter are intended for more advanced users who want more control over these parameters.</p> <p>The team introduced the 'auto' flag option, which automatically calculates the gas and fees required to execute a transaction. In this way, new users or developers can execute transactions without defining specific gas and fee values.</p> <p>Using the <code>auto</code> flag may sometimes not estimate the correct gas and fees based on network traffic. To overcome this, you can use a higher value for the <code>--gas-adjustment</code> flag. By default it is set to <code>1.2</code>. When the estimate is insufficient, retry a higher gas adjustment, such as <code>--gas-adjustment 1.3</code>.</p> <p>The <code>--gas-prices</code> and <code>--fees</code> flags cannot be combined. If so, the user will receive an error message stating that fees and gas prices cannot be provided at the same time.</p> <p>Keep in mind that the above combo may fail if the fee or gas amount offered is insufficient. If this is the case, the CLI will return an error message with the specific reason. For example:</p> <pre><code>raw_log: 'out of gas in location: submit proposal; gasWanted: 200000, gasUsed: 263940.\n  Please retry with a gas (--gas flag) amount higher than gasUsed: out of gas'\n</code></pre>"},{"location":"protocol/key-management/","title":"Key Management","text":"<p>A mnemonic, also known as a mnemonic, is a set of words used to recover or recover a cryptocurrency wallet. It serves as a backup to access your digital assets if you lose access to the original wallet. This phrase is usually a series of 12-24 words generated when you created your wallet and should be kept safe and private.</p> <p>The importance of the seed phrase is that cryptocurrencies are stored in a decentralized manner, meaning that there is no central authority or institution that holds or controls your funds. This means that if you lose access to your wallet (e.g. forget your password, lose your device), you will not be able to get your funds back without your seed phrase. Therefore, it is crucial to store your seed phrase in a safe and secure place, such as physical paper or a secure digital file.</p> <p>Also, it is recommended to make multiple copies and store them in different locations so that you have access to your funds in case of any emergency.</p>"},{"location":"protocol/key-management/#mnemonic-phrase-and-private-key","title":"Mnemonic Phrase and Private Key","text":"<p>A seed phrase, also known as a recovery phrase or backup phrase, is a series of words used to generate a private key. It is usually a set of 12 or 24 words used to recover or restore access to a cryptocurrency wallet if the original private key is lost or damaged. The seed phrase can be used to generate multiple private keys that can be used to access multiple cryptocurrency addresses and balances.</p> <p>A private key, on the other hand, is a long string of characters that is used to sign transactions and provide access to your cryptocurrency funds. Private keys are generated from a seed phrase and are unique to each cryptocurrency address. It is used to create a digital signature for a transaction to ensure that the transaction is legitimate and has been authorized by the rightful owner of the funds.</p> <p>In conclusion, the security of your private key and seed phrase is paramount. If your private key is compromised, it could put all linked accounts at risk. However, losing the mnemonic phrase can have more serious consequences because it is used to generate multiple private keys. Therefore, it is crucial to take proper steps to protect your private key and seed phrase to avoid any catastrophic loss.</p>"},{"location":"protocol/key-management/#mnemonics-in-daodst-cli","title":"Mnemonics in Daodst CLI","text":"<p>Before proceeding with the CLI, make sure you have <code>stcd</code> installed. Installation instructions are located.</p> <p>When you create a new key, you receive a seed phrase that you can use to recover that key. Backup mnemonic:</p> <pre><code>stcd keys add dev0\n{\n  \"name\": \"dev0\",\n  \"type\": \"local\",\n  \"address\": \"dst1n253dl2tgyhxjm592p580c38r4dn8023ctv28d\",\n  \"pubkey\": '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"ArJhve4v5HkLm+F7ViASU/rAGx7YrwU4+XKV2MNJt+Cq\"}',\n  \"mnemonic\": \"\"\n}\n\n**Important** write this mnemonic phrase in a safe place.\nIt is the only way to recover your account if you ever forget your password.\n\n# &lt;24 word mnemonic phrase&gt;\n</code></pre> <p>To restore keys:</p> <pre><code>$ stcd keys add dev0-restored --recover\n&gt; Enter your bip39 mnemonic\nbanner genuine height east ghost oak toward reflect asset marble else explain foster car nest make van divide twice culture announce shuffle net peanut\n{\n  \"name\": \"dev0-restored\",\n  \"type\": \"local\",\n  \"address\": \"dst1n253dl2tgyhxjm592p580c38r4dn8023ctv28d\",\n  \"pubkey\": '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"ArJhve4v5HkLm+F7ViASU/rAGx7YrwU4+XKV2MNJt+Cq\"}'\n}\n</code></pre>"},{"location":"protocol/key-management/#key-export","title":"Key export","text":""},{"location":"protocol/key-management/#tendermint-private-key-format","title":"Tendermint-Private Key Format","text":"<p>To back up such a key without a mnemonic:</p> <pre><code>stcd keys export dev0\nEnter passphrase to decrypt your key:\nEnter passphrase to encrypt the exported key:\n-----BEGIN TENDERMINT PRIVATE KEY-----\nkdf: bcrypt\nsalt: 14559BB13D881A86E0F4D3872B8B2C82\ntype: secp256k1\n\n# &lt;Tendermint private key&gt;\n-----END TENDERMINT PRIVATE KEY-----\n\n$ echo \"\\\n-----BEGIN TENDERMINT PRIVATE KEY-----\nkdf: bcrypt\nsalt: 14559BB13D881A86E0F4D3872B8B2C82\ntype: secp256k1\n\n# &lt;Tendermint private key&gt;\n-----END TENDERMINT PRIVATE KEY-----\" &gt; dev0.export\n</code></pre>"},{"location":"protocol/key-management/#ethereum-private-key-format","title":"Ethereum-Private Key Format","text":"<p>NOTE: These types of keys are compatible with MetaMask</p> <p>To back up such a key without a mnemonic:</p> <pre><code>stcd keys unsafe-export-eth-key dev0 &gt; dev0.export\n**WARNING** this is an unsafe way to export your unencrypted private key, are you sure? [y/N]: y\nEnter keyring passphrase:\n</code></pre>"},{"location":"protocol/key-management/#key-import","title":"key import","text":""},{"location":"protocol/key-management/#tendermint-private-key-format_1","title":"Tendermint-Private Key Format","text":"<pre><code>$ stcd keys import dev0-imported ./dev0.export\nEnter passphrase to decrypt your key:\n</code></pre>"},{"location":"protocol/key-management/#ethereum-private-key-format_1","title":"Ethereum-Private Key Format","text":"<pre><code>$ stcd keys unsafe-import-eth-key dev0-imported ./dev0.export\nEnter passphrase to encrypt your key:\n</code></pre>"},{"location":"protocol/key-management/#verify","title":"verify","text":"<p>Verify that your key has been restored using the following command:</p> <pre><code>$ stcd keys list\n[\n  {\n    \"name\": \"dev0-imported\",\n    \"type\": \"local\",\n    \"address\": \"dst1n253dl2tgyhxjm592p580c38r4dn8023ctv28d\",\n    \"pubkey\": '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"ArJhve4v5HkLm+F7ViASU/rAGx7YrwU4+XKV2MNJt+Cq\"}'\n  },\n  {\n    \"name\": \"dev0-restored\",\n    \"type\": \"local\",\n    \"address\": \"dst1n253dl2tgyhxjm592p580c38r4dn8023ctv28d\",\n    \"pubkey\": '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"ArJhve4v5HkLm+F7ViASU/rAGx7YrwU4+XKV2MNJt+Cq\"}'\n  },\n  {\n    \"name\": \"dev0\",\n    \"type\": \"local\",\n    \"address\": \"dst1n253dl2tgyhxjm592p580c38r4dn8023ctv28d\",\n    \"pubkey\": '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"ArJhve4v5HkLm+F7ViASU/rAGx7YrwU4+XKV2MNJt+Cq\"}'\n  }\n]\n</code></pre>"},{"location":"protocol/keyring/","title":"Keyring Keyring","text":"<p>Create, import, export, and delete keys using the CLI keyring.</p> <p>The keyring holds private/public key pairs used to interact with nodes. For example, a validator key needs to be set up before running a node so that blocks can be properly signed. Private keys can be stored in various locations, called \"backends\", such as files or the operating system's own keystore.</p> <p>\ud83d\udce3 Tips: If you need a refresher on private keys and key management, please refer to our Key Management.</p>"},{"location":"protocol/keyring/#add-key","title":"Add key","text":"<p>You can get help on the <code>keys</code> command and more information on specific subcommands using the following command, respectively:</p> <pre><code>stcd keys\n</code></pre> <pre><code>stcd keys [command] --help\n</code></pre> <p>To create a new key in the keyring, run the <code>add</code> subcommand with the <code>&lt;key_name&gt;</code> argument. You will have to provide a password for newly generated keys. This key will be used in the next section.</p> <pre><code>stcd keys add dev0\n\n# Put the generated address in a variable for later use.\nMY_VALIDATOR_ADDRESS=$(stcd keys show dev0 -a)\n</code></pre> <p>This command generates a new 24-word mnemonic, persists it to the relevant backend, and outputs information about the key pair. If this key pair will be used to hold valuable tokens, be sure to write the seed phrase in a safe place!</p> <p>By default, keyring generates an <code>eth_secp256k1</code> key. Keyring also supports <code>ed25519</code> keys, which can be created by passing the <code>--algo</code> flag. A key ring can of course hold both types of keys.</p> <p>\ud83d\udce3 Tip: The Ethereum address associated with the public key can be derived by taking the full Ethereum public key of type <code>eth_secp256k1</code>, computing the <code>Keccak-256</code> hash, and truncating the first twelve bytes.</p> <p>\ud83d\udea8 DANGER: Daodst does not support Cosmos <code>secp256k1</code> keys due to compatibility issues with Ethereum transactions.</p>"},{"location":"protocol/keyring/#keyring-backend","title":"Keyring backend","text":""},{"location":"protocol/keyring/#os","title":"OS","text":"<p>\ud83d\udce3 Tips: <code>os</code> is the default option because the operating system's default credential manager is designed to meet the most common needs of users and provide them with a comfortable experience without compromising security.</p> <p>The <code>os</code> backend relies on OS-specific defaults to handle key storage securely. Typically, the operating system's credential subsystem handles password prompting, private key storage, and user sessions according to the user's password policy. Below is a list of the most popular operating systems and their respective password managers:</p> <ul> <li>macOS (since Mac OS 8.6): Keychain</li> <li>Windows: Credentials Management API</li> <li>GNU/Linux:</li> <li>libsecret</li> <li>kwallet</li> </ul> <p>GNU/Linux distributions that use GNOME as their default desktop environment usually come with Seahorse. Users of KDE-based distributions usually get the KDE Wallet Manager. The former is actually a convenient <code>libsecret</code> front-end, while the latter is a <code>kwallet</code> client.</p> <p>The recommended backends for headless environments are <code>file</code> and <code>pass</code>.</p>"},{"location":"protocol/keyring/#file","title":"File","text":"<p><code>file</code> stores the encrypted keyring in the application's configuration directory. The password is requested every time this keyring is accessed, which may occur multiple times in a single command, resulting in repeated password prompts. If using a bash script to execute commands via the <code>file</code> option, you may wish to use the following format for multiple prompts:</p> <pre><code># assuming that KEYPASSWD is set in the environment\nyes $KEYPASSWD | stcd keys add me\nyes $KEYPASSWD | stcd keys show me\n# start stcd with keyring-backend flag\nstcd --keyring-backend=file start\n</code></pre> <p>\ud83d\udce3 Tip: The first time you add a key to an empty keyring, you will be prompted for the passphrase twice.</p>"},{"location":"protocol/keyring/#pass","title":"Pass","text":"<p>The <code>pass</code> backend uses the pass utility to manage disk encryption of sensitive data and metadata for keys. Keys are stored in \"gpg\" encrypted files in application-specific directories. <code>pass</code> is available for most popular UNIX operating systems as well as GNU/Linux distributions. See its man page for how to download and install it.</p> <p>\ud83d\udce3 Hint: <code>pass</code> uses GnuPG for encryption. <code>gpg</code> automatically invokes the <code>gpg-agent</code> daemon upon execution, which handles the caching of GnuPG credentials. See the <code>gpg-agent</code> man page for more information on how to configure caching parameters such as credential TTL and password expiration.</p> <p>Password storage must be set up before first use:</p> <pre><code>pass init &lt;GPG_KEY_ID&gt;\n</code></pre> <p>Replace <code>&lt;GPG_KEY_ID&gt;</code> with your GPG key ID. You can use your personal GPG key or an alternative key that you might want to use specifically to encrypt password storage.</p>"},{"location":"protocol/keyring/#kwallet","title":"Kwallet","text":"<p>The <code>kwallet</code> backend uses <code>KDE Wallet Manager</code>, which is installed by default on GNU/Linux distributions with KDE as the default desktop environment. For more information, please refer to KWallet Manual.</p>"},{"location":"protocol/keyring/#testing","title":"Testing","text":"<p>The <code>test</code> backend is a passwordless variant of the <code>file</code> backend. Keys are stored on disk in unencrypted form. This keyring is for testing purposes only. Use at your own risk!</p> <p>\ud83d\udea8 DANGER: NEVER use the <code>test</code> keying backend to create your mainnet validator keys. Doing so may result in Remote access to your funds through the <code>eth_sendTransaction</code> JSON-RPC endpoint, resulting in loss of funds.</p>"},{"location":"protocol/keyring/#memory","title":"Memory","text":"<p>The <code>memory</code> backend stores keys in memory. The key will be deleted immediately after the program exits.</p> <p>\ud83d\udea8 DANGER: For testing purposes only. The <code>memory</code> backend is NOT recommended for production use. Use at your own risk!</p>"},{"location":"protocol/multsign/","title":"Multsignature","text":"<p>Learn how to generate, sign, and broadcast transactions using keyring multisig.</p> <p>Multi-signature account is a Dst account with a special key that requires multiple signatures to sign transactions. This is useful for increasing the security of an account or requiring multiple parties to agree to a transaction. A multi-signature account can be created by specifying:</p> <ul> <li>Threshold number of required signatures</li> <li>The public key involved in the signature</li> </ul> <p>To be signed with a multisig account, the transaction must be signed individually by a different key specified for that account. The signatures are then combined into a multisig that can be used to sign transactions. If the number of signatures present is less than the required threshold number, the resulting multisig is considered invalid.</p>"},{"location":"protocol/multsign/#generate-a-multi-signature-key-pair","title":"Generate a multi-signature key pair","text":"<pre><code>stcd keys add --multisig=name1,name2,name3[...] --multisig-threshold=K new_key_name\n</code></pre> <p><code>K</code> is the minimum number of private keys that must sign a transaction with a public key address as a signer.</p> <p>The <code>--multisig</code> flag must contain the names of the public keys that will be combined into a single public key that will be generated and stored in the local database as <code>new_key_name</code>.</p> <p>All names provided via <code>--multisig</code> must already exist in the local database.</p> <p>The order in which keys are provided on the command line does not matter unless the flag <code>--nosort</code> is set, i.e. the following command produces two identical keys:</p> <pre><code>stcd keys add --multisig=p1,p2,p3 --multisig-threshold=2 multisig_address\nstcd keys add --multisig=p2,p3,p1 --multisig-threshold=2 multisig_address\n</code></pre> <p>Multisig addresses can also be generated on the fly and printed via the which command:</p> <pre><code>stcd keys show --multisig-threshold=K name1 name2 name3 [...]\n</code></pre>"},{"location":"protocol/multsign/#sign-transaction","title":"Sign transaction","text":""},{"location":"protocol/multsign/#step-1-create-a-multi-signature-key","title":"Step 1: Create a multi-signature key","text":"<p>Suppose you have <code>test1</code> and <code>test2</code> and want to create a multisignature account using <code>test3</code>.</p> <p>First import the public key of <code>test3</code> into your keyring.</p> <pre><code>stcd keys add \\\n     test3\\\n     --pubkey=dstpub1addwnpepqgcxazmq6wgt2j4rdfumsfwla0zfk8e5sws3p3zg5dkm9007hmfysxas0u2\n</code></pre> <p>Generate a multi-signature key with a 2/3 threshold.</p> <pre><code>stcd keys add \\\n     multi \\\n     --multisig=test1,test2,test3 \\\n     --multisig-threshold=2\n</code></pre> <p>You can see its address and details:</p> <pre><code>stcd keys show multi\n\n- name: multi\n   type: multi\n   address: dst1e0fx0q9meawrcq7fmma9x60gk35lpr4xk3884m\n   pubkey: dstpub1ytql0csgqgfzd666axrjzq3mxw59ys6yqcd3ydjvhgs0uzs6kdk5fp4t73gmkl8t6y02yfq7tvfzd666axrjzq3sd69kp5usk492x6nehqjal67ynv0nfqapzrz y3gmdk27la0kjfqfzd666axrjzq6utqt639ka2j3xkncgk65dup06t297ccljmxhvhu3rmk92u3afjuyz9dg9\n   mnemonic: \"\"\n   threshold: 0\n   pubkeys: []\n</code></pre> <p>Let's add 10 DST to the multisig wallet:</p> <pre><code>stcd tx bank send \\\n     test1\\\n     dst1e0fx0q9meawrcq7fmma9x60gk35lpr4xk3884m\\\n     100000000000000000000dst\\\n     --chain-id=daodst_7000-1 \\\n     --gas=auto \\\n     --fees=1000000dst \\\n     --broadcast-mode=block\n</code></pre>"},{"location":"protocol/multsign/#step-2-create-a-multi-signature-transaction","title":"Step 2: Create a multi-signature transaction","text":"<p>We want to send 5 DST from our multisig account to <code>dst1rgjxswhuxhcrhmyxlval0qa70vxwvqn2e0srft</code>.</p> <pre><code>stcd tx bank send \\\n     dst1rgjxswhuxhcrhmyxlval0qa70vxwvqn2e0srft\\\n     dst157g6rn6t6k5rl0dl57zha2wx72t633axqyvvwq \\\n     50000000000000000000dst \\\n     --gas=200000 \\\n     --fees=1000000dst \\\n     --chain-id=daodst_7000-1 \\\n     --generate-only &gt; unsignedTx.json\n</code></pre> <p>The file <code>unsignedTx.json</code> contains unsigned transactions encoded in JSON.</p> <pre><code>{\n  \"body\": {\n    \"messages\": [\n      {\n        \"@type\": \"/cosmos.bank.v1beta1.MsgSend\",\n        \"from_address\": \"dst1rgjxswhuxhcrhmyxlval0qa70vxwvqn2e0srft\",\n        \"to_address\": \"dst157g6rn6t6k5rl0dl57zha2wx72t633axqyvvwq\",\n        \"amount\": [\n          {\n            \"denom\": \"dst\",\n            \"amount\": \"5000000000000000000\"\n          }\n        ]\n      }\n    ],\n    \"memo\": \"\",\n    \"timeout_height\": \"0\",\n    \"extension_options\": [],\n    \"non_critical_extension_options\": []\n  },\n  \"auth_info\": {\n    \"signer_infos\": [],\n    \"fee\": {\n      \"amount\": [\n        {\n          \"denom\": \"dst\",\n          \"amount\": \"1000000\"\n        }\n      ],\n      \"gas_limit\": \"200000\",\n      \"payer\": \"\",\n      \"granter\": \"\"\n    }\n  },\n  \"signatures\": []\n}\n</code></pre>"},{"location":"protocol/multsign/#step-3-sign-alone","title":"Step 3: Sign alone","text":"<p>Sign with <code>test1</code> and <code>test2</code> and create individual signatures.</p> <pre><code>stcd tx sign \\\n     unsignedTx.json \\\n     --multisig=dst1e0fx0q9meawrcq7fmma9x60gk35lpr4xk3884m \\\n     --from=test1 \\\n     --output-document=test1sig.json\\\n     --chain-id=daodst_7000-1\n</code></pre> <pre><code>stcd tx sign \\\n     unsignedTx.json \\\n     --multisig=dst1e0fx0q9meawrcq7fmma9x60gk35lpr4xk3884m\\\n     --from=test2 \\\n     --output-document=test2sig.json\\\n     --chain-id=daodst_7000-1\n</code></pre>"},{"location":"protocol/multsign/#step-4-create-multisig","title":"Step 4: Create Multisig","text":"<p>Combined with the signature to sign the transaction.</p> <pre><code>stcd tx multisign \\\n     unsignedTx.json \\\n     multi \\\n     test1sig.json test2sig.json\\\n     --output-document=signedTx.json\\\n     --chain-id=daodst_7000-1\n</code></pre> <p>TX is now signed:</p> <pre><code>{\n  \"body\": {\n    \"messages\": [\n      {\n        \"@type\": \"/cosmos.bank.v1beta1.MsgSend\",\n        \"from_address\": \"dst1rgjxswhuxhcrhmyxlval0qa70vxwvqn2e0srft\",\n        \"to_address\": \"dst157g6rn6t6k5rl0dl57zha2wx72t633axqyvvwq\",\n        \"amount\": [\n          {\n            \"denom\": \"dst\",\n            \"amount\": \"5000000000000000000\"\n          }\n        ]\n      }\n    ],\n    \"memo\": \"\",\n    \"timeout_height\": \"0\",\n    \"extension_options\": [],\n    \"non_critical_extension_options\": []\n  },\n  \"auth_info\": {\n    \"signer_infos\": [\n      {\n        \"public_key\": {\n          \"@type\": \"/cosmos.crypto.multisig.LegacyAminoPubKey\",\n          \"threshold\": 2,\n          \"public_keys\": [\n            {\n              \"@type\": \"/cosmos.crypto.secp256k1.PubKey\",\n              \"key\": \"ApCzSG8k7Tr4aM6e4OJRExN7cNtvH21L9azbh+uRrvt4\"\n            },\n            {\n              \"@type\": \"/cosmos.crypto.secp256k1.PubKey\",\n              \"key\": \"Ah91erz8ChNanqLe9ea948rvAiXMCRlR5Ka7EE/c0xUK\"\n            },\n            {\n              \"@type\": \"/cosmos.crypto.secp256k1.PubKey\",\n              \"key\": \"A0OjtIUCFJM3AobJ9HJTWKP9RZV2+WPcwVjLgsAidrZ/\"\n            }\n          ]\n        },\n        \"mode_info\": {\n          \"multi\": {\n            \"bitarray\": {\n              \"extra_bits_stored\": 3,\n              \"elems\": \"wA==\"\n            },\n            \"mode_infos\": [\n              {\n                \"single\": {\n                  \"mode\": \"SIGN_MODE_LEGACY_AMINO_JSON\"\n                }\n              },\n              {\n                \"single\": {\n                  \"mode\": \"SIGN_MODE_LEGACY_AMINO_JSON\"\n                }\n              }\n            ]\n          }\n        },\n        \"sequence\": \"1\"\n      }\n    ],\n    \"fee\": {\n      \"amount\": [\n        {\n          \"denom\": \"dst\",\n          \"amount\": \"1000000\"\n        }\n      ],\n      \"gas_limit\": \"200000\",\n      \"payer\": \"\",\n      \"granter\": \"\"\n    }\n  },\n  \"signatures\": [\n    \"CkCEeIbeGc+I1ipZuhp/0KhVNnWAv2tTlvgo5x61lzk1KHmLPV38m/YFurrFt5cm5+fqIXrn+FlOjrJuzBhw8ogYCkCawm9mpXsBHk0CFsE5618fVnvScEkfrzW0c2jCcjqV8EPuj3ut74UWzZyQkwtJGxUWtro9EgnGsB7Di1Gzizst\"\n  ]\n}\n</code></pre>"},{"location":"protocol/multsign/#step-5-broadcast-transaction","title":"Step 5: broadcast transaction","text":"<pre><code>stcd tx broadcast signedTx.json \\\n    --chain-id=daodst_7000-1 \\\n    --broadcast-mode=block\n</code></pre>"},{"location":"protocol/pending/","title":"waiting queue","text":"<p>When a transaction is submitted to the Ethereum network, it first enters the pending state, waiting for the node to execute it.</p> <p>If the gas price in a transaction is set very low and the node is busy processing other transactions with higher gas prices, the transaction may remain pending for a longer period of time.</p> <p>During the pending state, transaction initiators are allowed to change transaction fields at any time.</p> <p>They can do this by sending another transaction with the same nonce.</p>"},{"location":"protocol/pending/#prerequisites-to-read","title":"Prerequisites to read","text":"<ul> <li>Cosmos SDK Mempool</li> </ul>"},{"location":"protocol/pending/#daodst-vs-ethereum","title":"Daodst vs Ethereum","text":"<p>In Ethereum, pending blocks are generated when miners are queued for production.</p> <p>These pending blocks consist of pending transactions picked by miners based on the highest gas reward paid.</p> <p>This mechanism exists because block finality is not possible on the Ethereum network.</p> <p>Blocks are committed with probabilistic determinism, meaning that over time (and blocks) transactions and blocks become less likely to be reverted.</p> <p>Daodst is designed completely differently in this regard, as there is no concept of \"pending state\".</p> <p>Daodst uses Tendermint Core BFT consensus to provide instant finality for transactions.</p> <p>For this reason, Ethermint does not need to suspend the state mechanism, since all (if not most) transactions will be committed to the next block (the average block time on the Cosmos chain is about 8 seconds).</p> <p>However, this causes problems with some Ethereum Web3 compatible queries, which may enter a pending state.</p> <p>Another notable difference from Ethereum is that blocks are generated by validators, or block producers, who include transactions from their local mempool into blocks in a first-in-first-out (FIFO) fashion.</p> <p>Transactions on Daodst cannot be ordered or picked from the Tendermint node mempool.</p>"},{"location":"protocol/pending/#pending-status-queue","title":"Pending status queue","text":"<p>Daodst will make queries to account for any unconfirmed transactions that exist in the node's transaction mempool.</p> <p>Pending state queries made will be subjective and will be queried on the mempool of the target node.</p> <p>So for the same query on two different nodes, the pending status will not be the same.</p> <p> JSON-RPC Calls on Pending Transactions </p> <ul> <li><code>eth_getBalance</code></li> <li><code>eth_getTransactionCount</code></li> <li><code>eth_getBlockTransactionCountByNumber</code></li> <li><code>eth_getBlockByNumber</code></li> <li><code>eth_getTransactionByHash</code></li> <li><code>eth_getTransactionByBlockNumberAndIndex</code></li> <li><code>eth_sendTransaction</code></li> </ul>"},{"location":"protocol/state-migrate/","title":"State import and export","text":"<p>Daodst can dump the entire application state into a JSON file. In addition to upgrade, this is useful for manually analyzing the status at a specified height.</p>"},{"location":"protocol/state-migrate/#export-status","title":"export status","text":"<p>Export status:</p> <pre><code>stcd export &gt; new_genesis.json\n</code></pre> <p>You can also export state from a specific height (at the end of the block that handles that height):</p> <pre><code>stcd export --height [height] &gt; new_genesis.json\n</code></pre> <p>If you plan to start a new network with height 0 (i.e. genesis) from the exported state, export with the <code>--for-zero-height</code> flag:</p> <pre><code>stcd export --height [height] --for-zero-height &gt; new_genesis.json\n</code></pre>"},{"location":"protocol/state-migrate/#manually-migrate-state","title":"Manually migrate state","text":"<p>If you want to migrate state manually, e.g. for local testing purposes. Note that for regular chain upgrades, no manual state migration is required.</p> <p>After exporting state to json file, you can replace old <code>genesis.json</code> with <code>new_genesis.json</code></p> <pre><code>cp -f genesis.json new_genesis.json\nmv new_genesis.json genesis.json\n</code></pre> <p>At this point, you may want to run a script to update the exported genesis to a genesis state compatible with your new version.</p> <p>You can migrate from a given version to the next version (eg: <code>v0.X.X</code> to <code>v1.X.X</code>) using the <code>migrate</code> command:</p> <pre><code>stcd migrate TARGET_VERSION GENESIS_FILE --chain-id=&lt;new_chain_id&gt; --genesis-time=&lt;yyyy-mm-ddThh:mm:ssZ&gt;\n</code></pre>"},{"location":"protocol/transfer/","title":"Transfer","text":"<p>A transaction is an action initiated by an account that changes the state of the blockchain. In order to perform state changes efficiently, each transaction is broadcast to the entire network.</p> <p>Any node can broadcast a transaction requesting execution on the blockchain state machine; once this occurs, validators will validate, execute the transaction, and propagate the resulting state change to the rest of the network.</p> <p>To process each transaction, computing resources on the network are consumed. Thus, the concept of <code>gas</code> emerged as a reference to the computation required by a validator to process a transaction.</p> <p>Users have to pay for this computation, and all transactions have an associated fee. The fee is calculated based on the gas and gas price required to execute the transaction.</p> <p>Additionally, transactions need to be signed with the sender's private key. This proves that transactions can only come from the sender and not sent fraudulently.</p> <p>In short, the transaction life cycle after submitting a signed transaction to the network is as follows:</p> <ul> <li>Transaction hashes are cryptographically generated.</li> <li>The transaction is broadcast to the network and added to the pool of all other pending network transactions.</li> <li>A validator has to pick your transaction and include it in a block in order to validate the transaction and consider it \"successful\".</li> </ul> <p>For a more detailed explanation of the transaction lifecycle, see the corresponding section.</p> <p>A transaction hash is a unique identifier that can be used to check transaction information, for example, whether the emitted event was successful.</p> <p>Transactions can fail for various reasons. For example, the gas or fee provided may not be sufficient. Additionally, transaction validation may fail.</p> <p>Each transaction has specific conditions that must be met in order to be considered valid. A broad verification is that the sender is the transaction signer.</p> <p>In this case, if you send the transaction where the sender's address is different from the signer's address, the transaction will fail even if the fee is sufficient.</p> <p>Today, transactions can not only make state transitions on the chain they were committed to, but they can also be transacted on another blockchain.</p> <p>Inter-chain transactions can be implemented through the Inter-Blockchain Communication Protocol (IBC).</p> <p>Find a more detailed explanation in the sections below.</p>"},{"location":"protocol/transfer/#transaction-type","title":"Transaction Type","text":"<p>Daodst supports two transaction types:</p> <ol> <li>Cosmos transactions</li> <li>Ethereum transactions</li> </ol> <p>This is possible because Daodst uses the Cosmos-SDK and implements the Ethereum Virtual Machine as a module.</p> <p>In this way, Daodst provides the features and functionality of the combined Ethereum and Cosmos chains, and more.</p> <p>Although most of the information contained in these two transaction types is similar, there are differences between them.</p> <p>An important difference is that Cosmos transactions allow multiple messages to be sent in the same transaction.</p> <p>In contrast, Ethereum transactions do not have this possibility.</p> <p>To bring these two types together, Daodst implements Ethereum transactions as a single <code>sdk.Msg</code> Included in <code>auth.StdTx</code>.</p> <p>This message contains all relevant Ethereum transaction information.</p> <p>This includes signatures, gases, payloads, etc.</p> <p>Find out more about both types in the following sections.</p>"},{"location":"protocol/transfer/#cosmos-transactions","title":"Cosmos Transactions","text":"<p>On the Cosmos chain, transactions are triggered by the metadata held in the context and the <code>sdk.Msg</code> of state changes within the module through the module's Protobuf Msg service composition/message service).</p> <p>When users want to interact with the application and change state (such as sending coins), they create transactions. A Cosmos transaction can have multiple <code>sdk.Msg</code>. Before a transaction can be broadcast to the network, each of them must be signed with the private key associated with the appropriate account.</p> <p>A Cosmos transaction includes the following information:</p> <ul> <li><code>Msgs</code>: an array of messages (<code>sdk.Msg</code>)</li> <li><code>GasLimit</code>: an option chosen by the user to calculate how much gas they need to pay</li> <li><code>FeeAmount</code>: the maximum amount the user is willing to pay</li> <li><code>TimeoutHeight</code>: the effective block height of the transaction</li> <li><code>Signatures</code>: array of signatures from all signers of tx</li> <li><code>Memo</code>: notes or comments sent with the transaction</li> </ul> <p>To submit Cosmos transactions, users must use one of the provided clients.</p>"},{"location":"protocol/transfer/#ethereum-transactions","title":"Ethereum Transactions","text":"<p>An Ethereum transaction refers to an operation initiated by an EOA (externally owned account, managed by a human), not an internal smart contract call. Ethereum transactions change the state of the EVM and therefore must be broadcast to the entire network.</p> <p>Ethereum transactions also require a fee, called <code>gas</code>. (EIP-1559) introduced the concept of base fees, as well as priority fees, to incentivize miners to include specific transactions in blocks.</p> <p>Ethereum transactions are divided into several categories:</p> <ul> <li>Regular transactions: transactions from one account to another</li> <li>Contract deployment transaction: a transaction without a <code>to</code> address, the contract code is sent in the <code>data</code> field</li> <li>Execution of the contract: a transaction that interacts with the deployed smart contract, where the <code>to</code> address is the smart contract address</li> </ul> <p>An Ethereum transaction includes the following information:</p> <ul> <li><code>recipient</code>: recipient address</li> <li><code>signature</code>: the sender's signature</li> <li><code>nonce</code>: a counter from the account's tx number</li> <li><code>value</code>: Amount of ETH to transfer (in wei)</li> <li><code>data</code>: Include arbitrary data. Used when deploying smart contracts or making smart contract method calls</li> <li><code>gasLimit</code>: the maximum amount of gas to consume</li> <li><code>maxPriorityFeePerGas</code>: mas gas as validator tip</li> <li><code>maxFeePerGas</code>: the maximum amount of gas paid for tx</li> </ul> <p>For more information on Ethereum transactions and the transaction lifecycle, go here.</p> <p>Daodst supports the following Ethereum transactions.</p> <p>\ud83d\udce3 Tip : Unprotected legacy transactions are not supported by default. :::</p> <ul> <li>Dynamic fee transactions (EIP-1559)</li> <li>Access list transactions (EIP-2930)</li> <li>Legacy transactions (EIP-2718)</li> </ul> <p>Daodst is capable enough to handle them through the Ethereum transaction package on <code>sdk.Msg</code>. Daodst achieves this by using <code>MsgEthereumTx</code>. This message encapsulates the Ethereum transaction as an SDK message and contains necessary transaction data fields.</p> <p>A note about <code>MsgEthereumTx</code> is that it implements <code>sdk.Msg</code> and <code>sdk.Tx</code> interfaces at the same time (generally SDK messages only appear in the former, while the latter is a set of messages peeling off.</p> <p>The reason for this is because <code>MsgEthereumTx</code> cannot be included in <code>auth.StdTx</code> (the SDK's standard transaction type), because it uses Geth's Ethereum send instead of the Cosmos SDK `in token An.</p>"},{"location":"protocol/transfer/#inter-chain-transaction","title":"Inter-chain transaction","text":"<p>Cross-chain transactions refer to the transfer of digital assets or data between two or more different blockchain networks.</p> <p>Each blockchain network has its own unique protocols and data structures, making it difficult to transfer assets or data directly from one blockchain to another. Cross-chain transactions allow assets and data to be transferred between different blockchains by using an intermediary mechanism or protocol.</p> <p>One such mechanism is a cross-chain bridge, which acts as a connector between different blockchains, enabling the transfer of assets or data.</p> <p>Cross-chain bridges typically require some form of trust or consensus mechanism to ensure the security and integrity of transactions.</p> <p>Another possibility is to use the IBC (Inter-Blockchain Communication) protocol.</p> <p>To use IBC for cross-chain transactions, users need to:</p> <ul> <li>Select the source and target blockchain networks between which the user wants to transfer assets or data.</li> <li>Ensure that both blockchain networks implement the IBC protocol</li> <li>Ensure connection and channel between two blockchain networks using IBC</li> <li>Initiate the transfer of assets or data: this is done by sending a transaction from the source blockchain to the target blockchain through the IBC channel</li> </ul> <p>As the number of different blockchain networks and applications continues to grow, cross-chain transactions are becoming increasingly important. They support the interoperability of different blockchain networks, enabling greater flexibility and efficiency in the transfer of digital assets and data.</p>"},{"location":"protocol/transfer/#transaction-credentials","title":"Transaction Credentials","text":"<p>A transaction receipt shows the data returned by an Ethereum client to represent the outcome of a particular transaction, including the transaction's hash, block number, amount of gas used, and, in the case of a smart contract deployed, the contract address. Additionally, it includes custom information from events emitted in smart contracts.</p> <p>The receipt contains the following information:</p> <ul> <li><code>transactionHash</code>: The hash of the transaction.</li> <li><code>transactionIndex</code>: Integer of transaction index position in the block.</li> <li><code>blockHash</code>: The hash value of the block where the transaction is located.</li> <li><code>blockNumber</code>: The block number where the transaction is located.</li> <li><code>from</code>: The address of the sender.</li> <li><code>to</code>: The recipient's address. null when it is a contract creation transaction.</li> <li><code>cumulativeGasUsed</code>: The total amount of gas used when executing this transaction in the block.</li> <li><code>effectiveGasPrice</code>: The sum of the base fee and the tip paid per unit of gas.</li> <li><code>gasUsed</code>: The amount of gas used by this particular transaction only.</li> <li><code>contractAddress</code>: the address of the created contract, if the transaction is a contract creation, otherwise it is empty.</li> <li><code>logs</code>: Array of log objects generated by this transaction.</li> <li><code>logsBloom</code>: Bloom filter for light clients to quickly retrieve related logs.</li> <li><code>type</code>: integer of transaction type, 0x00 for old transaction, 0x01 for access list type,   0x02 is for dynamic fees. It also returns.</li> <li><code>root</code>: transaction state root (pre-Byzantine)</li> <li><code>status</code>: 1 (success) or 0 (failure)</li> </ul>"},{"location":"protocol/stcd/","title":"CLI","text":"<p><code>stcd</code> is an all-in-one Command Line Interface (CLI). It allows you to run Daodst chain nodes, manage wallets and interact with Daodst network through queries and transactions. This introduction will explain how to install the <code>stcd</code> binary on your system and walk you through some simple examples on how to use stcd.</p>"},{"location":"protocol/stcd/#prerequisites","title":"prerequisites","text":""},{"location":"protocol/stcd/#go","title":"Go","text":"<p>Daodst is built using Go version <code>1.20+</code>. Check your version:</p> <pre><code>go version\n</code></pre> <p>Once the correct version is installed, confirm that your <code>GOPATH</code> is properly configured by running the following command and adding it to your shell startup script:</p> <pre><code>export PATH=$PATH:$(go env GOPATH)/bin\n</code></pre>"},{"location":"protocol/stcd/#jq","title":"jq","text":"<p>Daodst scripts use jq version <code>1.6+</code>. Check your version:</p> <pre><code>jq --version\n</code></pre>"},{"location":"protocol/stcd/#install","title":"Install","text":"<p>You can build and install <code>stcd</code> binaries from source.</p>"},{"location":"protocol/stcd/#build-from-source","title":"Build from source","text":"<p>Clone and build Daodst from source using <code>git</code>. <code>&lt;tag&gt;</code> refers to the release tag on Github. Latest Daodst Version</p> <pre><code>git clone https://github.com/daodst/blockchain.git\ncd blockchain\ngit fetch\ngit checkout &lt;tag&gt;\nmake install\n</code></pre> <p>Once the installation is complete, check that the stcd binary was successfully installed:</p> <pre><code>stcd version\n</code></pre> <p>\ud83d\udce3 Tips: If a <code>stcd: command not found</code> error message is returned, please confirm that you have configured Go correctly.</p>"},{"location":"protocol/stcd/#run-daodst-node","title":"Run Daodst node","text":"<p>To get familiar with Daodst, you can run a local blockchain node to generate blocks and expose EVM and Cosmos endpoints. This allows you to deploy and interact with smart contracts locally or test core protocol functionality.</p> <p>Run local node by executing the <code>local_node.sh</code> script in the base directory of the repository:</p> <pre><code>./local_node.sh\n</code></pre> <p>This script stores node configuration, including local default endpoints under <code>~/.tmp-stcd/config/config.toml</code>. If you have run the script before, this script allows you to override the existing configuration and start a new local node.</p> <p>Once the node is running, you will see it validating and producing blocks in the local Daodst blockchain:</p> <pre><code>12:59PM INF executed block height=1 module=state num_invalid_txs=0 num_valid_txs=0 server=node\n#...\n1:00PM INF indexed block exents height=7 module=txindex server=node\n</code></pre> <p>For more information on how to customize your local node, go to the single-node page.</p>"},{"location":"protocol/stcd/#using-stcd","title":"Using <code>stcd</code>","text":"<p>After installing the <code>stcd</code> binary, you can run commands with:</p> <pre><code>stcd [command]\n</code></pre> <p>There is also a <code>-h</code>, <code>--help</code> command available</p> <pre><code>stcd -h\n</code></pre> <p>Multiple node configurations can be maintained concurrently. To specify configuration, use the <code>--home</code> flag. In the following examples we will use the default configuration of the local node located in <code>~/.tmp-stcd</code>.</p>"},{"location":"protocol/stcd/#manage-wallets","title":"Manage wallets","text":"<p>You can use the stcd binary to manage your wallet to store private keys and sign transactions via the CLI. To see all keys use:</p> <pre><code>stcd keys list \\\n--home ~/.tmp-stcd\\\n--keyring-backend test\n\n# Example Output:\n# - address: dst19xnmslvl0pcmydu4m52h2gf0std5ee5pfgpyuf\n# name: dev0\n# pubkey: '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"AzKouyoUL0UUS1qRUZdqyVsTPkCAFWwxx3+BTOw36nKp\"}'\n# type: local\n</code></pre> <p>You can use <code>$NAME</code> to generate a new key/mnemonic:</p> <pre><code>stcd keys add [name] \\\n--home ~/.tmp-stcd \\\n--keyring-backend test\n</code></pre> <p>Export your daodst key as an Ethereum private key for [Metamask] eg):</p> <pre><code>stcd keys unsafe-export-eth-key [name] \\\n--home ~/.tmp-stcd\\\n--keyring-backend test\n</code></pre> <p>For more information on available key commands, use the <code>--help</code> flag</p> <pre><code>stcd keys -h\n</code></pre> <p>\ud83d\udce3 Tips: For more information on Keyring and its backend options, click here. :::</p>"},{"location":"protocol/stcd/#interacting-with-the-network","title":"Interacting with the network","text":"<p>You can use stcd to query information or submit transactions on the blockchain. Queries and transactions are requests you send to Daodst nodes via Tendermint RPC.</p> <p>\ud83d\udce3 \ud83d\udc49 To use the CLI, you need to provide the Tendermint RPC address to the <code>--node</code> flag. Find publicly available addresses for testnet and mainnet in the [Networks] page.</p>"},{"location":"protocol/stcd/#set-network-configuration","title":"Set network configuration","text":"<p>In the local setup, the node is set to <code>tcp://localhost:26657</code>. You can view your node configuration with:</p> <pre><code>stcd config\\\n--home ~/.tmp-stcd\n# Example Output\n# {\n# \"chain-id\": \"daodst_7000-1\",\n# \"keyring-backend\": \"test\",\n# \"output\": \"text\",\n# \"node\": \"tcp://localhost:26657\",\n# \"broadcast-mode\": \"sync\"\n# }\n</code></pre> <p>You can set up your node configuration to send requests to a different network by changing the endpoint:</p> <pre><code>stcd config node [tendermint-rpc-endpoint] \\\n--home ~/.tmp-stcd\n</code></pre> <p>here for more node configuration.</p>"},{"location":"protocol/stcd/#inquire","title":"Inquire","text":"<p>You can use <code>stcd query</code> (or <code>stcd q</code> for short) to query information on the blockchain. Click to view account balance Addresses stored in the bank module, using:</p> <pre><code>stcd q bank balances [adress] \\\n--home ~/.tmp-stcd\n# # Example Output:\n# balances:\n# - amount: \"99999000000000000000002500\"\n# denom: dst\n</code></pre> <p>To see other available query commands, use:</p> <pre><code># for all Queries\nstcd q\n\n# for querying commands in the bank module\nstcd q bank\n</code></pre>"},{"location":"protocol/stcd/#trade","title":"trade","text":"<p>You can submit transactions to the network using <code>stcd tx</code>. This creates, signs and broadcasts the tx in one command. To use the bank module to send tokens from an account in the keyring to another address, use:</p> <pre><code>stcd tx bank send [from_key_or_address] [to_address] [amount] \\\n--home ~/.tmp-stcd \\\n--fees 50000000000dst \\\n-b block\n\n# Example Output:\n# ...\n# txhash: 7BA2618295B789CC24BB13E654D9187CDD264F61FC446EB756EAC07AF3E7C40A\n</code></pre> <p>To see other available transaction commands, use:</p> <pre><code># for all transaction commands\nstcd tx\n\n# for Bank transaction subcommands\nstcd tx bank\n</code></pre> <p>Now that you know the basics of how to run and interact with the Daodst network, go to Configuration for further customization.</p>"},{"location":"protocol/stcd/command/","title":"CLI commands","text":""},{"location":"protocol/stcd/command/#cli-flags","title":"CLI flags","text":"<p>The following is a list of commonly used flags for stcd:</p> option description type default <code>--chain-id</code> full chain ID <code>string</code> <code>\"\"</code> <code>--home</code> configuration and data directory <code>string</code> <code>directory where binaries are located/.stcd</code> <code>--keyring-backend</code> select keyring backend <code>string</code> <code>\"os\"</code> <code>--output</code> output format <code>string</code> <code>\"text\"</code> <code>--node</code> Tendermint RPC interface address <code>&lt;host&gt;:&lt;port&gt;</code> <code>\"tcp://localhost:26657\"</code> <code>--from</code> name or address of account to sign from <code>string</code> <code>\"\"</code>"},{"location":"protocol/stcd/command/#command-list","title":"command list","text":"<p>List of commonly used <code>stcd</code> commands. You can get a complete list with the <code>stcd -h</code> command.</p> command description subcommand (example) <code>keys</code> key management <code>list</code>, <code>show</code>, <code>add</code>, <code>add --recover</code>, <code>delete</code> <code>tx</code> Transaction subcommands <code>bank send</code>, <code>ibc-transfer transfer</code>, <code>distribution withdraw-all-rewards</code> <code>query</code> query subcommands <code>bank balance</code>, <code>staking validators</code>, <code>gov proposals</code> <code>tendermint</code> Tendermint subcommands <code>show-address</code>, <code>show-node-id</code>, <code>version</code> <code>config</code> Client configuration <code>init</code> Initialize daodst <code>daemon</code> start daodst <code>version</code> Daodst version <code>validate-genesis</code> Validate genesis file <code>status</code> Query remote node status"},{"location":"protocol/stcd/config/","title":"configure","text":"<p>The following pages will guide you through the configuration of nodes and clients. This node is used to run the blockchain network, produce blocks and verify transactions. Clients act as gateways, interacting with the blockchain network by sending transactions and querying state. Additionally, we introduced running the JSON-RPC server.</p> <p>These configurations affect the performance, security, and functionality of the node. Therefore, it is crucial to understand and properly configure your nodes and clients.</p>"},{"location":"protocol/stcd/config/#configuration-and-data-directories","title":"Configuration and data directories","text":"<p>By default, your configuration and data are stored in folders located in the ~/.stcd directory. You can easily change the default directory with the <code>--home</code> flag. It's important to note that you can have multiple home directories, each representing a different blockchain.</p> <pre><code>.# ~/.stcd\n   \u251c\u2500\u2500 data/ # Contains the databases used by the node.\n   \u2514\u2500\u2500 config/\n       \u251c\u2500\u2500 app.toml # Application-related configuration file.\n       \u251c\u2500\u2500 config.toml # Tendermint-related configuration file.\n       \u251c\u2500\u2500 genesis.json # The genesis file.\n       \u251c\u2500\u2500 node_key.json # Private key to use for node authentication in the p2p protocol.\n       \u2514\u2500\u2500 priv_validator_key.json # Private key to use as a validator in the consensus protocol.\n</code></pre> <p>Specifies the <code>stcd</code> configuration and data storage directory; you can update it with the global flag <code>--home &lt;directory&gt;</code>.</p>"},{"location":"protocol/stcd/config/#node-configuration","title":"node configuration","text":"<p>The Cosmos SDK automatically generates two configuration files in <code>~/.stcd/config</code>:</p> <ul> <li><code>config.toml</code>: used to configure Tendermint, read more in Tendermint's documentation, - <code>app .toml</code> : Generated by the Cosmos SDK to configure your application, such as state pruning strategies, telemetry, gRPC and REST server configuration, state sync, JSON-RPC, etc.</li> </ul> <p>Both files are heavily commented, please refer to them directly to tune your node.</p> <p>An example configuration to tune is the <code>minimum-gas-prices</code> field in <code>app.toml</code>, which defines the minimum amount a validator is willing to accept in order to process a transaction. This is an anti-spam mechanism that will reject incoming transactions below a minimum gas price.</p> <p>If it's empty, make sure to edit the field with some value, such as <code>0dst</code>, otherwise the node will stop on startup.</p> <pre><code> # The minimum gas prices a validator is willing to accept for processing a\n # transaction. A transaction's fees must meet the minimum of any denomination\n # specified in this config (e.g. 0.25token1;0.0001token2).\n minimum-gas-prices = \"0dst\"\n</code></pre>"},{"location":"protocol/stcd/config/#state-pruning","title":"State pruning","text":"<p>There are four strategies for pruning state. These policies only apply to state, not to block storage. To set up pruning, adjust the <code>pruning</code> parameter in the <code>~/.stcd/config/app.toml</code> file. The following trim state settings are available:</p> <ul> <li><code>everything</code>: Prune all saved states except the current state.</li> <li><code>nothing</code>: save all state, do not delete anything.</li> <li><code>default</code>: Save the last 100 states and the state every 10,000 blocks.</li> <li><code>custom</code>: Use <code>pruning-keep-recent</code>, <code>pruning-keep-every</code>, and <code>pruning-interval</code> parameters to specify pruning settings.</li> </ul> <p>By default, each node is in <code>default</code> mode, which is the recommended setting for most environments. If you want to change your node pruning strategy, then you must do so at node initialization time. Passing a flag when starting <code>daodst</code> will always override the setting in the <code>app.toml</code> file, if you want to change the node to <code>everything</code> mode, then you can pass the <code>--pruning everything</code> flag when calling <code>stcd stc-start</code>.</p> <p>\ud83d\udea8 Dangerous: When you trim the state, you won't be able to query the height that has been trimmed off.</p>"},{"location":"protocol/stcd/config/#client-configuration","title":"Client Configuration","text":"<p>We can view the default client configuration settings with the <code>stcd config</code> command:</p> <pre><code>stcd config\n{\n  \"chain-id\": \"\",\n  \"keyring-backend\": \"os\",\n  \"output\": \"text\",\n  \"node\": \"tcp://localhost:26657\",\n  \"broadcast-mode\": \"sync\"\n}\n</code></pre> <p>We can make changes to the default settings according to our choice, so it allows the user to pre-set all configurations at once, so that the same configuration can be used afterwards.</p> <p>For example, the chain identifier can be changed from a blank name to <code>daodst_7000-1</code> with the following command:</p> <pre><code>stcd config \"chain-id\" daodst_7000-1\nstcd config\n{\n \"chain-id\": \"daodst_7000-1\",\n \"keyring-backend\": \"os\",\n \"output\": \"text\",\n \"node\": \"tcp://localhost:26657\",\n \"broadcast-mode\": \"sync\"\n}\n</code></pre> <p>Other values can be changed in the same way.</p> <p>Alternatively, we can directly change configuration values in one place in client.toml .</p> <p>Under the <code>.stcd/config/client.toml</code> path in the folder where we installed daodst:</p> <pre><code>############################################################################\n### Client Configuration ###\n\n############################################################################\n\n# The network chain ID\n\nchain-id = \"daodst_7000-1\"\n\n# The keyring's backend, where the keys are stored (os|file|kwallet|pass|test|memory)\n\nkeyring-backend = \"os\"\n\n# CLI output format (text|json)\n\noutput = \"number\"\n\n# &lt;host&gt;:&lt;port&gt; to Tendermint RPC interface for this chain\n\nnode = \"tcp://localhost:26657\"\n\n# Transaction broadcasting mode (sync|async|block)\n\nbroadcast-mode = \"sync\"\n</code></pre> <p>After making the necessary changes in <code>client.toml</code>, then save. For example, if we directly change the chain-id from <code>daodst_7000-1</code> to <code>daodst_7000-2</code> and output it as a number, it will instantly change as shown below.</p> <pre><code>stcd config\n{\n \"chain-id\": \"daodst_7000-2\",\n \"keyring-backend\": \"os\",\n \"output\": \"number\",\n \"node\": \"tcp://localhost:26657\",\n \"broadcast-mode\": \"sync\"\n}\n</code></pre>"},{"location":"protocol/stcd/config/#run-the-json-rpc-server","title":"Run the JSON-RPC server","text":"<p>This section describes the steps to enable a JSON-RPC server. JSON-RPC is provided over several transports. Daodst supports JSON-RPC over HTTP and WebSocket. In terms of requirements, we recommend a server with at least an 8-core CPU and 64GB of RAM. You must open ports 8545 and 8546 on your firewall.</p> <p>\ud83d\udce3 Tip: Unless your nodes store an entire copy of the blockchain locally, you cannot use all JSON RPC methods. Do you need an archive/snapshot of our network? Go to this section.</p>"},{"location":"protocol/stcd/config/#enable-server","title":"Enable server","text":"<p>To enable the RPC server, use the following flag (set to true by default).</p> <pre><code>stcd start --json-rpc.enable\n</code></pre>"},{"location":"protocol/stcd/config/#define-the-namespace","title":"Define the namespace","text":"<p><code>Eth</code>, <code>Net</code> and <code>Web3</code> namespaces are enabled by default, but for JSON-RPC you need to add more namespaces. In order to enable additional namespaces, edit the app.toml file.</p> <pre><code># API defines a list of JSON-RPC namespaces that should be enabled\n# Example: \"eth,txpool,personal,net,debug,web3\"\napi = \"eth,net,web3,txpool,debug,personal\"\n</code></pre>"},{"location":"protocol/stcd/config/#set-a-gas-amount","title":"Set a Gas amount","text":"<p><code>eth_call</code> and <code>eth_estimateGas</code> define a global gas cap over rpc for DoS protection. You can override the default gas cap value of 25,000,000 by passing a custom value in app.toml:</p> <pre><code># GasCap sets a cap on gas that can be used in eth_call/estimateGas (0=infinite). Default: 25,000,000.\ngas-cap = 25000000\n</code></pre>"},{"location":"protocol/stcd/config/#cors","title":"CORS","text":"<p>If accessing RPC from a browser, you need to enable CORS with the appropriate domain set. Otherwise, JavaScript calls are restricted by the same-origin policy and the request will fail.</p> <p>CORS settings can be updated from <code>app.toml</code></p> <pre><code>###############################################################################\n###                           API Configuration                             ###\n###############################################################################\n\n[api]\n\n# ...\n\n# EnableUnsafeCORS defines if CORS should be enabled (unsafe - use it at your own risk).\nenabled-unsafe-cors = true # default false\n</code></pre>"},{"location":"protocol/stcd/config/#prune","title":"prune","text":"<p>In order for all methods to work, your node must be archival (storing an entire copy of the blockchain locally). Trimming must be disabled. Prune settings can be updated from <code>app.toml</code></p> <pre><code>###############################################################################\n###                           Base Configuration                            ###\n###############################################################################\n\n# The minimum gas prices a validator is willing to accept for processing a\n# transaction. A transaction's fees must meet the minimum of any denomination\n# specified in this config (e.g. 0.25token1;0.0001token2).\n\n# ...\n\n# default: the last 100 states are kept in addition to every 500th state; pruning at 10 block intervals\n# nothing: all historic states will be saved, nothing will be deleted (i.e. archiving node)\n# everything: all saved states will be deleted, storing only the current state; pruning at 10 block intervals\n# custom: allow pruning options to be manually specified through 'pruning-keep-recent', 'pruning-keep-every', &gt;\npruning = \"nothing\"\npruning-keep-recent = \"0\"\npruning-keep-every = \"0\"\npruning-interval = \"0\"\n</code></pre>"},{"location":"protocol/stcd/config/#websocket-server","title":"WebSocket server","text":"<p>Websocket is a two-way transport protocol. A Websocket connection is maintained by both client and server until it is explicitly terminated by one. Most modern browsers support Websockets, which means it has good tools.</p> <p>Because Websockets are bidirectional, the server can push events to the client. This makes Websockets a good choice for use cases involving event subscriptions. Another benefit of Websockets is the low overhead of a single message after the handshake process, making it ideal for sending large numbers of requests. WebSocket server can be enabled from <code>app.toml</code></p> <pre><code># Address defines the EVM WebSocket server address to bind to.\nws-address = \"0.0.0.0:8546\"\n</code></pre>"},{"location":"protocol/stcd/single-node/","title":"single node","text":"<p>After this page, you can run a single-node local network manually or with an already prepared automated script. Running a single-node setup is useful for developers who want to test the functionality of their applications and protocols because of its simplicity and speed. For more complex setups, please refer to the Multi-node setup page.</p>"},{"location":"protocol/stcd/single-node/#prerequisites","title":"prerequisites","text":"<ul> <li>Install</li> </ul>"},{"location":"protocol/stcd/single-node/#automation-script","title":"Automation script","text":"<p>The easiest way to start a local Daodst node is to use the provided helper script, which will create a sensible default configuration for testing purposes:</p> <pre><code>$ local_node.sh\n...\n</code></pre> <p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p> <p>\ud83d\udce3 Tips: To avoid overwriting any data from real nodes used in production, it was decided to store the auto-generated test configuration in <code>~/.tmp-stcd</code> instead of the default <code>$install_path/.stcd</code>.</p> <p>When using the <code>local_node.sh</code> script, it is necessary to extend all <code>stcd</code> commands targeting the local test node with the <code>--home ~/.tmp-stcd</code> flag. This is mandatory because the <code>home</code> directory cannot be stored in the <code>stcd</code> configuration, which can be seen in the output below. For ease of use, it may be wise to export this directory path as an environment variable:</p> <pre><code>$ export TMP=$HOME/.tmp-stcd`\n$ stcd config --home $TMP\n{\n\"chain-id\": \"daodst_7000-1\",\n\"keyring-backend\": \"test\",\n\"output\": \"text\",\n\"node\": \"tcp://localhost:26657\",\n\"broadcast-mode\": \"sync\"\n}\n</code></pre> <p>You can customize local node scripts by changing configuration variables. See the following script excerpt for ideas on what can be adjusted:</p> <pre><code># Customize the name of your keys, the chain-id, moniker of the node, keyring backend, and more\nKEYS[0]=\"dev0\"\nKEYS[1]=\"dev1\"\nKEYS[2]=\"dev2\"\nCHAINID=\"daodst_7000-1\"\nMONIKER=\"localtestnet\"\n# Remember to change to other types of keyring like 'file' in-case exposing to outside world,\n# otherwise your balance will be wiped quickly\n# The keyring test does not require private key to steal tokens from you\nKEYRING=\"test\"\nKEYALGO=\"eth_secp256k1\"\nLOGLEVEL=\"info\"\n# Set dedicated home directory for the stcd instance\nHOMEDIR=\"$HOME/.tmp-stcd\"\n# to trace evm\n#TRACE=\"--trace\"\nTRACE=\"\"\n\n[...]\n\n  # Adjust this set a different maximum gas limit\n  jq '.consensus_params[\"block\"][\"max_gas\"]=\"10000000\"' \"$GENESIS\" &gt;\"$TMP_GENESIS\" &amp;&amp; mv \"$TMP_GENESIS\" \"$GENESIS\"\n\n[...]\n\n</code></pre>"},{"location":"protocol/stcd/single-node/#manual-deployment","title":"Manual deployment","text":"<p>This guide helps you create a single validator node that runs the network locally for testing and other development-related purposes.</p>"},{"location":"protocol/stcd/single-node/#initialize-the-chain","title":"Initialize the chain","text":"<p>Before actually running the node, we need to initialize the chain, most importantly its genesis file. This is done with the <code>init</code> subcommand:</p> <pre><code>$MONIKER=testing\n$KEY=dev0\n$CHAINID=\"daodst_7000-1\"\n\n# The argument $MONIKER is the custom username of your node, it should be human-readable.\nstcd init $MONIKER --chain-id=$CHAINID\n</code></pre> <p>\ud83d\udce3 Tips: You can modify this moniker later by updating the <code>config.toml</code> file.</p> <p>The command above creates all the configuration files your node and validators need to run, as well as a default genesis file which defines the initial state of the network. By default all these configuration files are in <code>~/.stcd</code>, but you can override the location of this folder by passing the <code>--home</code> flag.</p>"},{"location":"protocol/stcd/single-node/#genesis-program","title":"Genesis program","text":""},{"location":"protocol/stcd/single-node/#add-genesis-account","title":"Add genesis account","text":"<p>Before starting the chain, you need to populate the state with at least one account using keyring:</p> <pre><code>stcd keys add my_validator\n</code></pre> <p>After creating the local account, go ahead and grant it some <code>dst</code> tokens in the chain's genesis file. Doing this will also ensure your chain is aware of the existence of this account:</p> <pre><code>stcd add-genesis-account my_validator 10000000000dst\n</code></pre> <p>Now that your account has some tokens, you need to add a validator to your chain.</p> <p>For this guide, you will add your local node (created via the <code>init</code> command above) as a validator for the chain. Validators can be claimed via a special transaction called <code>gentx</code> included in the genesis file before the chain is first launched:</p> <pre><code># Create a gentx\n# NOTE: this command lets you set the number of coins.\n# Make sure this account has some coins with the genesis.app_state.staking.params.bond_denom denom\nstcd add-genesis-account my_validator 1000000000dst,10000000000fm\n</code></pre> <p><code>gentx</code> does three things:</p> <ol> <li>Register the <code>validator</code> account you created as the validator operator account (that is, the account that controls the validator).</li> <li>Delegate the pledged tokens of the provided <code>amount</code> by yourself.</li> <li>Associate the operator account with the Tendermint node public key that will be used to sign blocks. If the <code>--pubkey</code> flag is not provided, it defaults to the local node pubkey created via the <code>stcd init</code> command above.</li> </ol> <p>For more information on <code>gentx</code>, use the following command:</p> <pre><code>stcd gentx --help\n</code></pre>"},{"location":"protocol/stcd/single-node/#collect-gentx","title":"Collect <code>gentx</code>","text":"<p>By default, the genesis file does not contain any <code>gentxs</code>. <code>gentx</code> is a transaction that binds staked tokens present in the genesis file under <code>accounts</code> to a validator, essentially creating a validator at genesis. The chain starts once more than 2/3 validators (weighted by voting power) that are valid <code>gentx</code> recipients come online after <code>genesis_time</code>.</p> <p><code>gentx</code> can be added manually to the genesis file, or via the following command:</p> <pre><code># Add the gentx to the genesis file\nstcd collect-gentxs\n</code></pre> <p>This command will add all <code>gentxs</code> stored in <code>~/.stcd/config/gentx</code> to the genesis file.</p>"},{"location":"protocol/stcd/single-node/#daemon-running-single-node","title":"daemon running single node","text":"<p>Finally, check the <code>genesis.json</code> file for correctness:</p> <pre><code>stcd validate-genesis\n</code></pre> <p>Now that everything is set up, you can finally start your node:</p> <pre><code>stcd daemon\n</code></pre> <p>\ud83d\udce3 Tips: To inspect all available customizable options when running node, use the --help flag.</p> <p>You should see blocks coming in.</p> <p>The preceding commands allow you to run a single node. This is enough for the next section about interacting with this node, But you might want to run multiple nodes at the same time and see how consensus is reached between them.</p> <p>You can then stop the node with <code>Ctrl+C</code>.</p>"},{"location":"protocol/stcd/single-node/#further-configuration","title":"Further configuration","text":""},{"location":"protocol/stcd/single-node/#key-management","title":"Key Management","text":"<p>Run node with the same key each time: replace <code>stcd keys add $KEY</code> in <code>./local_node.sh</code> with:</p> <pre><code>echo \"your mnemonic here\" | stcd keys add $KEY --recover\n</code></pre> <p>\ud83d\udce3 Tips: Daodst currently supports 12-word mnemonics. :::</p> <p>You can generate a new key/mnemonic using:</p> <pre><code>stcd keys add $KEY\n</code></pre> <p>Export your Daodst key as an Ethereum private key (for Metamask for example):</p> <pre><code>stcd keys unsafe-export-eth-key $KEY\n</code></pre> <p>For more information on available key commands, use the <code>--help</code> flag</p> <pre><code>stcd keys -h\n</code></pre>"},{"location":"protocol/stcd/single-node/#keyring-backend-options","title":"Keyring backend options","text":"<p>The instructions above include the command to use <code>test</code> as <code>keyring-backend</code>. This is an insecure keyring that does not require a password and should not be used in production. Otherwise, Daodst supports using file or OS keyring backends for key storage. To create and use a file to store keys instead of the default operating system keyring, add the flag <code>--keyring-backend file</code> to any relevant command and a password prompt will appear via the command line. This can also be saved as a CLI configuration option:</p> <pre><code>stcd config keyring-backend file\n</code></pre> <p>\ud83d\udce3 Tips: For more information on Keyring and its backend options, click here.</p>"},{"location":"protocol/stcd/single-node/#enable-tracing","title":"Enable tracing","text":"<p>To enable tracing while running node, modify the last line of the <code>local_node.sh</code> script to the following command, Where:</p> <ul> <li><code>$TRACER</code> is the EVM tracer type used to collect execution traces from EVM transaction executions (e.g. <code>json|struct|access_list|markdown</code>)</li> <li><code>$TRACESTORE</code> is the output file containing the KVStore trace (e.g. <code>store.txt</code>)</li> </ul> <pre><code>stcd start --evm.tracer $TRACER --tracestore $TRACESTORE --pruning=nothing $TRACE --log_level $LOGLEVEL --minimum-gas-prices=0.0001dst --json-rpc.api eth,txpool,personal,net ,debug,web3\n</code></pre>"},{"location":"protocol/stcd/single-node/#clear-data-from-the-chain","title":"Clear data from the chain","text":""},{"location":"protocol/stcd/single-node/#reset-data","title":"Reset Data","text":"<p>Alternatively, you can reset the blockchain database, delete the node's address book file, and reset <code>priv_validator.json</code> to the genesis state.</p> <p>\ud83d\udce3 Tips: Always be careful when doing <code>stcd unsafe-reset-all</code> if you are running a validator node. If you don't switch <code>chain-id</code>, you should never use this command.</p> <p>\ud83d\udea8 DANGER: Make sure each node has a unique <code>priv_validator.json</code>. DO NOT copy <code>priv_validator.json</code> from old nodes to multiple new nodes. Running two nodes with the same <code>priv_validator.json</code> will result in you dual signing and will be permanently jailed!</p> <p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p> <p>First, delete obsolete files and reset data.</p> <pre><code>rm $install_path/.stcd/config/addrbook.json $install_path/.stcd/config/genesis.json\nstcd tendermint unsafe-reset-all --home .stcd\n</code></pre> <p>Your node is now in pristine state, while keeping the original <code>priv_validator.json</code> and <code>config.toml</code>. If you previously set up any sentinel nodes or full nodes, your nodes will still attempt to connect to them, but may fail if they have not been upgraded.</p>"},{"location":"protocol/stcd/single-node/#delete-data","title":"delete data","text":"<p>Binaries are stored in <code>$install_path/.stcd</code> by default, to remove existing binaries and configurations, run:</p> <pre><code>rm -rf $install_path/.stcd\n</code></pre> <p>To clear all data except the keystore (if the keyring backend is selected), you can then re-run the full node install command from above to start the node again.</p>"},{"location":"protocol/stcd/single-node/#transactions-per-second-tps","title":"Transactions per second (TPS)","text":"<p>To get a cumulative value of transactions per second, we use the Prometheus return value. The Prometheus exporter runs at address http://localhost:8877, so add this section to your Prometheus installation config.yaml file ,As follows</p> <pre><code>global:\nscrape_interval: 10s\n\nexternal_labels:\n   monitor: 'daodst'\n\nscrape_configs:\n- job_name: 'daodst'\n\n   scrape_interval: 10s\n\n   static_configs:\n     - targets: ['localhost:8877']\n</code></pre> <p>Then run Prometheus like this</p> <pre><code>prometheus --config.file=prom_config.yaml\n</code></pre> <p>Then visit the Prometheus dashboard at http://localhost:9090/ and navigate to the expression area and enter the following expression</p> <pre><code>rate(daodst_transactions_processed[1m])\n</code></pre> <p>This will show the speed at which transactions are processed.</p> <p>\ud83d\udce3 Tips: Daodst currently supports 12-word mnemonics.</p>"},{"location":"upgrade/","title":"Overview","text":"<p>Learn how to manage chain upgrades for full nodes and validators. There are 3 different upgrade categories:</p> <ul> <li>Planned or Unplanned: Chained upgrades can be scheduled at a given height via upgrade proposals.</li> <li>BREAKING OR NON-BREAKING: Upgrades can be API or state machine breaking, which affects backwards compatibility.   To fix this, the application state or genesis files need to be migrated in preparation for the upgrade.</li> <li>DATA RESET UPGRADE: Some upgrades require a full data reset to clear the state. This sometimes happens with rollbacks or hard forks.</li> </ul> <p>Additionally, validators can choose how upgrades are managed according to their preferences:</p> <ul> <li>Automatic or manual upgrades: Validators can run the <code>cosmovisor</code> process to perform upgrades automatically or manually.</li> </ul>"},{"location":"upgrade/#plan-to-upgrade","title":"Plan to upgrade","text":"<p>A planned upgrade is a coordinated planned upgrade using the logic of the upgrade module. This facilitates smooth upgrades of Daodst to new (broken) software versions, as it automatically handles state migration for new versions.</p>"},{"location":"upgrade/#governance-proposal","title":"Governance Proposal","text":""},{"location":"upgrade/#governance-proposal_1","title":"Governance Proposal","text":"<p>Governance proposals are a mechanism to coordinate upgrades at a given height or time using <code>SoftwareProposal</code>.</p> <p>\ud83d\udce3 Tips: All governance proposals, including software upgrades, will need to wait until the voting period ends before the upgrade can be implemented. Please consider this duration when submitting software upgrade proposals.</p> <p>If the proposal is passed, the upgrade <code>plan</code> for the specific upgrade logic to migrate the state will be persisted to the blockchain state and scheduled at a given upgrade height. Upgrades can be delayed or accelerated by updating <code>Plan.Height</code> in new proposals.</p>"},{"location":"upgrade/#hard-fork","title":"Hard Fork","text":"<p>A special type of planned upgrade is a hard-fork. In contrast to governance proposals, hard forks do not need to wait for the entire voting period. This makes them ideal for coordinating security holes and patches.</p> <p>The upgraded (forked) block height is set in the application's <code>BeginBlock</code> (i.e. before processing transactions for the block). Once the blockchain reaches that height, it automatically schedules an upgrade \"schedule\" for the same height, which then triggers the upgrade process. After the upgrade, block operations (<code>BeginBlock</code>, transaction processing, and state <code>Commit</code>) continue to proceed normally.</p> <p>\ud83d\udce3 Tips: In order to perform an upgrade hard fork, one needs to first release patch-versions using the <code>BeginBlock</code> upgrade scheduling logic. After +2/3 of the validators have upgraded to the new patch version, their nodes will automatically stop and upgrade the binaries.</p>"},{"location":"upgrade/#unplanned-upgrades","title":"Unplanned upgrades","text":"<p>An unplanned upgrade is one in which all validators need to gracefully stop and shut down their nodes at the same point in the process. This can be done by setting the <code>--halt-height</code> flag when running the <code>stcd start</code> command.</p> <p>If breaking changes occur during an unplanned upgrade (see below), validators will need to migrate state and origins before restarting their nodes.</p> <p>\ud83d\udce3 Tips: The main considerations for unplanned upgrades are the need to export the genesis state and the need to [reset] (#data-reset-upgrades) the blockchain data. This primarily affects infrastructure providers, tools, and clients such as block explorers and clients that must use archive nodes to serve queries for pre-upgrade heights.</p>"},{"location":"upgrade/#destructive-and-non-destructive-upgrades","title":"Destructive and non-destructive upgrades","text":"<p>Upgrades can be classified as breaking or non-breaking/releases according to the semantic versioning (Semver) of the corresponding software release version )(ie <code>vX.Y.Z</code>):</p> <ul> <li>Major Version (<code>X</code>): Backwards incompatible API and state machine breaking changes.</li> <li>Minor Version (<code>Y</code>): New backward compatibility features. These may also be state machine interrupts.</li> <li>Patch Release (<code>Z</code>): Backward compatible bug fixes, minor refactorings and improvements.</li> </ul>"},{"location":"upgrade/#major-versions","title":"Major Versions","text":"<p>If the new version you are upgrading to has breaking changes, you will have to:</p> <ol> <li>Migrating Genesis JSON</li> <li>Migrate application state</li> <li>Restart the node</li> </ol> <p>This is required to prevent double-signing or stopping the chain during consensus.</p> <p>To upgrade the genesis file, you can obtain it from a trusted source, or export it locally using the <code>stcd export</code> command.</p>"},{"location":"upgrade/#minor-version","title":"Minor version","text":"<p>If the new version you are upgrading to has breaking changes, you will have to:</p> <ol> <li>Migration status (if applicable)</li> <li>Restart the node</li> </ol>"},{"location":"upgrade/#patch-version","title":"Patch version","text":"<p>In order to update the patch:</p> <ol> <li>Stop the node</li> <li>Manually download the new release binaries<ol> <li>Restart the node</li> </ol> </li> </ol>"},{"location":"upgrade/#data-reset-upgrade","title":"Data reset upgrade","text":"<p>Data reset upgrades require node operators to completely reset the blockchain state and restart their nodes from a clean state, but with the same validator keys.</p>"},{"location":"upgrade/#automatic-or-manual-upgrade","title":"Automatic or manual upgrade","text":"<p>For each new software release, we strongly recommend that full node and validator operators perform a software upgrade.</p> <p>You can upgrade your node in any of the following ways:</p> <ul> <li>auto upgrades the software version and restarts the node after the upgrade occurs, or</li> <li>Download the new binaries and perform a manual upgrade</li> </ul> <p>Follow the links in the options above to learn how to upgrade your node according to your preferred option.</p>"},{"location":"upgrade/auto/","title":"auto update","text":"<p>We strongly recommend that validators use Cosmovisor to run their nodes. This will allow for smoother upgrades with low downtime, since validators don't have to manually upgrade binaries during upgrades. Instead, users can pre-install new binaries and Cosmovisor will automatically update them based on on-chain software upgrade recommendations.</p> <p><code>cosmovisor</code> is a small process manager for Cosmos SDK application binaries, a governance module that monitors incoming chain upgrade proposals.</p> <p>If it sees a proposal approved, cosmovisor can automatically download the new binary, stop the current binary, switch from the old binary to the new binary, and finally replace the new binary with the new binary. file to restart the node.</p>"},{"location":"upgrade/auto/#prerequisites","title":"prerequisites","text":"<ul> <li>Install Cosmovisor</li> </ul>"},{"location":"upgrade/auto/#1-configure-cosmovisor","title":"1. Configure Cosmovisor","text":"<p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p> <p>Set Cosmovisor environment variables. We recommend setting these in your <code>.profile</code> so that they are set automatically on each session.</p> <pre><code>echo \"# Setup Cosmovisor\" &gt;&gt; ~/.profile\necho \"export DAEMON_NAME=stcd\" &gt;&gt; ~/.profile\necho \"export DAEMON_HOME=$install_path/.stcd\" &gt;&gt; ~/.profile\nsource ~/.profile\n</code></pre> <p>After this, you must create the necessary folders for <code>cosmosvisor</code> in your <code>DAEMON_HOME</code> directory ($install_path/.stcd`) and copy the current binaries.</p> <pre><code>mkdir -p $install_path/.stcd/cosmovisor\nmkdir -p $install_path/.stcd/cosmovisor/genesis\nmkdir -p $install_path/.stcd/cosmovisor/genesis/bin\nmkdir -p $install_path/.stcd/cosmovisor/upgrades\n\ncp $GOPATH/bin/stcd $install_path/.stcd/cosmovisor/genesis/bin\n</code></pre> <p>To check that you are doing this correctly, make sure your <code>cosmovisor</code> and <code>stcd</code> versions are the same:</p> <pre><code>cosmovisor run version\nstcd version\n</code></pre>"},{"location":"upgrade/auto/#2-download-daodst-version","title":"2. Download Daodst version","text":""},{"location":"upgrade/auto/#manual-download","title":"Manual download","text":"<p>Cosmovisor will constantly poll <code>$DAEMON_HOME/data/upgrade-info.json</code> for new upgrade instructions. When upgrading, node operators need to:</p> <ol> <li>Download (NOT INSTALLED) the binaries for the new version</li> <li>Put it under <code>$DAEMON_HOME/cosmovisor/upgrades/&lt;name&gt;/bin</code>, where <code>&lt;name&gt;</code> is the URI-encoded name of the upgrade specified in the software upgrade plan.</li> </ol> <p>Example: For a <code>plan</code> named <code>v3.0.0</code> and the following <code>upgrade-info.json</code>:</p> <pre><code>{\n     \"binaries\": {\n         \"linux/arm64\": \"https://github.com/daodst/blockchain/releases/download/v3.0.0/daodst_3.0.0_Linux_arm64.tar.gz\",\n         \"linux/amd64\": \"https://github.com/daodst/blockchain/releases/download/v3.0.0/daodst_3.0.0_Linux_amd64.tar.gz\",\n         \"windows/x86_64\": \"https://github.com/daodst/blockchain/releases/download/v3.0.0/daodst_3.0.0_Windows_x86_64.zip\"\n     }\n}\n</code></pre> <p>Your <code>cosmovisor/</code> directory should look like this:</p> <pre><code>cosmovisor/\n\u251c\u2500\u2500 current/ # either genesis or upgrades/&lt;name&gt;\n\u251c\u2500\u2500 genesis\n\u2502 \u2514\u2500\u2500 bin\n\u2502 \u2514\u2500\u2500 stcd\n\u2514\u2500\u2500 upgrades\n     \u2514\u2500\u2500 v3.0.0\n         \u251c\u2500\u2500 bin\n         \u2502 \u2514\u2500\u2500 stcd\n         \u2514\u2500\u2500 upgrade-info.json\n</code></pre>"},{"location":"upgrade/auto/#automatic-download","title":"Automatic download","text":"<p>\u26a0\ufe0f NOTE : Automatic downloads do not verify in advance that binaries are available. If there is any problem downloading the binary, <code>cosmovisor</code> will stop and not restart the chain (which might cause it to stop).</p> <p>It is possible to have Cosmovisor auto-download new binaries. Validators can use the automatic download option to prevent unnecessary downtime during upgrades.</p> <p>This option will automatically restart the chain with the upgrade binary once the chain stops at the recommended upgrade-height.</p> <p>The main benefit of this option is that validators can prepare upgrade binaries ahead of time and then relax while upgrading.</p> <p>To set up automatic downloads use set the following environment variables:</p> <pre><code>echo \"export DAEMON_ALLOW_DOWNLOAD_BINARIES=true\" &gt;&gt; ~/.profile\n</code></pre>"},{"location":"upgrade/auto/#3-start-your-node","title":"3. Start your node","text":"<p>Now everything is set up and ready to go, you can start your node.</p> <pre><code>cosmovisor run start\n</code></pre> <p>You're going to need some way to keep the process running all the time. If you are on linux you can do this by creating a service.</p> <pre><code>sudo tee /etc/systemd/system/stcd.service &gt; /dev/null &lt;&lt;EOF\n[Unit]\nDescription=Daodst Chain Daemon\nAfter=network-online.target\n\n[Service]\nUser=$USER\nExecStart=$(which cosmovisor) start\nRestart=always\nRestartSec=3\nLimitNOFILE=infinity\n\nEnvironment=\"DAEMON_HOME=$HOME/.stcd\"\nEnvironment=\"DAEMON_NAME=stcd\"\nEnvironment=\"DAEMON_ALLOW_DOWNLOAD_BINARIES=false\"\nEnvironment=\"DAEMON_RESTART_AFTER_UPGRADE=true\"\n\n[Install]\nWantedBy=multi-user.target\nEOF\n</code></pre> <p>Then update and start the node</p> <pre><code>sudo -S systemctl daemon-reload\nsudo -S systemctl enable stcd\nsudo -S systemctl start stcd\n</code></pre> <p>You can check the status with:</p> <pre><code>systemctl status stcd\n</code></pre>"},{"location":"upgrade/hard-fork/","title":"hard fork upgrade","text":"<p>One of the significant limitations of the normal upgrade procedure via governance is that it needs to wait for the entire voting period.</p> <p>This duration makes it unsuitable for automated upgrades involving patches for security vulnerabilities or other critical components.</p> <p>A faster alternative to using governance is to create a hard fork procedure. This process automatically applies changes to upgrade plans, allowing them to execute at a given block height without creating a governance proposal.</p> <p>The high-level strategy for coordinated upgrades is as follows:</p> <ol> <li>Bugfixes are on private branches that contain breaking changes.</li> <li>Need to create a new patch release (e.g. <code>v8.0.0</code> -&gt; <code>v8.0.1</code>) which contains the hard fork logic and performs upgrades to the next breaking version (e.g. <code>v9.0.0</code>) pre-defined blocks high.</li> <li>Validators upgrade their nodes to a patched version (eg \"v8.0.1\").    In order to successfully perform a hard fork, it is important that enough validators upgrade to the patched version such that they represent at least 2/3 of the total validator voting power.</li> <li>One hour before the upgrade time (corresponding to the upgrade block height), a new main version (such as <code>v9.0.0</code>) containing bug fixes will be released.</li> </ol> <p>IMPORTANT: Posts need to be created 1 hour in advance because It takes about 30 minutes to create release binaries, validators need buffer time to download them and update them cosmovisor setting.</p>"},{"location":"upgrade/list/","title":"upgrade list","text":"<p>Check the details and requirements for each mainnet and testnet upgrade.</p>"},{"location":"upgrade/list/#mainnet","title":"Mainnet","text":"Version Planned Outage Data Reset Manual Upgrade Only Upgrade Height <code>v1.0.0</code> (genesis) <code>N/A</code> <code>N/A</code> <code>N/A</code> \u274c 1"},{"location":"upgrade/list/#test-network","title":"Test network","text":"Version Planned Outage Data Reset Manual Upgrade Only Upgrade Height <code>v1.0.0-beta1</code> (genesis) <code>N/A</code> <code>N/A</code> <code>N/A</code> \u274c 1"},{"location":"upgrade/manual/","title":"Manual upgrade","text":"<p>Learn how to manually upgrade your nodes.</p>"},{"location":"upgrade/manual/#prerequisites","title":"prerequisites","text":"<ul> <li>install stcd</li> </ul>"},{"location":"upgrade/manual/#1-upgrade-daodst-version","title":"1. Upgrade Daodst version","text":"<p>Before upgrading Daodst version. Stop your daodst instance with <code>Ctrl/Cmd+C</code>.</p> <p>Next, upgrade the software to the desired release version. Check out Daodst release page Details about each release.</p> <p>\u26a0\ufe0f NOTE : Make sure the version installed matches the version required for the network you are running (mainnet or testnet).</p> <pre><code>cd blockchain\ngit fetch --all &amp;&amp; git checkout &lt;new_version&gt;\nmake install\n</code></pre> <p>\ud83d\udce3 Tip : If you have trouble at this step, please check that you have the latest stable version of Golang installed.</p> <p>Verify that you have successfully installed Daodst on your system using the <code>version</code> command:</p> <pre><code>$ stcd version --long\n\nname: daodst\nserver_name: daodst\nversion: 3.0.0\ncommit: \nbuild_tags: \ngo: go version go1.20 darwin/amd64\n...\n</code></pre> <p>\ud83d\udce3 Tip: If there is a software version mismatch, check your <code>$PATH</code> to make sure the correct <code>stcd</code> is running.</p>"},{"location":"upgrade/manual/#2-replace-genesis-file","title":"2. Replace Genesis file","text":"<p>\ud83d\udce3 Tip : You can find the latest <code>genesis.json</code> file for mainnet or testnet in the following repositories:</p> <ul> <li>Mainnet: github.com/daodst/mainnet</li> <li>Testnet: github.com/daodst/testnets</li> </ul> <p>Save the new genesis as <code>new_genesis.json</code>. Then, replace the old <code>genesis.json</code> located in the <code>config/</code> directory with <code>new_genesis.json</code>:</p> <pre><code>cd $install_path/.stcd/config\ncp -f genesis.json new_genesis.json\nmv new_genesis.json genesis.json\n</code></pre> <p>\ud83d\udce3 Tips:</p> <p>We recommend using <code>sha256sum</code> to check the hash of the origin of the download against the expected origin.</p> <pre><code>cd ~/.stcd/config\necho \"&lt;expected_hash&gt; genesis.json\" | sha256sum -c\n</code></pre> <p>:::</p>"},{"location":"upgrade/manual/#3-data-reset","title":"3. Data reset","text":"<p>\u26a0\ufe0f Note : If the version you want to upgrade requires a data reset (hard fork), please check here. If this is not the case, you can skip to Reboot.</p> <p>Delete obsolete files and reset data:</p> <pre><code>rm $install_path/.stcd/config/addrbook.json\nstcd tendermint unsafe-reset-all --home $install_path/.stcd\n</code></pre> <p>Your node is now in pristine state, while keeping the original <code>priv_validator.json</code> and <code>config.toml</code>. If you previously set up any sentinel nodes or full nodes, your nodes will still attempt to connect to them, but may fail if they have not been upgraded.</p> <p>\ud83d\udea8 IMPORTANT \ud83d\udea8</p> <p>Make sure each node has a unique <code>priv_validator.json</code>. DO NOT copy <code>priv_validator.json</code> from old nodes to multiple new nodes. Running two nodes with the same <code>priv_validator.json</code> will result in you double signing.</p>"},{"location":"upgrade/manual/#4-restart-the-node","title":"4. Restart the node","text":"<p>To restart a node after a new genesis update, use the <code>daemon</code> command:</p> <pre><code>stcd daemon\n</code></pre>"},{"location":"upgrade/rollback/","title":"rollback","text":"<p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p> <p>Learn how to rollback a chain version if a chain upgrade fails.</p> <p>In order to restore a previous chain version, a validator must restore the following data:</p> <ul> <li>A database containing the state of the previous chain (by default in <code>$install_path/.stcd/data</code>)</li> <li>Validator's <code>priv_validator_state.json</code> file (also in <code>$install_path/.stcd/data</code> by default)</li> </ul> <p>If a validator does not own their database data, another validator should share a copy of the database. Validators will be able to download a copy of the data and validate it before launching their nodes.</p> <p>If validators do not have a backup <code>priv_validator_state.json</code> file, then those validators will not have double-signature protection on their first block.</p>"},{"location":"upgrade/rollback/#restore-status-program","title":"restore status program","text":"<ol> <li> <p>First, stop your node.</p> </li> <li> <p>Then, copy the contents of the backup data directory back to the <code>$DAODST_HOME/data</code> directory (should be <code>$install_path/.stcd/data</code> by default)</p> </li> </ol> <pre><code># Assumes backup is stored in \"backup\" directory\nrm -rf $install_path/.stcd/data\nmv backup/.stcd/data $install_path/.stcd/data\n</code></pre> <ol> <li>Next, install the previous version of Daodst.</li> </ol> <pre><code># from Daodst directory\ngit checkout &lt;prev_version&gt;\nmake install\n## verify version\nstcd version --long\n</code></pre> <ol> <li>Finally, start the node.</li> </ol> <pre><code>stcd daemon\n</code></pre>"},{"location":"upgrade/template/","title":"Upgrade proposal content template","text":"<p>The upgrade includes three parts, the gateway client upgrade, the main chain node upgrade, and the APP upgrade. The gateway and the main chain are divided into two versions, linux and windows, and only support 64-bit systems. The upgrade file package needs to be sha256 encoded, and then spliced \u200b\u200bto the download link according to the given format for file validity verification. The upgrade_script script is suitable for upgrading data or programs that require additional processing besides the client.</p> <p>Execute the sha256 command:</p> <pre><code>sha256sum file\n#output:\n27a1ed5d502d4148f837f2a74c6d87b574ce52391fda253618e60486e0304c5b file\n</code></pre> <ul> <li>Gateway client upgrade proposal content:</li> </ul> <pre><code>{\n  \"gateway\": {\n        \"version\": \"22.09.07\",\n        \"binaries\": {\n            \"linux/amd64\": {\n                \"url\": \"https://example.com/daodst.zip?checksum=sha256:aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f\",\n                \"size\": 123877163\n            },\n            \"windows/amd64\": {\n                \"url\": \"https://example.com/daodst.zip?checksum=sha256:aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f\",\n                \"size\": 123877163\n            }\n        }\n    }\n\n}\n</code></pre> <ul> <li>Main chain node upgrade proposal content:</li> </ul> <pre><code>{\n  \"blockchain\": {\n        \"version\": \"22.10.08\",\n        \"binaries\": {\n            \"linux/amd64\": {\n                \"url\": \"https://example.com/daodst.zip?checksum=sha256:aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f\",\n                \"size\": 123877163\n            },\n            \"windows/amd64\": {\n                \"url\": \"https://example.com/daodst.zip?checksum=sha256:aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f\",\n                \"size\": 123877163\n            }\n        }\n    }\n}\n</code></pre> <ul> <li>APP upgrade proposal content:</li> </ul> <pre><code>{\n    \"app\": {\n        \"version\": \"22.09.07\",\n        \"binaries\": {\n            \"android\": {\n                \"url\": \"https://example.com/gaia.zip?checksum=sha256:aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f\",\n                \"size\": 123877163\n            }\n        }\n    }\n}\n</code></pre> <p>Support for one proposal to upgrade multiple programs:</p> <pre><code>{\n  \"gateway\": {\n        \"version\": \"22.09.07\",\n        \"binaries\": {\n            \"linux/amd64\": {\n                \"url\": \"https://example.com/gaia.zip?checksum=sha256:aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f\",\n                \"size\": 123877163\n            },\n            \"windows/amd64\": {\n                \"url\": \"https://example.com/gaia.zip?checksum=sha256:aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f\",\n                \"size\": 123877163\n            }\n        }\n    },\n  \"blockchain\": {\n        \"version\": \"22.10.08\",\n        \"binaries\": {\n            \"linux/amd64\": {\n                \"url\": \"https://example.com/gaia.zip?checksum=sha256:aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f\",\n                \"size\": 123877163\n            },\n            \"windows/amd64\": {\n                \"url\": \"https://example.com/gaia.zip?checksum=sha256:aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f\",\n                \"size\": 123877163\n            }\n        }\n    },\n    \"app\": {\n        \"version\": \"22.09.07\",\n        \"binaries\": {\n            \"android\": {\n                \"url\": \"https://example.com/gaia.zip?checksum=sha256:aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f\",\n                \"size\": 123877163\n            }\n        }\n    }\n}\n</code></pre>"}]}